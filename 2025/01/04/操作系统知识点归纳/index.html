<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>00 操作系统知识点归纳 笔记 | coo1heisenberg's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.10.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="操作系统知识点归纳 存储结构 为什么计算机要给储存结构分级？ 答： 不同级别的储存结构具有不同的访问速度，CPU 访问 CPU Cache 的延时只需要几纳秒，访问物理内存的延时则是 100 纳秒，速度相差 100 倍，访问磁盘延时就更高了，已经到毫秒级别了，但是访问速度越快的存储器，造价成本"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="coo1heisenberg's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.10.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;border-radius:0 5px 5px 0",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-05-12 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.webp'
    },
    copyright: {"limit":50,"author":"作者: Coo1heisenberg’s BLOG","link":"链接: ","source":"来源: coo1heisenberg's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Project/">Project<sup>3</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/SpringCloud/">SpringCloud<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">2025/04</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">2025/02</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">2025/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">2024/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">2024/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">2024/06</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">2024/05</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Project/">Project<sup>3</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/SpringCloud/">SpringCloud<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon solitude st-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">00 操作系统知识点归纳 笔记</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" href="/" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/caozuoxitong.png" alt="00 操作系统知识点归纳 笔记"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Others/">Others</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-name tags-punctuation">操作系统</span></a></div></div></div></div><h1 class="post-title">00 操作系统知识点归纳 笔记</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2025-01-04 20:05:52"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2025-01-04T12:05:52.000Z">2025-01-04T12:05:52.000Z</time></span><span class="post-meta-date" title="最后更新于 2025-01-06 16:28:01"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2025-01-06T08:28:01.339Z">2025-01-06T08:28:01.339Z</time></span><span class="post-meta-wordcount"><span class="post-meta-separator"></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>操作系统知识点归纳</h1>
<hr>
<h2 id="存储结构"><a class="headerlink" href="#存储结构"></a>存储结构</h2>
<hr>
<h3 id="为什么计算机要给储存结构分级？"><a class="headerlink" href="#为什么计算机要给储存结构分级？"></a>为什么计算机要给储存结构分级？</h3>
<p>答：</p>
<ul>
<li><strong>不同级别的储存结构具有不同的访问速度</strong>，<code>CPU</code> 访问 <code>CPU Cache</code> 的延时只需要几纳秒，访问物理内存的延时则是 100 纳秒，速度相差 100 倍，访问磁盘延时就更高了，已经到毫秒级别了，但是访问速度越快的存储器，造价成本会高很多，容量也比较小</li>
<li><strong>通过分级储存结构，可以将数据按照不同的访问速度、容量和成本要求进行管理</strong>，<code>CPU Cache</code> 用于存储近期频繁访问的数据，内存用于存储当前执行的程序和数据，而硬盘则用于存储大量数据和长期存储</li>
</ul>
<p><strong>补充</strong>：</p>
<p>计算机的存储结构的层级如下图，从上到下，存储的容量越来越大，但是 <code>CPU</code> 访问的速度越来越慢</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104201428538.png" alt="计算机的存储结构的层级" loading="lazy"></p>
<p>下面这张表格是不同层级的存储器之间的成本对比图：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104201500684.png" alt="不同层级的存储器之间的成本对比" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/storage.html">2.2 磁盘比内存慢几万倍？ | 小林coding</a></p>
<hr>
<h3 id="CPU-cache-L1-L2-L3-读取数据的时间量级差距有多大？"><a class="headerlink" href="#CPU-cache-L1-L2-L3-读取数据的时间量级差距有多大？"></a>CPU cache L1 L2 L3 读取数据的时间量级差距有多大？</h3>
<p>答：</p>
<p>差距不大，都是纳秒级别，<code>CPU</code> 访问 <code>CPU Cache L1</code> 的延时大概是 1-2 纳秒，访问 <code>CPU Cache L2</code> 的延时大概是 5-10 纳秒，访问 <code>CPU Cache L3</code> 的延时大概是 10-30 纳秒</p>
<p><strong>补充</strong>：</p>
<p><code>CPU</code> 访问 <code>L1 Cache</code> 只需要 2~4 个时钟周期，访问 <code>L2 Cache</code> 大约 10~28 个时钟周期，访问 <code>L3 Cache</code> 大约 28~68 个时钟周期，而访问内存速度大概在 200~388 个时钟周期之间。如下表格：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104201813158.png" alt="cache L1 L2 L3的CPU访问所需时间对比" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html">2.3 如何写出让 CPU 跑得更快的代码？ | 小林coding</a></p>
<hr>
<h3 id="CPU-缓存对程序性能的影响都体现在哪些方面？"><a class="headerlink" href="#CPU-缓存对程序性能的影响都体现在哪些方面？"></a>CPU 缓存对程序性能的影响都体现在哪些方面？</h3>
<p>答：</p>
<p>程序具有局部性原理，如果一个数据被访问，那么附近的数据很可能也会被访问到，<code>CPU Cache</code> 就是基于这个局部性原理，在访问数据的时候，如果访问的数据不在 <code>CPU Cache</code> 中，不会只从内存读这一个数据，而是会从内存连续加载数据到 <code>CPU Cache</code>，这样相邻的数据都会被缓存在 <code>CPU Cache</code>，那么程序在访问相邻数据的时候，相邻数据就可以直接在缓存中命中，无需访问内存，可以提高访问的效率</p>
<p><strong>补充</strong>：</p>
<p><code>CPU</code> 访问内存的速度，比访问 <code>CPU Cache</code> 的速度慢了 100 多倍，所以如果 <code>CPU</code> 所要操作的数据在 <code>CPU Cache</code> 中的话，这样将会带来很大的性能提升。访问的数据在 <code>CPU Cache</code> 中的话，意味着缓存命中，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快，对于遍历二维数组的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">array[N][N]= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j += <span class="number">1</span>) &#123;</span><br><span class="line">        array[i][j]= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j += <span class="number">1</span>) &#123;</span><br><span class="line">        array[j][i]= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>形式一 的速度会比 形式二 的速度快很多，因为 形式一 可以更好利用 <code>CPU Cache</code>，访问数据的缓存命中率会比较高</li>
<li>当 <code>CPU</code> 访问内存数据时，如果数据不在 <code>CPU Cache</code> 中，则会一次性会连续加载 64 字节大小的数据到<code>CPU Cache</code>，那么当访问 <code>array[0][0]</code> 时，由于该元素不足 64 字节，于是就会往后顺序读取 <code>array[0][8]</code> ~ <code>array[0][15]</code> 到 <code>CPU Cache</code> 中。顺序访问的 <code>array[i][j]</code> 因为利用了这一特点，所以就会比跳跃式访问的 <code>array[j][i]</code> 要快</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html">2.3 如何写出让 CPU 跑得更快的代码？ | 小林coding</a></p>
<hr>
<h2 id="内核态"><a class="headerlink" href="#内核态"></a>内核态</h2>
<hr>
<h3 id="什么是内核？"><a class="headerlink" href="#什么是内核？"></a>什么是内核？</h3>
<p>答：</p>
<ul>
<li>内核 是 操作系统 的核心组件，负责 <strong>管理系统资源</strong>、<strong>提供硬件抽象层</strong>、<strong>调度任务</strong> 和 <strong>实现进程间通信</strong> 等功能</li>
<li>内核是系统中第一个加载的程序，并拥有最高的特权级别，控制整个系统的运行和资源分配。它与用户空间程序进行交互，提供系统调用接口，实现了操作系统的基本功能</li>
</ul>
<p><strong>补充</strong>：</p>
<p>计算机是由各种外部硬件设备组成的，比如：内存、<code>CPU</code>、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以由「内核」作为中间人，让内核作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104203317766.png" alt="内核的位置" loading="lazy"></p>
<ul>
<li>现代操作系统，内核一般会提供 4 个基本能力：
<ol>
<li>管理进程、线程，决定哪个进程、线程使用 <code>CPU</code>，也就是进程调度的能力</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：[14 用户态和内核态：用户态线程和内核态线程有什么区别？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14">https://learn.lianglianglee.com/专栏/重学操作系统-完/14</a>  用户态和内核态：用户态线程和内核态线程有什么区别？.md)</p>
<hr>
<h3 id="内核态和用户态区别？为什么要区分内核态和用户态？"><a class="headerlink" href="#内核态和用户态区别？为什么要区分内核态和用户态？"></a>内核态和用户态区别？为什么要区分内核态和用户态？</h3>
<p>答：</p>
<ul>
<li><code>CPU</code> 将指令分为了 <strong>特权指令</strong> 和 <strong>非特权指令</strong>，然后操作系统根据 <code>CPU</code> 的特权分级机制，把进程的运行空间分为 <strong>内核空间</strong> 和 <strong>用户空间</strong></li>
<li>内核态 具有 最高权限，可以执行 特权指令，直接访问所有系统和硬件资源，而 用户态 不能执行 特权指令，只能执行 非特权指令，所以只能访问受限的资源，比如：不可以直接访问内存、硬盘、网卡等硬件设备，如果要访问这些硬件资源，需要通过 系统调用 的方式，让进程陷入到内核态才能访问这些特权资源</li>
<li>之所以要区分 内核态 和 用户态，目的就是 <strong>为了保证系统的稳定性和安全性</strong>，因为通过限制应用程序对特权指令的访问，可以防止恶意程序直接操作危险的指令导致系统崩溃的问题</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>在 <code>CPU</code> 的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如：清空内存，修改时钟等。如果所有的程序代码都能够直接使用这些指令，那么很有可能我们的系统一天将会死 n 次</li>
<li>所以，<code>CPU</code> 将指令分为 <strong>特权指令</strong> 和 <strong>非特权指令</strong> ，对于较为危险的指令，只允许操作系统本身及其相关模块进行调用，普通的、用户自行编写的应用程序只能使用那些不会造成危险的指令</li>
<li>基于安全的考虑，<code>CPU</code> 提供了特权分级机制，把区域分成了四个 <code>Ring</code>，越往里权限越高，越往外权限越低</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104204217112.png" alt="特权分级机制" loading="lazy"></p>
<ul>
<li>
<p>操作系统根据 <code>CPU</code> 的特权分级机制，把进程的运行空间分为「<strong>内核空间</strong>」和「<strong>用户空间</strong>」，分别对应着上图中， <code>CPU</code> 特权等级的 <code>Ring 0</code> 和 <code>Ring 3</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104204840190.png" alt="Windows虚拟内存与物理内存示意图" loading="lazy"></p>
<ul>
<li>内核空间（<code>Ring 0</code>）具有最高权限，可以直接访问所有硬件资源，比如：硬盘、网卡、内存等</li>
<li>用户空间（<code>Ring 3</code>）只能访问受限资源，不能直接访问内存等硬件设备，过「<strong>系统调用</strong>」陷入到内核中才能访问这些特权资源</li>
<li><strong>为什么要区分 内核态 和 用户态 呢？</strong> 这是为了实现操作系统的核心功能和保证系统的稳定性、安全性以及资源的合理分配。通过区分 内核态 和 用户态，操作系统可以：
<ol>
<li>提供一种安全机制，限制用户程序对系统资源的直接访问，防止恶意程序对系统造成破坏</li>
<li>实现操作系统的核心功能，如管理进程、文件系统、内存管理等，这些功能需要在内核态下执行</li>
<li>实现多任务并发执行，通过在内核态和用户态之间进行切换，操作系统可以在不同的应用程序之间共享处理器资源，实现任务的并发执行</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266950886">Linux系统中，为什么需要区分内核空间与用户空间？ - 知乎</a></p>
<hr>
<h3 id="什么时候会由用户态陷入内核态？"><a class="headerlink" href="#什么时候会由用户态陷入内核态？"></a>什么时候会由用户态陷入内核态？</h3>
<p>答：</p>
<p>主要有三种情况，会导致应用程序 <strong>从 用户态 陷入到 内核态</strong>：</p>
<ol>
<li>应用程序执行 <strong>系统调用</strong> 的时候，会触发一个软件中断（比如：<code>int</code> 指令），会进入 内核态 执行相应的 内核代码，完成后再返回 用户态</li>
<li>当 <strong>应用程序发生异常情况</strong>，如：访问非法内存、除零错误 等，<code>CPU</code> 会触发一个异常，将控制权转移到内核态的 异常处理程序 中</li>
<li>当 <strong>系统接收到外部设备的中断信号</strong>，如：硬件设备的输入 / 输出请求、定时器中断 等，处理器会中断当前的执行，进入 内核态 执行相应的 中断处理程序</li>
</ol>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>有三种方式程序会从 用户态 陷入 内核态</strong>：
<ol>
<li><strong>系统调用</strong>：这是 用户态进程 <strong>主动</strong> 要求切换到 内核态 的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作</li>
<li><strong>异常</strong>：当 <code>CPU</code> 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如：访问非法内存、除零错误等</li>
<li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向 <code>CPU</code> 发出相应的中断信号，这时 <code>CPU</code> 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如：硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作 等</li>
</ol>
</li>
<li>这 3 种方式是系统在运行时由 用户态 转到 内核态 的最主要方式，其中 <strong>系统调用</strong> 可以认为是 <strong>用户进程「主动」发起的</strong>，<strong>异常</strong> 和 <strong>外围设备中断</strong> 则 <strong>是「被动」的</strong></li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://liuyehcf.github.io/2017/08/20/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用 | Liuye Notebook</a></p>
<hr>
<h3 id="系统调用的过程？"><a class="headerlink" href="#系统调用的过程？"></a>系统调用的过程？</h3>
<p>答：</p>
<ul>
<li>当 应用程序 发生 系统调用 的时候，会发生 用户态 和 内核态 的切换，过程是这样的：
<ul>
<li>执行 <strong>系统调用</strong> 的时候，先将 <strong>系统调用名称</strong> 转换为 <strong>系统调用号</strong>，接着将 <strong>系统调用号</strong> 和 <strong>请求的参数</strong> 放到 <strong>寄存器</strong> 中，然后执行 <strong>软件中断命令</strong>，<code>CPU</code> 会从 <strong>用户态</strong> 切换到 <strong>内核态</strong></li>
<li><code>CPU</code> 跳转到 <strong>中断处理程序</strong>，将当前 <strong>用户态</strong> 的现场信息保存到 <strong>内核栈</strong> 中，接着根据 <strong>系统调用号</strong> 从 <strong>系统调用表</strong> 中找到对应的 <strong>系统调用函数</strong>，并将 <strong>寄存器</strong> 中保存的参数取出来，作为函数参数，然后在 <strong>内核</strong> 中执行 <strong>系统调用函数</strong></li>
<li>执行完 <strong>系统调用</strong> 后，执行 <strong>中断返回指令</strong>，<strong>内核栈</strong> 会弹出之前保存的用户态的现场信息，将原来用户态保存的现场恢复回来，这时候 <code>CPU</code> 恢复到 <strong>用户态</strong>，<strong>用户态</strong> 进程恢复执行</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>当程序需要访问硬件资源的时候，比如：内存、硬盘等，就需要通过「<strong>系统调用</strong>」陷入到内核中，才能访问这些特权资源。系统调用可以理解为内核实现的函数，比如：应用程序要通过网卡接收数据，会调用 <code>Socket</code> 的<code>read</code> 函数</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106123011635.png" alt="操作系统接口" loading="lazy"></p>
<p>程序在执行系统调用的过程中会从 用户态 切换到 内核态，再从 内核态 切换到 用户态，过程如下：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106123132830.png" alt="执行系统调用的过程" loading="lazy"></p>
<ul>
<li>
<p>系统调用的过程：</p>
<ol>
<li>从 用户态 到 内核态：当应用程序使用系统调用时，先将 系统调用名称 转换为 系统调用号，接着将「系统调用号」和「请求参数」放到寄存器里，然后执行软件中断指令（<code>int $0x80</code> 指令），产生一个中断，<code>CPU</code> 陷入到 内核态</li>
<li>执行 内核态 逻辑：<code>CPU</code> 跳转到 中断处理程序，先将当前 用户态 的 寄存器（用户态的代码段、数据段、保存参数的寄存器）压入到内核栈中，接着将 系统调用号 从 寄存器 里面取出来，最后根据 系统调用号，在「系统调用表」中找到相应的系统调用函数进行调用，并将寄存器中保存的参数取出来，作为函数参数</li>
<li>从 内核态 到 用户态：执行完系统调用后，执行中断返回指令（<code>iret</code> 指令），内核栈会弹出之前保存的寄存器，将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候 <code>CPU</code> 恢复到 用户态，用户态 进程恢复执行</li>
</ol>
</li>
<li>
<p>一次系统调用过程中的，会发生两次「<code>CPU</code> 上下文切换」（所谓的 <code>CPU</code> 上下文就是 <code>CPU</code> 寄存器 和 程序计数器）</p>
<ol>
<li><strong>第一次 <code>CPU</code> 上下文切换是从 用户态 切换到 内核态</strong>：<code>CPU</code> 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，<code>CPU</code> 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务</li>
<li><strong>第二次 <code>CPU</code> 上下文切换是从 内核态 切换到 用户态</strong>：<code>CPU</code> 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-syscall-overhead/">为什么系统调用会消耗较多资源 - 面向信仰编程</a>、<a target="_blank" rel="noopener" href="https://blog.men.ci/x86-userland-and-syscall/">在 x86 中实现用户态与系统调用 - Menci’s Blog</a></p>
<hr>
<h3 id="用户态和内核态是如何切换的？"><a class="headerlink" href="#用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h3>
<p>答：</p>
<ul>
<li><code>Linux</code> 系统中每个进程都有两个栈，分别是 用户栈 和 内核栈，当应用程序运行在用户态的时候，就会使用用户栈，当应用程序运行在内核态的时候，就会使用内核栈</li>
<li>内核态与用户态的相互切换，其中<strong>最重要的一个步骤就是 用户栈 和 内核栈 的切换</strong></li>
</ul>
<ol>
<li>
<p>用户栈到内核栈：</p>
<ul>
<li>
<p>执行中断指令（<code>int $0x80</code> 指令），中断发生时，<code>CPU</code> 去一个特定的结构（比如：<code>TSS</code>）中，获取该进程的内核栈的地址信息，也就是内核栈的段选择子和栈顶指针（这两个东西是描述内核栈在内存的哪个地址空间），并分别送入 <code>ss</code> 寄存器和 <code>rsp</code> 寄存器，这时候 <code>CPU</code> 就指向了该进程的内核栈的栈顶位置了，这就<strong>完成了用户态到内核态的一次栈的切换</strong></p>
</li>
<li>
<p>然后，<code>IP</code> 寄存器（指令指针寄存器）跳入 中断服务程序 开始执行，中断服务程序 会把 用户态 的所有 寄存器 压入到 内核栈中。如下图，CPU 自动地将用户态栈的段选择子 <code>ss3</code>，和栈顶指针 <code>rsp3</code> 都放到内核态栈里了。这里的数字 <code>3</code> 代表了 <code>CPU</code> 特权级，内核态是 <code>0</code>，用户态是 <code>3</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106124525356.png" alt="用户态栈 vs 内核态栈" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p>内核栈 到 用户栈</p>
<ul>
<li>当中断结束时，中断服务程序 会从 内核栈 里将 <code>CPU</code> 寄存器的值全部恢复，最后再执行 “<code>iret</code>” 指令</li>
<li>将 <code>ss3</code> / <code>rsp3</code> 都弹出栈，并且将这个值分别送到 <code>ss</code> 和 <code>rsp</code> 寄存器中，这时候 <code>CPU</code> 就指向了该进程的用户栈的栈顶位置了，这样就完成了从内核栈到用户栈的一次切换</li>
<li>内核栈的 <code>ss0</code> 和 <code>rsp0</code> 也会被保存到前面所说的 <code>CPU</code> 的一个特定的结构（比如：<code>TSS</code>）中，以供下次切换时使用</li>
</ul>
</li>
</ol>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://liupzmin.com/2021/06/27/theory/stack-insight-01-md/">Stack 顿悟三部曲（1）：从CPU的视角说起 | 兔子先生</a></p>
<hr>
<h3 id="为什么用户态和内核态的相互切换过程开销比较大？"><a class="headerlink" href="#为什么用户态和内核态的相互切换过程开销比较大？"></a>为什么用户态和内核态的相互切换过程开销比较大？</h3>
<p>答：</p>
<ol>
<li><strong>上下文切换</strong>：在 用户态 和 内核态 之间切换时，需要保存当前进程或线程的上下文信息，包括：程序计数器、寄存器状态、栈指针 等。这些 上下文信息 保存在内存中或者内核数据结构中，在切换完成后需要再次加载回来。这个过程会消耗一定的时间和资源</li>
<li><strong>权限切换</strong>：用户态和内核态具有不同的权限级别，内核态拥有更高的特权级别，可以执行一些用户态不可访问的指令和操作。因此，从用户态切换到内核态需要进行特权级别的变更，这个过程也会增加开销</li>
<li><strong>地址空间切换</strong>：用户态 和 内核态 通常有不同的地址空间，为了保护操作系统内核不受用户程序的直接影响，当切换到内核态时需要进行地址空间的切换和映射，这也会增加开销</li>
<li><strong><code>TLB</code> 刷新</strong>：<code>TLB</code> 是 <code>CPU</code> 中的一种缓存，用于存储虚拟地址到物理地址的映射关系。当发生用户态和内核态的切换时，可能导致 <code>TLB</code> 中的缓存无效，需要进行 <code>TLB</code> 刷新，这会引起一定的性能损失</li>
</ol>
<p><strong>补充</strong>：</p>
<ul>
<li>当程序中有系统调用语句，程序执行到系统调用时，首先使用类似 <code>int 80</code> 的 软中断 指令，保存现场，去系统调用，在内核态执行，然后恢复现场，每个进程都会有两个栈，一个 内核态栈 和一个 用户态栈。当 <code>int</code> 中断执行时就会由 用户态栈 转向 内核态栈，系统调用 时需要进行栈的切换，而且内核代码对用户不信任，需要进行额外的检查，而且系统调用的返回过程有很多额外工作，比如：检查是否需要调度等</li>
<li>系统调用 一般都需要保存用户程序得上下文（<code>context</code>），在进入内核的时候需要保存用户态的寄存器，在内核态返回用户态的时候会恢复这些寄存器的内容。这是一个开销的地方。 如果需要在不同用户程序间切换的话，那么还要更新 <code>cr3</code> 寄存器（<code>CR3</code> 含有存放页目录表页面的物理地址），这样会更换每个程序的虚拟内存到物理内存映射表的地址，也是一个比较高负担的操作</li>
</ul>
<hr>
<h2 id="中断"><a class="headerlink" href="#中断"></a>中断</h2>
<hr>
<h3 id="什么是中断？为什么要有中断？"><a class="headerlink" href="#什么是中断？为什么要有中断？"></a>什么是中断？为什么要有中断？</h3>
<p>答：</p>
<p>中断机制的好处是 <strong>化 主动 为 被动</strong>，避免 <code>CPU</code> 轮询等待某条件成立。如果没有中断机制，那么 “某个条件成立” 就需要 <code>CPU</code> 轮询判断，这样就会增加系统的开销。而使用中断机制，就可以在条件成立之后，向 <code>CPU</code> 发送中断事件，强制中断 <code>CPU</code> 执行程序，转而去执行中断处理程序</p>
<p><strong>补充</strong>：</p>
<ul>
<li>在计算机中，<strong>中断 是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的 中断处理程序 来 响应请求</strong></li>
<li>简单来说，中断会让 <code>CPU</code> 停止正在执行的程序，转而让 <code>CPU</code> 去执行中断处理函数程序，执行完再返回原程序。例如：我们敲击键盘的时候，键盘的控制器就会向 <code>CPU</code> 发起一个中断请求。<code>CPU</code> 在接到请求以后，就会停下正在做的工作，把当前的寄存器状态全部保存好，然后去调用中断服务程序。为什么需要中断？我举个生活中取外卖的例子，对比一下有中断和没有中断的场景：
<ul>
<li>如果没有中断机制（外卖员不会打电话给我），我需要一直一直傻傻地盯着看外卖配送员的进度，没办法去干其他事情，直到外卖到了，我才能做其他事情</li>
<li>如果有中断机制（外卖员会打电话给我），我就不需要盯着外卖配送员的进度，我可以做其他事情，等外卖到了，外卖员会打电话给我（中断发生），我才会停下手中地事情，去拿外卖</li>
<li>这里的打电话，其实就是对应计算机里的中断，没接到电话的时候，我可以做其他的事情，只有接到了电话，也就是发生中断，我才会停下当前的事情，去进行另一个事情，也就是拿外卖</li>
</ul>
</li>
<li>从这个例子，我们可以知道，<strong>中断是一种异步的事件处理机制，可以提高系统的并发处理能力</strong></li>
</ul>
<hr>
<h3 id="什么是硬件中断和软件中断？"><a class="headerlink" href="#什么是硬件中断和软件中断？"></a>什么是硬件中断和软件中断？</h3>
<p>答：</p>
<ul>
<li>硬件中断：<strong>由硬件 自动 触发的中断</strong>就属于硬件中断，比如：中断 和 异常 都属于硬件中断，中断是由外部设备触发的，异常是由 <code>CPU</code> 触发的</li>
<li>软件中断：<strong>由软件程序 主动 触发的中断</strong>属于软件中断，比如：<code>INT</code> 指令，<code>Linux</code> 内核提供的系统调用，就是用了 <code>INT 0x80</code> 这种指令</li>
</ul>
<p><strong>补充</strong>：</p>
<p>先来说说中断的分类，以 <code>Intel CPU</code> 作为例子，<code>Intel CPU</code> 提供了三种「中断（动词）」程序执行的机制，分别是：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106130640842.png" alt="中断的分类" loading="lazy"></p>
<ul>
<li>中断（<code>interrupt</code>）：由硬件设备触发，比如：点击一下鼠标、敲一下键盘，这时候外部设备会给 <code>CPU</code> 发送一个中断号，属于异步事件</li>
<li>异常（<code>exception</code>）：<code>CPU</code> 在执行指令时检测到的反常条件，比如：除法异常、错误指令异常，缺页异常等，然后 <code>CPU</code> 自己给自己一个中断号，无需外界给，属于同步事件</li>
<li><code>INT</code> 指令：<code>INT</code> 指令后面跟一个数字，就相当于直接用指令的形式，告诉 <code>CPU</code> 一个中断号。比如：<code>INT 0x80</code>，就是告诉 <code>CPU</code> 中断号是 <code>0x80</code>。<code>Linux</code> 内核提供的系统调用，就是用了 <code>INT 0x80</code> 这种指令</li>
</ul>
<p>根据触发的方式不同，将这三个机制分成两类：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106130348821.png" alt="根据触发方式分类" loading="lazy"></p>
<ul>
<li><strong>中断 和 异常 属于「硬件中断」</strong>，因为他们都是 硬件 自动触发的，中断是由外部设备触发的，异常是由<code>CPU</code> 触发的</li>
<li><strong><code>INT</code> 指令属于「软件中断」</strong>，因为他是由软件程序主动触发的</li>
</ul>
<hr>
<h2 id="Linux-启动"><a class="headerlink" href="#Linux-启动"></a>Linux 启动</h2>
<hr>
<h3 id="说一下-Linux-启动的流程？"><a class="headerlink" href="#说一下-Linux-启动的流程？"></a>说一下 Linux 启动的流程？</h3>
<p>答：</p>
<p>下图展示了 <code>Linux</code> 启动的流程具体步骤：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106131021467.png" alt="Linux启动流程" loading="lazy"></p>
<ul>
<li><strong>第一步</strong>：当我们打开电源时，<code>BIOS</code>（基本输入/输出系统，<code>Basic Input/Output System</code>）或 <code>UEFI</code>（统一可扩展固件接口，<code>Unified Extensible Firmware Interface</code>）固件会从非易失性内存中加载，并执行 <code>POST</code>（开机自检，<code>Power On Self Test</code>）</li>
<li><strong>第二步</strong>：<code>BIOS</code> / <code>UEFI</code> 检测连接到系统的设备，包括 <code>CPU</code>、内存 和 存储设备</li>
<li><strong>第三步</strong>：选择一个启动设备来启动操作系统。可以是 硬盘、网络服务器 或  <code>CD ROM</code></li>
<li><strong>第四步</strong>：<code>BIOS</code> / <code>UEFI</code> 运行引导加载器（<code>GRUB</code>），它提供了一个选择操作系统或内核功能的菜单</li>
<li><strong>第五步</strong>：内核准备就绪后，我们现在切换到用户空间。内核启动 <code>systemd</code> 作为第一个用户空间进程，负责管理进程和服务、探测所有剩余硬件、挂载文件系统并运行桌面环境</li>
<li><strong>第六步</strong>：系统启动时，<code>systemd</code> 默认激活 <code>default.target</code> 单元。同时还会执行其他分析单元</li>
<li><strong>第七步</strong>：系统运行一组启动脚本并配置环境</li>
<li><strong>第八步</strong>：用户将看到一个登录窗口。系统现已准备就绪</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sfpgeXEwM/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0">简述 Linux 的启动过程_哔哩哔哩_bilibili</a></p>
<hr>
<h2 id="进程与线程"><a class="headerlink" href="#进程与线程"></a>进程与线程</h2>
<hr>
<h3 id="进程与线程有什么区别？"><a class="headerlink" href="#进程与线程有什么区别？"></a>进程与线程有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>定义区别</strong>：进程就是运行起来的可执行程序，当我们运行一个可执行程序的时候，就会创建一个或多个进程，创建进程的时候需要分配空间，比如：栈区、文件映射区、堆区、静态区、常量区、代码段，因此也会说进程是资源分配的最小单位；线程则是程序执行的基本单位，每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束</li>
<li><strong>共享资源区别</strong>：每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，彼此<br>
共享同一个地址空间。堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统</li>
<li><strong>上下文切换区别</strong>：进程和线程上下文切换的时候，都会发生内核态和用户态的切换，进程间的切换的时候，除了需要切换 <code>CPU</code> 上下文，还需要切换页表，切换了页表会影响 <code>TLB</code> 的命中率，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换只需要切换 <code>CPU</code> 上下文，不会改变虚拟地址空间，不会影响 <code>TLB</code> 命中率</li>
<li><strong>安全性区别</strong>：并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之多进程不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出</li>
</ul>
<hr>
<h3 id="为什么需要线程？"><a class="headerlink" href="#为什么需要线程？"></a>为什么需要线程？</h3>
<p>答：</p>
<ul>
<li><strong>并发能力</strong>：线程可以实现程序的并发执行，即在同一时间内可以同时执行多个任务，提高了系统的响应速度和资源利用率。通过多线程编程，可以将耗时的操作与其他任务并行执行，提升程序的性能</li>
<li><strong>切换开销</strong>：线程的切换开销比进程小，线程切换只需要切换 <code>CPU</code> 上下文，不会改变虚拟地址空间，不需要重新加载页表，不会影响 <code>TLB</code> 命中率</li>
<li><strong>通信方便</strong>：同一个进程内，多个线程是可以共享进程内存资源的，线程间的通信比进程间的通信更简单和高效</li>
</ul>
<p><strong>补充</strong>：</p>
<p>线程是轻量级的进程，可以从 <strong>并行能力</strong>、<strong>切换开销</strong>、<strong>通信方便</strong> 来说明线程的优势</p>
<p><strong>详细链接</strong>：[17 进程和线程：进程的开销比线程大在了哪里？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17">https://learn.lianglianglee.com/专栏/重学操作系统-完/17</a>  进程和线程：进程的开销比线程大在了哪里？.md)</p>
<hr>
<h3 id="多线程是不是越多越好，太多会有什么问题？"><a class="headerlink" href="#多线程是不是越多越好，太多会有什么问题？"></a>多线程是不是越多越好，太多会有什么问题？</h3>
<p>答：</p>
<ul>
<li>多线程不一定越多越好，过多的线程可能会导致一些问题
<ol>
<li><strong>切换开销</strong>：线程的创建和切换会消耗系统资源，包括 内存 和 <code>CPU</code>。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某个线程崩溃后，可能会导致进程崩溃</li>
<li><strong>死锁的问题</strong>：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>线程数量越多，切换的开销就越高，发生死锁的概率就越大</p>
<hr>
<h3 id="什么时候用单线程，什么时候用多线程呢？"><a class="headerlink" href="#什么时候用单线程，什么时候用多线程呢？"></a>什么时候用单线程，什么时候用多线程呢？</h3>
<p>答：</p>
<ul>
<li>一般在单个逻辑比较简单，而且速度相对来非常快的情况下，我们可以使用 单线程。例如：<code>Redis</code> 处理命令的实现是用了单线程，从内存中快速读取值，避免了加锁的开销</li>
<li>而在逻辑相对来说很复杂的场景，等待时间相对较长又或者是需要大量计算的场景，建议使用多线程来提高系统的整体性能。例如：<code>NIO</code> 时期的文件读写操作、图像处理以及大数据分析等</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>单线程适用于以下情况：
<ol>
<li><strong>简单的程序</strong>：当程序逻辑简单且任务量较少时，使用单线程可以简化代码结构，减少线程切换的开销</li>
<li><strong>需要顺序执行的任务</strong>：例如，需要按照特定的顺序依次执行任务的场景，单线程可以确保任务按照预期的顺序执行</li>
<li><strong>对资源访问有限制</strong>：某些资源（如：共享数据、文件）可能有访问限制，单线程可以避免并发访问造成的竞争和冲突</li>
</ol>
</li>
<li>多线程适用于以下情况:
<ol>
<li><strong>并发处理任务</strong>：当需要同时处理多个任务，且任务之间没有强依赖关系时，使用多线程可以提高程序的并发性和整体性能</li>
<li><strong>大规模计算</strong>：对于需要大量计算的任务，使用多线程可以将计算任务分配给多个线程，加快计算速度</li>
<li><strong>高响应性要求</strong>：多线程可以提高系统的响应性，例如在图形界面应用中，使用多线程可以保持界面的流畅性，同时处理用户输入和后台任务</li>
</ol>
</li>
</ul>
<hr>
<h3 id="线程共享了进程的哪些资源？"><a class="headerlink" href="#线程共享了进程的哪些资源？"></a>线程共享了进程的哪些资源？</h3>
<p>答：</p>
<ul>
<li>线程共享了进程的 <strong>虚拟内存空间</strong>、<strong>文件描述符</strong>、<strong>信号处理器</strong>
<ul>
<li><strong>虚拟内存空间</strong>：意味着线程可以访问进程的代码区、堆区、数据区的资源等</li>
<li><strong>文件描述符</strong>：意味着线程可以通过文件描述符访问进程打开的文件、套接字等资源</li>
<li><strong>信号处理器</strong>：意味着线程可以接收和处理进程收到的信号</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106140618741.png" alt="单线程与多线程的示意图" loading="lazy"></p>
<ul>
<li>同一进程中的线程共享资源
<ol>
<li>虚拟内存空间：共享进程的代码区、堆区、数据区的资源等</li>
<li>文件描述符：共享进程打开的文件、套接字等资源</li>
<li>信号处理器：共享进程的信号处理器</li>
</ol>
</li>
<li>同一进程中的线程独占资源
<ul>
<li>程序计数器和寄存器的值</li>
<li>栈：每个线程中的函数调用过程是独立的，因此需要有独立的栈</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1768025">线程间到底共享了哪些进程资源？-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="为什么创建进程比创建线程慢？"><a class="headerlink" href="#为什么创建进程比创建线程慢？"></a>为什么创建进程比创建线程慢？</h3>
<p>答：</p>
<ul>
<li><code>Linux</code> 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，包含 代码区、堆区、栈区、数据区 等内存资源</li>
<li>创建线程则简单得多，只需要确定 <code>PC</code> 指针和 寄存器 的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用进程的虚拟内存空间，减少了创建虚拟内存的开销</li>
<li>因此，创建进程比创建线程慢，而且进程的内存开销更大</li>
</ul>
<p><strong>补充</strong>：</p>
<p>从创建虚拟内存的成本来考虑</p>
<p><strong>详细链接</strong>：[17 进程和线程：进程的开销比线程大在了哪里？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17">https://learn.lianglianglee.com/专栏/重学操作系统-完/17</a>  进程和线程：进程的开销比线程大在了哪里？.md)</p>
<hr>
<h3 id="为什么进程的切换比线程开销大？"><a class="headerlink" href="#为什么进程的切换比线程开销大？"></a>为什么进程的切换比线程开销大？</h3>
<p>答：</p>
<p>进程间的切换的时候，除了需要切换 <code>CPU</code> 上下文，还需要 切换页表，切换了页表会影响 <code>TLB</code> 的命中率，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换只需要切换 <code>CPU</code> 上下文不会改变虚拟地址空间，不会影响 <code>TLB</code> 命中率</p>
<p><strong>补充</strong>：</p>
<ul>
<li>进程切换分两步：
<ol>
<li>切换「页表」以使用新的地址空间。一旦去切换上下文，<code>CPU</code> 中所有已经缓存的内存地址就失效了</li>
<li>切换内核栈和 <code>CPU</code> 上下文</li>
</ol>
</li>
<li>线程和进程的最大区别就在于地址空间，对于线程切换，第 1 步是不需要做的，第 2 步是进程和线程切换都要做的。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</li>
<li>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 <code>Cache</code> 来缓存常用的地址映射，这样可以加速页表查找，这个 <code>Cache</code> 就是<code>TLB</code>（<code>translationLookaside Buffer</code>，<code>TLB</code> 本质上就是一个 <code>Cache</code>，是用来加速页表查找的）</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106142413280.png" alt="进程与线程的切换" loading="lazy"></p>
<ul>
<li>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 <code>TLB</code> 就失效了，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 <code>TLB</code> 失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快，原因就在这里</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1710837">深入理解Linux内核进程上下文切换-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="线程的上下文切换是怎么个过程？"><a class="headerlink" href="#线程的上下文切换是怎么个过程？"></a>线程的上下文切换是怎么个过程？</h3>
<p>答：</p>
<p>线程发生上下文切换的时候，正在运行的线程会将寄存器的状态保存到内核中的 <code>TCB</code>（线程控制块）里，然后恢复另一个线程的上下文。<strong>和进程的区别是，线程只需要切换 <code>CPU</code> 的上下文，不会改变地址空间</strong></p>
<p><strong>补充</strong>：</p>
<p>当线程切换的时候，当前线程被时钟中断打断，将发生中断时的现场保存到进程内核栈（如：<code>sp</code>、<code>lr</code> 等），然后会切换到下一个线程，当再次回切换回来的时候，返回用户空间的时候会恢复之前的现场，线程就可以继续执行（执行之前被中断打断的下一条指令，继续使用自己用户态<code>sp</code>），这对于用户程序来说是透明的</p>
<p>如下为硬件上下文切换示例图：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106143200103.png" alt="硬件上下文切换" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1710837">深入理解Linux内核进程上下文切换-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="僵尸进程、守护进程与孤儿进程的区别？"><a class="headerlink" href="#僵尸进程、守护进程与孤儿进程的区别？"></a>僵尸进程、守护进程与孤儿进程的区别？</h3>
<p>答：</p>
<ul>
<li>僵尸进程 是指子进程已经终止，但其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取子进程的终止状态，导致子进程的进程描述符仍然保留在系统进程表中，成为僵死进程，僵死进程不占用系统资源，但会占用一个进程<code>ID</code></li>
<li>孤儿进程 是指父进程先于子进程退出或异常终止，导致子进程成为孤儿进程。孤儿进程会被 <code>init</code> 进程（进程<code>ID</code>为1）接管，<code>init</code> 进程会成为孤儿进程的新的父进程</li>
<li>守护进程 是在后台运行的一种特殊进程，不与任何终端关联，关闭终端并不会影响守护进程的生命周期，守护进程的生命周期通常是伴随系统的启动和关闭，会一直在后台运行</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>僵尸进程</strong>（记忆点：儿子死了，爸爸没有收尸，儿子就成僵尸了）：僵尸进程是指终止但还未被回收的进程。如果子进程退出，而父进程并没有调用 <code>wait()</code> 或 <code>waitpid()</code> 来回收，那么就会产生僵尸进程。<strong>僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中</strong>
<ul>
<li><strong>危害</strong>：<strong>占用进程号，系统所能使用的进程号是有限的，可能导致不能产生新的进程；占用一定的内存</strong></li>
<li>如何避免产生僵尸进程：
<ul>
<li>父进程调用 <code>wait</code> 或者 <code>waitpid</code> 等待子进程结束</li>
<li>子进程结束时，内核会发生 <code>SIGCHLD</code> 信号给父进程。父进程可以注册一个信号处理函数，在该函数中调用 <code>waitpid</code>，等待所有结束的子进程；也可以用 <code>signal</code>（<code>SIGCLD</code>，<code>SIG_IGN</code>）忽略 <code>SIGCHLD</code> 信号，那么子进程结束后，内核会进行回收</li>
<li>杀死父进程，僵尸进程就会变成孤儿进程，由 <code>Init</code> 进程接管并处理</li>
</ul>
</li>
</ul>
</li>
<li><strong>孤儿进程</strong>（记忆点：爸爸没了，就是孤儿）：如果某个进程的父进程先结束了，那么它的子进程会成为孤儿进程每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用 <code>Init</code> 进程（<code>pid</code> = 1）接管，并由 <code>Init</code> 进程调用 <code>wait</code> 等待其结束，完成状态收集工作。孤儿进程不会对系统造成危害</li>
<li><strong>守护进程</strong>：守护进程（英语：<code>daemon</code>）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。<code>Linux</code> 系统的大多数服务器就是通过守护进程实现的。守护进程的名称通常以 <code>d</code> 结尾，比如：<code>sshd</code>、<code>xinetd</code>、<code>crond</code> 等，常见的守护进程包括系统日志进程 <code>syslogd</code>、<code>web</code>服务器 <code>htpd</code>、邮件服务器 <code>sendmail</code> 和数据库服务器 <code>mysqld</code>等</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程 | LiuYongbin</a></p>
<hr>
<h3 id="怎么杀死僵尸进程？"><a class="headerlink" href="#怎么杀死僵尸进程？"></a>怎么杀死僵尸进程？</h3>
<p>答：</p>
<p>僵尸进程是已经死了的，不能直接使用 <code>kill</code> 命令杀掉僵尸进程，只能通过 <code>ps</code> 命令找到僵尸进程的父进程的 <code>pid</code> 号，然后通过 <code>kill</code> 命令杀掉父进程的方式来达到僵尸进程的效果，因为当父进程被杀掉后，操作系统会将僵尸进程的父进程会变为 <code>1</code> 号 <code>init</code> 进程，接着 <code>init</code> 进程会自动接管僵尸进程的回收工作</p>
<p><strong>补充</strong>：</p>
<p>可以使用 <code>ps aux | grep z</code> 命令来找到僵尸进程。在状态位带有 <code>2</code> 关键字的进程代表其为僵尸进程。我们可使用 <code>top</code> 命令查看系统中是否有僵尸进程存在</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106151321782.png" alt="top命令" loading="lazy"></p>
<ul>
<li>
<p>正常情况下我们可以用 <code>SIGKILL</code> 信号来杀死进程，但是僵尸进程已经死了，你不能杀死已经死掉的东西</p>
</li>
<li>
<p>所以只能通过杀死僵尸进程的父进程来达到杀死僵尸进程的效果，因为当进程终止时，操作系统会将所有子进程的父进程设置为 <code>init</code> 进程（进程<code>ID</code>为 1），<code>init</code> 进程会自动接管僵尸进程的回收工作</p>
</li>
<li>
<p>因此，要杀掉一个僵尸进程，需找到其父进程号（<code>PPID</code>）并给它发送 <code>SIGKILL(9)</code> 信号：<code>kill -9 ppid</code></p>
</li>
<li>
<p>可使用以下命令去找到僵尸进程的 <code>PPID</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p PID -o ppid</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://linux.cn/article-9143-1.html">技术|什么是僵尸进程，如何找到并杀掉僵尸进程？</a></p>
<hr>
<h3 id="一个进程fork出一个子进程，那么他们占用的内存是之前的2倍吗？"><a class="headerlink" href="#一个进程fork出一个子进程，那么他们占用的内存是之前的2倍吗？"></a>一个进程fork出一个子进程，那么他们占用的内存是之前的2倍吗？</h3>
<p>答：</p>
<ul>
<li>
<p>不是的</p>
<ul>
<li>
<p><code>fork</code> 的时候，创建的子进程是复父进程的虚拟内存，并不是物理内存，这时候父子的虚拟内存指向的是同个物理内存空间，这样能够节约物理内存资源，页表对应的页表项的属性会标记该物理内存的权限为只读</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106152532391.png" alt="写时复制" loading="lazy"></p>
</li>
<li>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，<code>CPU</code> 就会触发写保护中断，这个写保护中断是由于违反权限导致的，然后操作系统会在「<strong>写保护中断处理函数</strong>」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制</strong>」，发生了这个过程，内存占用才会增多</p>
</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>考察写时复制的概念，在发生写操作的时候，操作系统才会去复制物理内存，否则父子进程的物理内存还是共享状态，并不会增加内存占用</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039869422">linux-kernel - Linux 写时复制机制原理 - 个人文章 - SegmentFault 思否</a></p>
<hr>
<h2 id="协程"><a class="headerlink" href="#协程"></a>协程</h2>
<hr>
<h3 id="什么是协程？"><a class="headerlink" href="#什么是协程？"></a>什么是协程？</h3>
<p>答：</p>
<p>协程是一个用户态的线程，用户在堆上模拟出协程的栈空间。当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态，就可以实现上下文切换。<strong>相比于线程上下文切换，没有了从 用户态 转换到 内核态 的切换成本</strong></p>
<p><strong>补充</strong>：</p>
<p>要强调协程是用户态的线程，切换的时候是不需要发生用户态和内核态的切换，相当于是一个轻量级线程</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94018082">从头到尾理解有栈协程实现原理 - 知乎</a></p>
<hr>
<h3 id="协程和线程有什么区别？"><a class="headerlink" href="#协程和线程有什么区别？"></a>协程和线程有什么区别？</h3>
<p>答：</p>
<ul>
<li>协程 可以理解为 用户态线程，跟 线程 的区别主要有三个方面：
<ol>
<li>线程调度由 <strong>内核负责</strong>，协程调度由 <strong>用户负责</strong>，所以协程的切换是比线程快的，因为协程的切换不用经过操作系统用户态与内核态的切换，并且协程的切换只需要保留极少的状态和寄存器变量值，比如：<code>SP</code>、<code>BP</code>、<code>PC</code> 寄存器，而线程的切换会保留额外的寄存器变量值，比如：浮点寄存器</li>
<li>线程的栈比协程的栈大很多，线程的栈大小一般是在创建时指定，默认是大小是 <code>8MB</code>，如果创建成千上万个线程的话，对于系统会有很大的负担，而协程栈通常是 <code>KB</code> 级别的，比如：<code>2KB</code>，所以即使创建上千上万个协程，对于系统来说也不是很大的负担。另外，线程的栈在运行时不能够更改，而协程栈在 <code>Go</code> 运行时的帮助下可以动态检测栈的大小，进行扩容和收缩</li>
<li>协程的调度是<strong>协作式调度</strong>，当一个协程处理完自己的任务后，可以主动将执行权限让给其他协程，而线程是<strong>抢占式调度</strong>，线程的切换的主动权不再线程自己身上。</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
<th><strong>协程</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>资源（包括内存、打开的文件等）分配的单位</td>
<td>CPU 调度的基本单位</td>
<td>用户态轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td><strong>切换情况</strong></td>
<td>进程切换 CPU 环境（栈、寄存器、页表和文件句柄等）的保存以及新调度进程环境的设置</td>
<td>保存和设置程序计数器、寄存器和栈的内容</td>
<td>先将寄存器的上下文和栈保存，等切换回来时进行恢复</td>
</tr>
<tr>
<td><strong>切换过程</strong></td>
<td>用户态 → 内核态 → 用户态</td>
<td>用户态 → 内核态 → 用户态</td>
<td>用户态</td>
</tr>
<tr>
<td><strong>调用栈</strong></td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>不同进程之间实现并发，各自占用 CPU 时间片</td>
<td>一个进程内部多个线程并发执行</td>
<td>同一时间只能有一个协程，而其它协程处于休眠状态，适合对任务分时处理</td>
</tr>
<tr>
<td><strong>系统开销</strong></td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU 高速缓存失效，页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，有一定的开销</td>
<td>直接操作/恢复基本没有内核切换的开销，可以加锁的访问全局变量，开销最小</td>
</tr>
<tr>
<td><strong>通信</strong></td>
<td>进程之间的通信需要借助操作系统</td>
<td>线程之间可以直接写入进程数据段（如全局变量）来进行通信</td>
<td>共享内存，消息队列</td>
</tr>
<tr>
<td><strong>占用内存</strong></td>
<td>依据所调用的资源大小</td>
<td>固定不变，由编译器决定</td>
<td>初始化一般较小，可以自动扩展</td>
</tr>
</tbody>
</table>
<ul>
<li>从 <strong>调度方式</strong>、<strong>切换开销</strong>、<strong>栈大小</strong> 这三个方面来展开说明区别：
<ol>
<li>协程的调度是协作式调度（主动放弃执行，并不会被其他协程打断），当一个协程处理完自己的任务后，可以主动将执行权限让给其他协程。这意味着协程能更好地在规定时间内完成自己的工作，而不会被任意抢占。当一个协作式运行的时间过长，<code>Go</code> 语言调度器才会强制抢占其执行。线程是抢占式调度，当发生中断或者 <code>I/O</code> 的时候，<code>CPU</code> 就会自动切换别的线程，也就是线程的切换的主动权不再线程自己身上</li>
<li>协程的切换要快于线程，因为协程的切换不用经过操作系统用户态与内核态的切换，并且 <code>Go</code> 语言中协程的切换只需要保留极少的状态和寄存器变量值（<code>SP</code> / <code>BP</code> / <code>PC</code>），而线程的切换会保留额外的寄存器变量值（例如：浮点寄存器）。在 <code>Go</code> 语言中，上下文切换速度的一个可参考量化指标是，线程大约为 1~2 微秒，协程大约是 0.2 微秒，比线程快数倍</li>
<li>线程的栈比协程的栈大很多，线程的栈大小一般是在创建时指定，为了避免出现栈溢出（<code>Stack Overflow</code>）的错误，默认的栈大小会相对较大（例如：8M），这意味着创建 1000 个线程就需要消耗 2G 的虚拟内存，这大大限制了线程创建的数量（虽然今天 64 位的虚拟内存地址空间已经让这种限制变得不太严重）。而 <code>Go</code> 语言中的协程栈默认为 2 <code>KB</code>，在实践中，我们经常会看成千上万的协程存在。另外，线程的栈在运行时栈不能够更改，而协程栈在 <code>Go</code> 运行时的帮助下可以动态检测栈的大小，进行扩容和收缩。由于协程栈很小，在实践中，协程常被看作是一种轻量级的资源</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://huweicai.com/process-thread-goroutine/">进程线程协程的本质区别 | Anonymous’ Blog</a></p>
<hr>
<h3 id="协程切换的本质是什么？"><a class="headerlink" href="#协程切换的本质是什么？"></a>协程切换的本质是什么？</h3>
<p>答：</p>
<p>协程的切换本质就是切换 <code>CPU</code> 寄存器，把当前协程的 <code>CPU</code> 寄存器状态保存起来，比如：<code>IP</code>、<code>SP</code>寄存器，然后将需要切换进来的协程的 <code>CPU</code> 寄存器状态加载到 <code>CPU</code> 寄存器上就完成了切换的过程，整个切换过程发生在用户态，不会陷入内核态</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>协程实际上是将函数实现成可以任意中断的函数，比如：函数 1 执行到一半，可以直接切换执行别的函数，给人的感觉就是多个函数在并发，所以协程的切换类似于函数调用栈切换</p>
</li>
<li>
<p>已知函数运行在调用栈上，如果将一个函数作为协程，<strong>保存上下文</strong>即是保存从这个函数栈帧存储的值，以及此时寄存器存储的值；<strong>恢复上下文</strong>即是将这些值分别重新写入对应的栈帧和寄存器；而<strong>切换上下文</strong>无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。下图是协程切换前的状态：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106155319276.png" alt="协程切换前的状态" loading="lazy"></p>
</li>
<li>
<p>从协程 1 切换到协程 2 后的状态如下图所示：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106155423300.png" alt="从协程1切换到协程2后的状态" loading="lazy"></p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/330606651">有栈协程与无栈协程 - 知乎</a></p>
<hr>
<h3 id="为什么协程切换的开销比线程切换小？"><a class="headerlink" href="#为什么协程切换的开销比线程切换小？"></a>为什么协程切换的开销比线程切换小？</h3>
<p>答：</p>
<ul>
<li><strong>用户态切换</strong>：协程的切换是在用户态进行的，不需要操作系统的介入。相比之下，线程的切换需要操作系统进行调度和上下文切换，需要从用户态切换到内核态，这涉及到 <code>CPU</code> 寄存器的保存和恢复等操作，开销较大</li>
<li><strong>协作式调度</strong>：协程的调度是协作式的，由协程自身主动让出执行权，而不是被操作系统强制切换。这种调度方式避免了不必要的上下文切换，减少了切换开销</li>
</ul>
<p><strong>补充</strong>：</p>
<p>从 用户态切换、协作式调度 方式去对比</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://huweicai.com/process-thread-goroutine/">进程线程协程的本质区别 | Anonymous’ Blog</a></p>
<hr>
<h2 id="进程间通信"><a class="headerlink" href="#进程间通信"></a>进程间通信</h2>
<hr>
<h3 id="进程间有哪些通信方式？"><a class="headerlink" href="#进程间有哪些通信方式？"></a>进程间有哪些通信方式？</h3>
<p>答：</p>
<ul>
<li>进程间通信方式主要有 管道、消息队列、共享内存、信号、信号量 和 <code>socket</code> 通信
<ul>
<li>管道通信的数据是 无格式的字节流，并且通信方向是 单向 的，只能在一个方向上流动，管道分为 匿名管道 和 有名管道，匿名管道 是没有文件实体，只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。而有名管道有文件实体，可以用于任何进程间的通信，并且数据可以持久化保存，即使创建它的进程退出，其他进程仍然可以使用该管道</li>
<li>消息队列在内核中是通过链表来组织消息的，克服了管道通信的数据是无格式的问题</li>
<li>管道和消息队列在读写数据的时候，都需要经过用户态与内核态之间的拷贝过程，共享内存就解决了这个问题，多个进程可以将共享内存映射到各自的虚拟地址空间，实现共享数据的读写，不会涉及用户态和内核态之间的数据拷贝，所以共享内存方式是进程间通信方式里最高效的，不过共享内存带来新的问题，多进程竞争同个共享资源会造成数据的错乱，因为需要同步机制来保证多进程下的读写数据的安全</li>
<li>信号量可以实现进程间的同步和互斥访问共享资源，信号量其实是一个计数器，表示的是资源个数，当一个进程想要访问资源时，它会尝试递减信号量（称为<code>P</code>操作）。如果信号量的值大于零，这个操作会成功，否则进程就会阻塞，直到信号量变为正数。当进程完成对资源的访问后，它会递增信号量（称为<code>V</code>操作），允许其他阻塞的进程访问资源</li>
<li>信号是一种异步的通知机制，用于通知进程某个事件已经发生。当一个信号发送给一个进程时，操作系统会中断进程的正常流程来处理信号，只适用于简单的通知和事件处理</li>
<li>前面提到的这些通信方式都只能在本上进行进程间通信，如果要实现跨主机的进程间通信，就需要通过 <code>socket</code> 通信了，可以实现基于 <code>TCP</code> 或者 <code>UDP</code> 协议的通信方式</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>要说出每个通信方式的应用场景和优劣势。
<ul>
<li><strong>管道</strong>：分为 有名管道 和 匿名管道
<ul>
<li>匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中 <code>shell</code> 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失</li>
<li>命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 <code>p</code> 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外,不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 <code>lseek</code> 之类的文件定位操作</li>
</ul>
</li>
<li><strong>消息队列</strong>：消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程</li>
<li><strong>共享内存</strong>：共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信,带来新的问题，多进程竞争同个共享资源会造成数据的错乱</li>
<li><strong>信号量</strong>：信号量可以保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <code>P</code> 操作和 <code>V</code> 操作</li>
<li><strong>信号</strong>：与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如：键盘 <code>ctrl</code> + C）和软件来源（如 <code>kill</code> 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即：<code>SIGKILL</code> 和 <code>SIGSTOP</code> ，这是为了方便我们能在任何时候结束或停止某个进程</li>
<li><strong><code>socket</code> 通信</strong>：前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 <code>Socket</code> 通信了。<code>Socket</code> 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 <code>Socket</code> 的类型不同，分为三种常见的通信方式，一个是基于 <code>TCP</code> 协议的通信方式，一个是基于 <code>UDP</code> 协议的通信方式，一个是本地进程间通信方式</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">5.2 进程间有哪些通信方式？ | 小林coding</a></p>
<hr>
<h3 id="哪个进程间通信效率最高的？"><a class="headerlink" href="#哪个进程间通信效率最高的？"></a>哪个进程间通信效率最高的？</h3>
<p>答：</p>
<p><strong>共享内存 的通信效率最高</strong>，因为共享内存不涉及内核态和用户态之间的数据拷贝</p>
<p><strong>补充</strong>：</p>
<ul>
<li>共享内存通信效率最高</li>
<li>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250106160914458.png" alt="共享内存" loading="lazy"></p>
<hr>
<h3 id="有名管道和匿名管道的区别？"><a class="headerlink" href="#有名管道和匿名管道的区别？"></a>有名管道和匿名管道的区别？</h3>
<p>答：</p>
<ul>
<li>匿名管道 没有 文件实体，不能用于非亲缘进程间通信，只能用于在父子进程之间进行通信，并且匿名管道只存在于创建它的进程的内存中，进程退出后即被销毁</li>
<li>有名管道 存在 文件实体，可以用于任意进程间的通信，并且数据可以持久化保存，即使创建它的进程退出，其他进程仍然可以使用该管道</li>
</ul>
<p><strong>补充</strong>：</p>
<p>说出 2 个区别点：</p>
<ol>
<li><strong>持久性</strong>：有名管道在文件系统中存在，可以持久化保存，即使创建它的进程退出，其他进程仍然可以使用该管道。而匿名管道只存在于创建它的进程的内存中，进程退出后即被销毁</li>
<li><strong>进程间关系</strong>：有名管道可以用于任意进程间的通信，不受进程关系的限制。而匿名管道只能在父子进程之间进行通信，因为子进程会复制父进程的文件句柄，虽然这样子进程就拥有了匿名管道的文件句柄，因此就可以进行父子通信了</li>
</ol>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.colourso.top/linux-pipefifo/">Linux 进程间通信——匿名管道和有名管道 - Colourso</a></p>
<hr>
<h3 id="信号和信号量的区别？"><a class="headerlink" href="#信号和信号量的区别？"></a>信号和信号量的区别？</h3>
<p>答：</p>
<ul>
<li>信号用于 异步处理异常 或 特殊事件，而信号量用于同步进程以安全地访问共享资源
<ul>
<li>信号是一种异步的通知机制，用于通知进程某个事件已经发生。当一个信号发送给一个进程时，操作系统会中断进程的正常流程来处理信号</li>
<li>信号量是一种用于解决多进程同步和互斥问题的工具，主要用于保护共享资源，防止多个进程同时访问。信号量有一个整数值，该值的含义是可以同时访问某个资源的进程数量。当一个进程想要访问资源时，它会尝试递减信号量（称为<code>P</code>操作）。如果信号量的值大于零，这个操作会成功，否则进程就会阻塞，直到信号量变为正数。当进程完成对资源的访问后，它会递增信号量（称为<code>V</code>操作），允许其他阻塞的进程访问资源</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>概念不同</strong>：信号是一种异步通知机制，用于通知进程发生了某个特定事件，例如：键盘输入、异常等。信号量是一种同步机制，用于实现多个进程之间的互斥访问和同步操作</li>
<li><strong>使用方式不同</strong>：信号通过发送信号的进程向接收信号的进程发送信号，接收进程通过注册信号处理函数来响应信号。信号量通过对共享资源进行加锁和解锁的操作，协调多个进程对共享资源的访问。</li>
<li><strong>应用场景不同</strong>：信号常用于处理异步事件，例如：捕获异常、处理用户输入等。信号量常用于解决多个进程对共享资源的并发访问问题，例如：控制进程的执行顺序、避免竞态条件等</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">5.2 进程间有哪些通信方式？ | 小林coding</a></p>
<hr>
<h2 id="内存管理"><a class="headerlink" href="#内存管理"></a>内存管理</h2>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"></a><div class="post-copyright__author_name">coo1heisenberg's Blog</div><div class="post-copyright__author_desc">Diligence can make up for clumsiness!</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">coo1heisenberg's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"></span>操作系统<span class="tagsPageCount">1</span></a></div></div><div class="social-share"></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/10/00-Kafka/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">00 Kafka 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">00 计算机网络知识点归纳 笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">菜鸡的自我救赎...</div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Coo1heisenberg’s BLOG</div><div class="author-info__desc">Diligence can make up for clumsiness!</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/coo1heisenbergProject" title="Github"><i class="solitude  st-github-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">操作系统知识点归纳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A6%81%E7%BB%99%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E7%BA%A7%EF%BC%9F"><span class="toc-text">为什么计算机要给储存结构分级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-cache-L1-L2-L3-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%87%8F%E7%BA%A7%E5%B7%AE%E8%B7%9D%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="toc-text">CPU cache L1 L2 L3 读取数据的时间量级差距有多大？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%BC%93%E5%AD%98%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E9%83%BD%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-text">CPU 缓存对程序性能的影响都体现在哪些方面？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%EF%BC%9F"><span class="toc-text">什么是内核？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%9F"><span class="toc-text">内核态和用户态区别？为什么要区分内核态和用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%B1%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="toc-text">什么时候会由用户态陷入内核态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">系统调用的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">用户态和内核态是如何切换的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E7%9B%B8%E4%BA%92%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%BC%80%E9%94%80%E6%AF%94%E8%BE%83%E5%A4%A7%EF%BC%9F"><span class="toc-text">为什么用户态和内核态的相互切换过程开销比较大？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-text">什么是中断？为什么要有中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-text">什么是硬件中断和软件中断？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E5%90%AF%E5%8A%A8"><span class="toc-text">Linux 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Linux-%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下 Linux 启动的流程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">进程与线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">为什么需要线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%8C%E5%A4%AA%E5%A4%9A%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">多线程是不是越多越好，太多会有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-text">什么时候用单线程，什么时候用多线程呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%BA%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-text">线程共享了进程的哪些资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%AF%94%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%85%A2%EF%BC%9F"><span class="toc-text">为什么创建进程比创建线程慢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%BC%80%E9%94%80%E5%A4%A7%EF%BC%9F"><span class="toc-text">为什么进程的切换比线程开销大？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">线程的上下文切换是怎么个过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">僵尸进程、守护进程与孤儿进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9D%80%E6%AD%BB%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">怎么杀死僵尸进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8Bfork%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BB%96%E4%BB%AC%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E4%B9%8B%E5%89%8D%E7%9A%842%E5%80%8D%E5%90%97%EF%BC%9F"><span class="toc-text">一个进程fork出一个子进程，那么他们占用的内存是之前的2倍吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-text">什么是协程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">协程和线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">协程切换的本质是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%B0%8F%EF%BC%9F"><span class="toc-text">为什么协程切换的开销比线程切换小？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">进程间有哪些通信方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%EF%BC%9F"><span class="toc-text">哪个进程间通信效率最高的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">有名管道和匿名管道的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">信号和信号量的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/30/pintuan-project/" title="00 拼团交易平台系统"><img alt="00 拼团交易平台系统" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/pdd.png"></a><div class="content"><a class="title" href="/2025/04/30/pintuan-project/" title="00 拼团交易平台系统">00 拼团交易平台系统</a><a class="article-recent_post_categories" href="/2025/04/30/pintuan-project/">Java</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/25/Java-%E5%9F%BA%E7%A1%80/" title="00 Java基础 笔记"><img alt="00 Java基础 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png"></a><div class="content"><a class="title" href="/2025/02/25/Java-%E5%9F%BA%E7%A1%80/" title="00 Java基础 笔记">00 Java基础 笔记</a><a class="article-recent_post_categories" href="/2025/02/25/Java-%E5%9F%BA%E7%A1%80/">Java</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/" title="02 SpringCloud 笔记"><img alt="02 SpringCloud 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/SpringCloud_2025-01-15.png"></a><div class="content"><a class="title" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/" title="02 SpringCloud 笔记">02 SpringCloud 笔记</a><a class="article-recent_post_categories" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/">Spring</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记"><img alt="00 Kafka 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/kafka_log.png"></a><div class="content"><a class="title" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记">00 Kafka 笔记</a><a class="article-recent_post_categories" href="/2025/01/10/00-Kafka/">MQ</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记"><img alt="00 操作系统知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/caozuoxitong.png"></a><div class="content"><a class="title" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记">00 操作系统知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Solitude</span></div><div class="footer-bar-description">来自 Heisenberg 的原创文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 - 2025 By&nbsp;<a class="footer-bar-link" href="/">Coo1heisenberg’s BLOG</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.10.6"></script><script src="/js/main.js?v=1.10.6"></script><script src="/js/third_party/waterfall.min.js?v=1.10.6"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.10.6"></script><script>dark()
</script><script src="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="//open.lightxi.com/cdnjs/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script defer pjax src="//open.lightxi.com/cdnjs/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.10.6"></script><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["2025/04/30/pintuan-project/","2025/02/25/Java-基础/","2025/01/15/SpringCloud笔记/","2025/01/10/00-Kafka/","2025/01/04/操作系统知识点归纳/","2024/12/24/计算机网络知识点归纳/","2024/12/21/01-redis知识点归纳/","2024/12/16/01-MySQL知识点归纳/","2024/12/04/Spring框架/","2024/12/02/Java-JVM虚拟机/","2024/11/04/Java-并发编程/","2024/11/01/Java-集合框架/","2024/09/28/00-前端开发入门教程/","2024/09/26/01-空间转录组/","2024/09/13/00-单细胞多组学分析/","2024/07/22/00-MongoDB/","2024/07/17/00-elasticsearch/","2024/07/15/01-黑马redis/","2024/07/13/00-黑马redis/","2024/07/08/00-黑马SSM/","2024/07/08/01-头条点评项目/","2024/07/06/00-Mybatis-Plus/","2024/06/29/00-黑马MySQL/","2024/06/25/00-头条点评项目/","2024/06/21/02-Python/","2024/06/11/01-Python/","2024/05/25/00-Python/","2024/05/13/DesignPattern/","2024/05/13/Docker/","2024/05/13/Nginx/","2024/05/13/Linux/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>