<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>00 计算机网络知识点归纳 笔记 | coo1heisenberg's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.10.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="计算机网络知识点归纳 网络分层模型 介绍一下 OSI 七层协议，各层协议都有哪些？ 答： OSI 参考模型共有 7 层，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层的协议有： HTTP、HTTPS 传输层的协议有：TCP 和 UDP 网络层的协议有：IP"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="coo1heisenberg's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.10.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;border-radius:0 5px 5px 0",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-05-12 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.webp'
    },
    copyright: {"limit":50,"author":"作者: Coo1heisenberg’s BLOG","link":"链接: ","source":"来源: coo1heisenberg's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Project/">Project<sup>4</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">2025/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">2024/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">2024/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">2024/06</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">2024/05</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">2024/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Project/">Project<sup>4</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon solitude st-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">00 计算机网络知识点归纳 笔记</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" href="/" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/computer_network.png" alt="00 计算机网络知识点归纳 笔记"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Others/">Others</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tags-name tags-punctuation">计算机网络</span></a></div></div></div></div><h1 class="post-title">00 计算机网络知识点归纳 笔记</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-12-24 16:45:51"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-12-24T08:45:51.000Z">2024-12-24T08:45:51.000Z</time></span><span class="post-meta-date" title="最后更新于 2025-01-04 19:56:09"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2025-01-04T11:56:09.242Z">2025-01-04T11:56:09.242Z</time></span><span class="post-meta-wordcount"><span class="post-meta-separator"></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>计算机网络知识点归纳</h1>
<hr>
<h2 id="网络分层模型"><a class="headerlink" href="#网络分层模型"></a>网络分层模型</h2>
<hr>
<h3 id="介绍一下-OSI-七层协议，各层协议都有哪些？"><a class="headerlink" href="#介绍一下-OSI-七层协议，各层协议都有哪些？"></a>介绍一下 OSI 七层协议，各层协议都有哪些？</h3>
<p>答：</p>
<ul>
<li><code>OSI</code> 参考模型共有 <code>7</code> 层，从上到下分别是：<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>、<strong>物理层</strong>
<ul>
<li>应用层的协议有： <code>HTTP</code>、<code>HTTPS</code></li>
<li>传输层的协议有：<code>TCP</code> 和 <code>UDP</code></li>
<li>网络层的协议有：<code>IP</code>、<code>ICMP</code>、<code>ARP</code></li>
</ul>
</li>
<li>我认为，网络分层的好处是：<strong>对各个层之间进行了解耦，层一层之间不会产生关联性</strong>，比如：我们应用层的 <code>HTTP</code> 协议，从 <code>HTTP1.1</code> 升级到 <code>HTTP2.0</code> 的时候，并不会对传输层、网络层等有影响，或者网络层的 <code>IPv4</code> 协议升级为 <code>IPv6</code> 协议的时候，也不会影响应用层、传输层</li>
<li>不过，<code>OSI</code> 参考模型只是理论模型，实际上因特网中的网络模型是使用了 <code>TCP/IP</code> 网络模型，它对 <code>OSI</code> 参考模型做了简化，<strong>把 应用层、表示层、会话层 统一成了 应用层</strong>，<strong>数据链路层 和 物理层 统一成了 网络接口层</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241224183155709.png" alt="OSI模型 TCP/IP模型" loading="lazy"></p>
<ul>
<li><code>OSI</code> 的 7 层模型从上到下依次为：<strong>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</strong></li>
<li><strong>应用层</strong>：<strong>负责直接与 软件应用程序 交互以提供所需的通信功能</strong>，并且它 <strong>与最终用户最接近</strong>
<ul>
<li><strong>应用层的功能</strong>：通常包括 <strong>验证通信伙伴</strong> 和 <strong>资源的可用性</strong> 以支持任何数据传输。该层还定义了用于最终应用程序的协议，例如：域名系统（<code>DNS</code>）、文件传输协议（<code>FTP</code>）、超文本传输协议（<code>HTTP</code>）、<code>Internet</code> 消息访问协议（<code>IMAP</code>）、邮局协议（<code>POP</code>）、简单邮件传输协议（<code>SMTP</code>）、简单网络管理协议（<code>SNMP</code>）和 <code>Telnet</code>（终端仿真)</li>
</ul>
</li>
<li><strong>表示层</strong>：<strong>表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另个系统的应用层识别</strong>，如：<strong>数据转换，压缩和加密，解密</strong>
<ul>
<li>表示层可以 <strong>处理任何所需的数据格式或代码转换</strong></li>
<li>例如：将扩展 二进制编码 的 十进制交换码（<code>EBCDIC</code>）编码的文本文件 转换为 美国信息交换标准码（<code>ASCII</code>）编码的文本文件</li>
<li>表示层也 可<strong>用于数据压缩和加密</strong></li>
<li>例如：视频呼叫将在传输过程中被压缩。以便可以更快地传输，并且数据将在接收方恢复。对于具有较高安全性要求的数据（例如：包含你的密码的短信），将在此层进行加密</li>
</ul>
</li>
<li><strong>会话层</strong>：<strong>会话层控制计算机之间的对话（连接）它建立，管理，维护并最终终止本地和远程应用程序之间的连接</strong>
<ul>
<li>会话层软件 还 <strong>处理 身份验证 和 授权功能</strong>。会话层通常在使用远程过程调用的应用程序环境中明确实现</li>
</ul>
</li>
<li><strong>传输层</strong>：<strong>负责两个设备间的 端 到 端 通信</strong>
<ul>
<li>包括：从会话层提取数据，将数据分解为多个数据，然后再发送到网络层</li>
<li>传输层还负责进行 <strong>流量控制</strong> 和 <strong>错误控制</strong>。<strong>流量控制 用于 确定最佳传输速度</strong>，避免发送方发送速率过快导致接收方接收不过来的情况。传输层还会确保接收数据的完整性（如果不完整，则请求重新传输）来对接收端进行错误控制。传输层包含 <code>TCP</code> 和 <code>UDP</code> 协议</li>
</ul>
</li>
<li><strong>网络层</strong>：网络层通过 <strong>逻辑寻址</strong> 和 <strong>交换功能</strong> 处理 <strong>数据包路由</strong>
<ul>
<li>这一层：实现 <strong>不同网络</strong> 之间的 <strong>数据传输</strong>。它进一步将网段或数据报分解成更小的数据包，并使用 <code>IP</code> 地址找到通往最终目的地的最佳路由。这一过程被称为 <strong>路由选择</strong></li>
<li>网络是可以连接许多 节点 的介质。每个节点都有一个地址。当一个节点需要将消息传输到其他节点时，它仅能提供 <strong>消息的内容</strong> 和 <strong>目标节点的地址</strong>，则网络将找到将消息传递到目标节点的方法，并可能通过其他节点进行路由。如果消息太长，网络可能会在一个节点上将其拆分为多个段，分别发送它们，然后在另一节点上重新组合片段</li>
</ul>
</li>
<li><strong>数据链路层</strong>：数据链路层提供 <strong>节点</strong> 到 <strong>节点</strong> 的传输，即：<strong>两个直接连接的节点之间的链接</strong>
<ul>
<li>这一层允许在 <strong>同一网络</strong> 的 <strong>设备</strong> 之间传输数据。<strong>数据包 被分解成 帧</strong>，这些帧被限制在 局域网 内</li>
<li>它以 <strong>帧</strong> 的形式处理 <strong>数据的打包</strong> 和 <strong>拆包</strong>。它定义了在两个物理连接的设备之间建立和终止连接的协议，例如：点对点协议（<code>PPP</code>）</li>
<li>数据链路层通常分为两个子层：<strong>媒体访问控制（<code>MAC</code>）层</strong>和 <strong>逻辑链路控制（<code>LLC</code>）层</strong>。<code>MAC</code> 层负责控制网络中的设备如何访问媒体以及允许传输数据。<code>LLC</code> 层负责标识和封装网络层协议，并控制错误检查和帧同步</li>
</ul>
</li>
<li><strong>物理层</strong>：<strong>物理层定义了数据连接的物理规格</strong>
<ul>
<li>例如：连接器的插针布局，电缆的工作电压，光纤电缆规格以及无线设备的频率。它负责物理介质中非结构化原始数据的发送和接收</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247531667&amp;idx=2&amp;sn=f420c02c4512d410f2b864f367498adb&amp;chksm=f98d3839cefab12fcd60009fddb1463946cf4a7c22371067103dc891bcceea5946a563b183d6&amp;token=1859366457&amp;lang=zh_CN#rd">面试官：我们为什么需要 7 层 OSI 网络模型？</a>、<a target="_blank" rel="noopener" href="https://www.cloudflare-cn.com/learning/ddos/glossary/open-systems-interconnection-model-osi/">什么是 OSI 模型？ | Cloudflare</a></p>
<hr>
<h3 id="TCP-IP-网络模型有哪几层？"><a class="headerlink" href="#TCP-IP-网络模型有哪几层？"></a>TCP/IP 网络模型有哪几层？</h3>
<p>答：</p>
<ul>
<li><code>TCP/IP</code> 网络模型主要有 四 层，从上到下分别是：<strong>应用层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>网络接口层</strong></li>
<li><strong>应用层</strong>：<strong>负责为 应用软件 提供 网络服务</strong>
<ul>
<li>例如：<code>HTTP</code>、<code>HTTPS</code>、<code>DNS</code>等协议</li>
</ul>
</li>
<li><strong>传输层</strong>：<strong>负责为 应用程序层 提供 数据传输服务</strong>
<ul>
<li>传输层协议 主要有 <code>TCP</code> 和 <code>UDP</code>
<ul>
<li><code>TCP</code>是 可靠 传输协议</li>
<li><code>UDP</code> 是 不可靠 的传输协议</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络层</strong>：<strong>负责主机 寻址，打包 和 路由 功能</strong>
<ul>
<li>网络层的核心协议是：<code>IP</code>、<code>ARP</code>、<code>ICMP</code> 等协议
<ul>
<li><code>IP</code> 协议负责寻址和路由</li>
<li><code>ARP</code> 协议负责获取 <code>MAC</code> 地址</li>
<li><code>ICMP</code> 负责提供诊断功能并报告错误</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络接口层</strong>：负责为 <strong>网络层提供「链路级别」传输的服务</strong>，负责 <strong>在 以太网、<code>WiFi</code> 这样的底层网络上发送原始数据包</strong>
<ul>
<li>工作在 网卡 这个层次，使用 <code>MAC</code> 地址来标识网络上的设备</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241224194836687.png" alt="TCP/IP网络模型" loading="lazy"></p>
<ul>
<li>
<p><code>TCP/IP</code> 网络模型有两种说法， 有的说 五 层 <code>TCP/IP</code> 网络模型，有的说 四 层 <code>TCP/IP</code> 网络模型</p>
<ul>
<li>四层 <code>TCP/IP</code> 网络模型是：应用层、传输层、网络层、网络接口层</li>
<li>五层 <code>TCP/IP</code> 网络模型是：应用层、传输层、网络层、数据链路层、物理层</li>
</ul>
</li>
<li>
<p><code>TCP/IP</code> 网络通常是由上到下分成 4 层，分别是：<strong>应用层，传输层，网络层 和 网络接口层</strong></p>
</li>
<li>
<p><strong>应用层</strong>：<code>TCP/IP</code> 模型的应用程序层使应用程序能够访问其他层的服务，并定义了应用程序用来交换数据的协议</p>
<ul>
<li>最熟悉的应用层协议包括：<code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SNMP</code> 和 路由信息协议（<code>RIP</code>）</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：传输层负责 <strong>为 应用程序层 提供 会话 和 数据通信服务</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225111207457.png" alt="传输层" loading="lazy"></p>
<ul>
<li>该层的核心协议是 <code>TCP</code> 和 <code>UDP</code>
<ul>
<li><code>TCP</code> 提供 <strong>一对一</strong>，<strong>面向连接</strong> 的 可靠通信服务。它负责对发送的数据包进行排序和确认，并恢复传输中丢失的数据包</li>
<li><code>UDP</code> 提供 <strong>一对一</strong> 或 <strong>一对多</strong> 的 <strong>无连接，不可靠</strong> 的通信服务。当要传输的数据量较小时（例如，该数据可以放入单个数据包中），通常使用 <code>UDP</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>：网络层 <strong>负责 主机寻址，打包 和 路由功能</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225111602000.png" alt="网络层" loading="lazy"></p>
<ul>
<li>网络层负责 <strong>将 数据 从 一个设备 传输到 另一个设备</strong></li>
<li><strong>网络层的核心协议</strong>：<code>IP</code>、地址解析协议（<code>ARP</code>）、<code>Internet</code> 控制消息协议（<code>ICMP</code>）和 <code>Internet</code> 组管理协议（<code>IGMP</code>）
<ul>
<li><code>IP</code> 是可路由协议，负责 <code>IP</code> 寻址，路由以及数据包的分段和重组
<ul>
<li>将 <code>IP</code> 地址分成两种意义：
<ul>
<li>一个是 <strong>网络号</strong>，负责标识该 <code>IP</code> 地址是<strong>属于哪个「子网」的</strong>
<ul>
<li><code>IP</code> 地址与 子网掩码 按位 与 运算</li>
</ul>
</li>
<li>一个是 <strong>主机号</strong>，<strong>负责标识同一「子网」下的不同主机</strong>
<ul>
<li><code>IP</code> 地址与 子网掩码取反后 按位 与 运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ARP</code> 负责发现网络访问层地址，例如：与给定 <code>Internet</code> 层访问关联的硬件地址</li>
<li>由于 <code>IP</code> 数据包传递失败，<code>ICMP</code> 负责提供诊断功能并报告错误</li>
<li><code>IGMP</code> 负责 <code>IP</code> 多播组的管理。<code>IP</code> 在此层中将标头添加到数据包中，称为 <code>IP</code> 地址。现在既有 <code>IPv4</code> （32位）地址又有 <code>IPv6</code> （128位）地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络接口层</strong>：网络接口层 <strong>负责将 <code>TCP/IP</code> 数据包放在网络介质上，并从网络介质上接收 <code>TCP/IP</code> 数据包</strong></p>
<ul>
<li><code>TCP/IP</code> 被设计为 独立于网络访问方法，帧格式 和 介质。换句话说，它独立于任何特定的网络技术。这样，<code>TCP/IP</code> 可以用于连接不同的网络类型，例如：以太网，令牌环，<code>X.25</code>，帧中继和异步传输模式（<code>ATM</code>）</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225104421093.png" alt="TCP/IP的封装格式" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E4%BC%A0%E8%BE%93%E5%B1%82">2.1 TCP/IP 网络模型有哪几层？ | 小林coding</a></p>
<hr>
<h3 id="IP-协议和-TCP-协议属于哪一层？"><a class="headerlink" href="#IP-协议和-TCP-协议属于哪一层？"></a>IP 协议和 TCP 协议属于哪一层？</h3>
<p>答：</p>
<p><code>IP</code> 协议属于 网络层，<code>TCP</code> 协议属于 传输层</p>
<hr>
<h3 id="网络为什么要分层？"><a class="headerlink" href="#网络为什么要分层？"></a>网络为什么要分层？</h3>
<p>答：</p>
<ul>
<li>分层的目的是 <strong>为了降低耦合，各层相互独立之后，上层可以不关心下层的实现，只关心下层提供的接口服务，有利于排查网络问题，能更精细定位问题所在哪一层</strong></li>
<li>分层之后层与层之间不会产生关联性，不会因为某个层的改动，影响了其他层
<ul>
<li>比如：应用层的 <code>HTTP</code> 协议，从 <code>HTTP1.1</code> 升级到 <code>HTTP2.0</code> 的时候，并不会对 传输层、网络层 等有影响，或者网络层的 <code>IPv4</code> 协议升级为 <code>IPv6</code> 协议的时候，也不会影响 应用层、传输层</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>分层的好处</strong>：
<ol>
<li><strong>各层之间是 独立的</strong>
<ul>
<li>某一层 并不需要知道它 下一层 是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个较容易处理的更小问题，这样，整个问题的复杂度就下降了</li>
</ul>
</li>
<li><strong>灵活性好</strong>
<ul>
<li>当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响此外，对某一层提供的服务还可以进行修改。当某层提供的服务不再需要时，甚至可以将这层取消</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="键入网址场景问题"><a class="headerlink" href="#键入网址场景问题"></a>键入网址场景问题</h2>
<hr>
<h3 id="输入网址后，期间发生了什么？"><a class="headerlink" href="#输入网址后，期间发生了什么？"></a>输入网址后，期间发生了什么？</h3>
<p>答：</p>
<p>在浏览器输入网址后：</p>
<ol>
<li>
<p><strong>浏览器会先解析 <code>URL</code>，解析出 域名、资源路径、端口 等信息，然后构造 <code>HTTP</code> 请求报文</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121808120.png" alt="URL组成" loading="lazy"></p>
</li>
<li>
<p><strong>接着进行 域名 解析，将 域名解析 为 <code>IP</code> 地址</strong>，会先查 系统缓存 是否 域名信息，如果有就返回 <code>IP</code> 地址，没有就会查看本地系统 <code>host</code> 文件有没有域名信息，如果有就返回 <code>IP</code> 地址，如果没有就去查本地 <code>DNS</code> 服务器，如果本地 <code>DNS</code> 服务器缓存中有域名信息，就返回 <code>IP</code> 地址，否则本地 <code>DNS</code> 服务器分别去 根域名服务器 → 顶级域名服务器 → 权威域名服务器询问，最后拿着返回的 <code>IP</code> 交给浏览器</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121950471.png" alt="DNS域名解析器关系图" loading="lazy"></p>
</li>
<li>
<p>由于 <code>HTTP</code> 是基于 <code>TCP</code> 传输的，所以 <strong>在发送 <code>HTTP</code> 请求前，要进行 三次握手</strong>，在客户端发送第一次握手的时候，<code>TCP</code> 头部会填上 <code>SYN</code> 标记位，同时填上 目标端口 和 源端口 的信息。源端口 是 浏览器随机生成的，目标端口要看是 <code>HTTP</code> 还是 <code>HTTPS</code>，如果是 <code>HTTP</code> 默认目标端口是 80，如果是 <code>HTTPS</code> 默认是 443</p>
</li>
<li>
<p>然后到 <strong>网络层</strong>，会加上 <code>IP</code> 头，同时填上 目标 <code>IP</code> 地址 和 源 <code>IP</code> 地址</p>
</li>
<li>
<p>然后到 <strong>数据链路层</strong>，会通过 <code>ARP</code> 协议，获取路由器的 <code>MAC</code> 地址，然后会加上 <code>MAC</code> 头，填上 目标<code>MAC</code>地址 和 源 <code>MAC</code> 地址</p>
</li>
<li>
<p>然后到 <strong>物理层</strong> 之后，直接把 数据包，转发给 路由器，路由器再通过下一跳，最终找到 目标服务器，然后目标服务器收到客户的 <code>SYN</code> 报文后，会响应第二次握手</p>
</li>
<li>
<p>当双方都 <strong>完成 三次握手 后</strong>，如果是 <code>HTTP</code> 协议，客户端就会将 <code>HTTP</code> 请求就会发送给目标服务器；如果是 <code>HTTPS</code> 协议，客户端 还要和 服务端 进行 <code>TLS</code> 四次握手之后，客户端才会将 <code>HTTP</code> 报文发送给目标服务器</p>
</li>
<li>
<p>目标服务器收到 <code>HTTP</code> 请求消息后，就返回 <code>HTTP</code> 响应消息，浏览器会对响应消息进行解析渲染，呈现给用户</p>
</li>
</ol>
<p><strong>补充</strong>：</p>
<p>关键要讲出输入网址后涉及的每一个网络协议的工作原理和作用：</p>
<ul>
<li><code>HTTP/HTTPS</code> 协议 → <code>DNS</code> 协议 → <code>TCP</code> 协议 → <code>IP</code>协议 → <code>ARP</code> 协议</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121624353.png" alt="输入网址后的流程图" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-tcp">2.2 键入网址到网页显示，期间发生了什么？ | 小林coding</a></p>
<hr>
<h3 id="DNS-是如何解析的？属于哪一层的协议？"><a class="headerlink" href="#DNS-是如何解析的？属于哪一层的协议？"></a>DNS 是如何解析的？属于哪一层的协议？</h3>
<p>答：</p>
<ul>
<li><code>DNS</code> 属于 <strong>应用层</strong> 的协议
<ul>
<li>客户端在进行 <code>DNS</code> 解析之前，会先查看 浏览器 和 操作系统 是否有缓存域名对应的 <code>IP</code> 地址，没有就会查看本地系统 <code>host</code> 文件有没有域名信息，如果有就返回 <code>IP</code> 地址</li>
<li>如果没有就会向本地 <code>DNS</code> 服务器发出查询请求，如果没有接着本地 <code>DNS</code> 向 根 <code>DNS</code> 发送查询请求，根 <code>DNS</code> 服务器收到请求后会返回顶级域名服务器的 <code>IP</code> 地址，然后本地 <code>DNS</code> 服务器再向顶级域名服务器发出查询请求，顶级 <code>DNS</code> 服务器收到请求后会返回权威域名服务器的 <code>IP</code> 地址，然后本地 <code>DNS</code> 服务器再向 权威域名服务器 发出查询请求，权威域名服务器 收到请求后，就会返回域名对应的 <code>IP</code> 地址了，最后本地 <code>DNS</code> 服务器返回查询结果给客户端，同时本地域名服务器把返回的结果保存到缓存，以备下一次使用。客户端通过这个 <code>IP</code> 地址就可以访问目标 <code>Web</code> 服务器了。到这里，<code>DNS</code> 查询的整个过程就结束了</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225123358734.png" alt="具体流程" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://support.huaweicloud.com/productdesc-dns/zh-cn_topic_0035920135.html?utm_source=dns_Growth_map&amp;utm_medium=display&amp;utm_campaign=help_center&amp;utm_content=Growth_map">公网域名解析_云解析服务 DNS_华为云</a></p>
<hr>
<h3 id="DNS域名解析使用的什么协议？"><a class="headerlink" href="#DNS域名解析使用的什么协议？"></a>DNS域名解析使用的什么协议？</h3>
<p>答：</p>
<ul>
<li>在 <code>DNS</code> 中，域名解析 请求 和 响应 都是基于 <code>UDP</code> 进行传输的</li>
<li><code>UDP</code> 是一种 无连接 的 传输层协议，它提供了一种简单的传输机制，适用于对 实时性要求较高 的应用场景。<code>DNS</code> 使用 <code>UDP</code> 协议进行域名解析是因为 域名解析 通常是 短小而频繁 的请求，<code>UDP</code> 的无连接特性可以减少建立和断开连接的开销，并提高解析的效率（<code>UDP</code> 协议以及 <code>UDP</code>相较于 <code>TCP</code>的优点）</li>
<li><code>UDP</code> 对于 <code>TCP</code> 的缺点是没办法保证数据的可靠传输，针对这个缺陷，<strong>可以在应用层实现一个超时重传机制，如果域名解析请求在一定时间内没收到响应，那么就重发域名解析请求</strong>（<code>UDP</code> 不保证可靠性的缺点）</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6991611868867461157">DNS 协议是什么？完整查询过程？为什么选择使用 UDP 协议发起 DNS 查询？&gt; 你可能了解 DNS 协议是什么？那 - 掘金</a></p>
<hr>
<h3 id="输入域名如何知道端口的？"><a class="headerlink" href="#输入域名如何知道端口的？"></a>输入域名如何知道端口的？</h3>
<p>答：</p>
<p><code>HTTP</code> 默认端口是 80，<code>HTTPS</code> 默认端口是 443，如果用户指定了端口，比如：<code>域名:8080</code>，这时候就会使用<code>8080</code> 作为目标端口</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>http://baidu.com/</code>，默认端口是 <strong>80</strong></li>
<li><code>https://baidu.com/</code>，默认端口是 <strong>443</strong></li>
<li><code>http://baidu.com:8080/</code>，指定的端口是 <strong>8080</strong></li>
</ul>
<p><strong>详细链接</strong>：[11 你能写出正确的网址吗？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/11">https://learn.lianglianglee.com/专栏/透视HTTP协议/11</a>  你能写出正确的网址吗？.md)</p>
<hr>
<h3 id="客户端向服务端的-IP-地址发送数据，服务端如何确定应该把数据传递给谁？"><a class="headerlink" href="#客户端向服务端的-IP-地址发送数据，服务端如何确定应该把数据传递给谁？"></a>客户端向服务端的 IP 地址发送数据，服务端如何确定应该把数据传递给谁？</h3>
<p>答：</p>
<p>服务端的应用会监听端口，协议栈会通过端口来区分不同应用的数据</p>
<p><strong>补充</strong>：</p>
<p>每个传输层协议（如：<code>TCP</code> 和 <code>UDP</code>）都使用 端口号 来标识不同的应用程序或服务，服务端 通过 监听 特定的端口号来接收来自客户端的数据</p>
<hr>
<h3 id="现在很多网站都要求使用-https，假设我们输入一个-http-网址，网站是如何实现由-http-跳转到-https-的？"><a class="headerlink" href="#现在很多网站都要求使用-https，假设我们输入一个-http-网址，网站是如何实现由-http-跳转到-https-的？"></a>现在很多网站都要求使用 https，假设我们输入一个 http 网址，网站是如何实现由 http 跳转到 https 的？</h3>
<p>答：</p>
<ul>
<li>服务器网关收到 <code>http</code> 请求后，给客户端一个 <code>http</code> 响应，状态码为 <code>301</code>（永久重定向）</li>
<li>浏览器收到 重定向 响应后，自动向服务器发起一个新的 <code>HTTPS</code> 请求（默认端口 <code>443</code>）</li>
</ul>
<p><strong>补充</strong>：</p>
<p>网站实现由 <code>HTTP</code> 跳转到 <code>HTTPS</code> 的过程通常涉及 服务器端的配置，以确保用户访问的是 加密 的连接。以下是 <code>nginx</code> 服务器端配置方法，可以在虚拟主机的配置文件中添加以下代码来实现重定向：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name example.com;</span><br><span class="line">	return 301 https://$host$request uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="网络传输场景问题"><a class="headerlink" href="#网络传输场景问题"></a>网络传输场景问题</h2>
<hr>
<h3 id="如果浏览器没有显示页面有哪些原因？"><a class="headerlink" href="#如果浏览器没有显示页面有哪些原因？"></a>如果浏览器没有显示页面有哪些原因？</h3>
<p>答：</p>
<p>最直接的办法就是 <strong>抓包</strong>，排查的思路大概有：</p>
<ol>
<li><strong>先确定是 服务端 的问题，还是 客户端 的问题</strong>
<ul>
<li>先在 客户端 确认浏览器是否可以访问其他网站，如果不可以，说明客户端网络自身的问题，然后检查 客户端 网络配置（连接 <code>wifi</code> 正不正常，有没有插网线）</li>
<li>如果可以正常其他网页，说明 客户端 网络是可以正常上网的</li>
</ul>
</li>
<li><strong>如果 客户端 网络没问题，就抓包确认 <code>DNS</code> 是否解析出了 <code>IP</code> 地址，如果没有解析出来，说明域名写错了，如果解析出了 <code>IP</code> 地址，抓包确认有没有和服务端建立三次握手</strong>：
<ul>
<li>如果没有成功建立三次握手，需要在服务端通过 <code>ps</code> 确认 <code>server</code> 进程是否启动了，以及通过  <code>netstate</code> 命令确认是否监听了端口</li>
<li>如果能成功建立三次握手，并且发出了 <code>HTTP</code> 请求，但是就是没有显示页面，可以查看服务端返回的响应码：
<ul>
<li>如果是 <code>404</code> 错误码，检查输入的 <code>url</code> 是否正确</li>
<li>如果是 <code>500</code>，说明服务器此时有问题，这时候就需要去服务器排查日志了</li>
<li>如果是 <code>200</code>，可以在浏览器按 <code>F12</code> 输出前端控制台，看看前端代码有问题导致浏览器没有渲染出页面</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果 客户端 网络是正常的，但是访问速度很慢，导致很久才显示出来</strong>。可以通过 <code>ping</code> 去确认网络延迟是否正常，如果耗时很严重，可以排查服务器的流量是不是很大，导致超过了带宽上限，产生了丢包的问题。如果网络是正常的，可能要排查接口为什么处理这么久，这里有可能是慢 <code>sql</code> 导致的</li>
</ol>
<p>总之就 是一层一层有没有插网线，网络配置是否正确、<code>DNS</code> 有没有解析出 <code>IP</code> 地址、<code>TCP</code> 有没有三次握手、<code>HTTP</code> 返回的响应码是什么</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2dT9SlEhimW1conTVbZ8ZQ">字节一面：网站显示不出来，怎么排查？</a></p>
<hr>
<h3 id="服务器ping不通但是http能请求成功，会出现这种情况吗？"><a class="headerlink" href="#服务器ping不通但是http能请求成功，会出现这种情况吗？"></a>服务器ping不通但是http能请求成功，会出现这种情况吗？</h3>
<p>答：</p>
<ul>
<li>会的</li>
<li>因为 <code>ping</code> 和 <code>http</code> 使用的协议是不一样的，<code>ping</code> 是基于网络层的 <code>ICMP</code> 协议，而 <code>http</code> 是基于传输层的 <code>TCP</code> 协议的，有可能服务器的防火墙禁止 <code>ICMP</code> 协议，但是 <code>TCP</code> 协议没有禁止，就会出现服务器 <code>ping</code> 不通，但是 <code>http</code> 能请求现象</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>主要是 <code>ping</code> 和 <code>http</code> 底层的协议区别</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/4_ip/ping.html#%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B">5.2 ping 的工作原理 | 小林coding</a></p>
<hr>
<h3 id="客户端-TCP-连接一个不存在的-IP-地址的服务端会发生什么？（cold）"><a class="headerlink" href="#客户端-TCP-连接一个不存在的-IP-地址的服务端会发生什么？（cold）"></a>客户端 TCP 连接一个不存在的 IP 地址的服务端会发生什么？（cold）</h3>
<p>答：</p>
<ul>
<li>分情况讨论：
<ol>
<li>如果访问的 <code>IP</code> 地址是局域网内的，客户端的内核在发 <code>ARP</code> 请求的时候，广播询问这个目标 <code>IP</code> 地址是谁的，由于网络中不存在该目标 <code>IP</code> 地址，所以没有设备应答客户端的 <code>ARP</code> 请求，这时候就会卡在 <code>ARP</code> 协议，客户端的 <code>SYN</code> 报文是发送不出去的</li>
<li>如果访问的 <code>IP</code> 地址不是局域网的，客户端会先将 <code>SYN</code> 报文发给路由器，然后路由器会继续转发，由于目标 <code>IP</code> 地址是不存在的，该 <code>SYN</code> 报文会在网络中消亡，因此客户端是不会收到对 <code>SYN</code> 报文的确认报文的，接着客户端会触发超时重传，重传 <code>SYN</code> 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yLp6Z_00TsAwagbx_lEPXA">字节面试：连接一个不存在的 IP 地址，会发生什么？</a></p>
<hr>
<h3 id="客户端-TCP-连接一个-IP-地址存在但是端口不存在的服务端会发生什么？（cold）"><a class="headerlink" href="#客户端-TCP-连接一个-IP-地址存在但是端口不存在的服务端会发生什么？（cold）"></a>客户端 TCP 连接一个 IP 地址存在但是端口不存在的服务端会发生什么？（cold）</h3>
<p>答：</p>
<p>端口不存在的话，代表服务端没有监听这个端口，服务端在收到客户端的 <code>SYN</code> 报文后，服务端会回 <code>RST</code> 报文，客户端收到 <code>RST</code> 报文后，会断开连接</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225131324285.png" alt="举例" loading="lazy"></p>
<ul>
<li>如果客户端访问了没有被服务端监听的端口的话，服务端会回 <code>RST</code> 报文</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_no_listen.html">4.19 服务端没有 listen，客户端发起连接建立，会发生什么？ | 小林coding</a></p>
<hr>
<h3 id="客户端-UDP-发送一个-IP-地址存在但是端口不存在报文会发生什么？（cold）"><a class="headerlink" href="#客户端-UDP-发送一个-IP-地址存在但是端口不存在报文会发生什么？（cold）"></a>客户端 UDP 发送一个 IP 地址存在但是端口不存在报文会发生什么？（cold）</h3>
<p>答：</p>
<p>服务端会回 <code>ICMP</code> 报文，报告端口不可达</p>
<p><strong>补充</strong>：</p>
<p><code>UDP</code> 没有 <code>RST</code> 报文，所以如果端口不存在，这时候会在网络层通过 <code>ICMP</code> 协议，报告端口不可达的消息给客户端</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225131717841.png" alt="举例" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mrpre/article/details/43451775">关于UDP接收icmp端口不可达(port unreachable)_icmp port unreachable-CSDN博客</a></p>
<hr>
<h2 id="HTTP"><a class="headerlink" href="#HTTP"></a>HTTP</h2>
<hr>
<h3 id="HTTP-协议的特点是什么？"><a class="headerlink" href="#HTTP-协议的特点是什么？"></a>HTTP 协议的特点是什么？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 具有简单、灵活可扩展、无状态等特点，是一种广泛应用于 <code>Web</code> 通信的协议
<ol>
<li><strong>基于文本</strong>：<code>HTTP</code> 的消息是以 <strong>文本形式</strong> 传输，易于阅读和调试</li>
<li><strong>可扩展性</strong>：<code>HTTP</code> 协议本身不限制数据的内容和格式，可以通过 <strong>扩展头部、方法</strong> 等来支持新的功能</li>
<li><strong>灵活性</strong>：<code>HTTP</code> <strong>支持不同的数据格式</strong>（如：<code>HTML</code>、<code>JSON</code>、<code>XML</code> 等），适用于多种应用场景</li>
<li><strong>请求应答模式</strong>：<code>HTTP</code> 协议使用的是 <strong>请求 - 应答</strong> 通信模式，请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作</li>
<li><strong>无状态</strong>：<code>HTTP</code> <strong>每个请求之间相互独立</strong>，服务器不会保留之前请求的状态信息，需要通过其他手段（如：<code>Cookies</code>、<code>Session</code>）来维护状态</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 是 灵活可扩展 的，可以任意添加头字段实现任意功能</li>
<li><code>HTTP</code> 是可靠传输协议，基于 <code>TCP/IP</code> 协议 “尽量” 保证数据的送达</li>
<li><code>HTTP</code> 是应用层协议，比 <code>FTP</code>、<code>SSH</code> 等更通用功能更多，能够传输任意数据</li>
<li><code>HTTP</code> 使用了 请求 - 应答 模式，客户端主动发起请求，服务器被动回复请求</li>
<li><code>HTTP</code> 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<p><strong>详细链接</strong>：[13 HTTP有哪些特点？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/13">https://learn.lianglianglee.com/专栏/透视HTTP协议/13</a>  HTTP有哪些特点？.md)</p>
<hr>
<h3 id="HTTP-报文格式？怎么分割的？"><a class="headerlink" href="#HTTP-报文格式？怎么分割的？"></a>HTTP 报文格式？怎么分割的？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 报文格式分为 <strong>请求行</strong>、<strong>请求头</strong>、<strong>请求体</strong> 三个部分：
<ul>
<li><strong>请求行</strong> 是 <strong>请求或响应的基本信息</strong>，比如：请求方法、<code>URL</code>、<code>HTTP</code> 版本信息</li>
<li><strong>请求头</strong> 是 <strong>用 <code>key-value</code> 形式更详细地说明报文</strong>，比如：<code>Host</code> 字段、<code>Connection</code> 字段、<code>Content-Length</code>  字段</li>
<li><strong>请求体</strong> 是 <strong>实际传输的数据</strong>，比如：文本数据、图片数据</li>
</ul>
</li>
<li><strong>请求行</strong> 和 <strong>请求头</strong> 是<strong>通过 <code>\r\n</code> 分割</strong>的，<strong>请求头</strong> 和 <strong>请求体</strong> 之间是通过 空白行 分割的，也就是 <strong>两个连续的<code>\r\n</code></strong></li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 报文格式分为 请求行、请求头、请求体 三个部分
<ul>
<li>请求行的内容是 <code>HTTP</code> 方法、<code>URL</code>、<code>HTTP</code> 版本号，请求行里的字段之间是通过 空格 分割，请求行 和 请求头 是通过 <code>\r\n</code> 分割的</li>
<li>请求头 的 内容 是 多个键值对字段的集合，键 和 值 通过 冒号 分割，每个字段之间通过 <code>\r\n</code> 分割</li>
<li>请求体 的内容是 实体数据，请求头 和 请求体 之间是通过 空白行 分割的，即：两个连续的<code>\r\n</code>（回车符 + 换行符）</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225133744351.png" alt="HTTP报文格式" loading="lazy"></p>
<p><strong>详细链接</strong>：[09 HTTP报文是什么样子的？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/09">https://learn.lianglianglee.com/专栏/透视HTTP协议/09</a>  HTTP报文是什么样子的？.md)</p>
<hr>
<h3 id="HTTP-默认的端口是什么？"><a class="headerlink" href="#HTTP-默认的端口是什么？"></a>HTTP 默认的端口是什么？</h3>
<p>答：</p>
<p><code>80</code> 端口</p>
<p><strong>补充</strong>：</p>
<p>端口 是 <code>TCP</code> 的概念，针对 <code>HTTP</code> 协议，服务端默认是监听 <code>80</code> 端口，针对 <code>HTTPS</code> 协议，服务端默认是监听  <code>443</code> 端口</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wsg25/articles/9703730.html">HTTP、HTTPS常用的默认端口号 - 景寓6号 - 博客园</a></p>
<hr>
<h3 id="HTTP-有什么方法？"><a class="headerlink" href="#HTTP-有什么方法？"></a>HTTP 有什么方法？</h3>
<p>答：</p>
<ul>
<li>我了解到 <code>HTTP</code> 方法的有 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>HEAD</code>、<code>DELETE</code> 这些方法，其中：
<ul>
<li><code>GET</code> 方法是用来 <strong>请求从服务器获取资源的</strong></li>
<li><code>HEAD</code> 方法和 <code>GET</code> 方法类似，也是请求从服务器获取资源，但与 <code>GET</code> 请求不同的是，服务器不会返回请求的实体数据，<strong>只会传回响应头，也就是获取的是资源的 “元信息”</strong></li>
<li><code>POST</code> 方法是 <strong>用来向服务端提交数据，数据就放在报文的 <code>body</code> 里</strong></li>
<li><code>PUT</code> 方法和 <code>POST</code> 类似，也可以向服务器提交数据，<strong>区别在于 <code>POST</code> 是 “新增数据”，<code>PUT</code> 是 “更新数据”</strong></li>
<li><code>DELETE</code> 方法是用来 <strong>删除资源</strong></li>
</ul>
</li>
<li>在项目开发中，用的比较多是 <code>GET</code> 和 <code>POST</code> 请求</li>
</ul>
<p><strong>补充</strong>：</p>
<p>目前 <code>HTTP/1.1</code>规定的八种方法，单词必须是 大写 的形式</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225134528641.png" alt="HTTP/1.1 规定的八种方法" loading="lazy"></p>
<p><strong>详细链接</strong>：[10 应该如何理解请求方法？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/10">https://learn.lianglianglee.com/专栏/透视HTTP协议/10</a>  应该如何理解请求方法？.md)</p>
<hr>
<h3 id="分析一下哪些-HTTP-方法是安全或者幂等的？"><a class="headerlink" href="#分析一下哪些-HTTP-方法是安全或者幂等的？"></a>分析一下哪些 HTTP 方法是安全或者幂等的？</h3>
<p>答：</p>
<ul>
<li><code>GET</code> 和 <code>HEAD</code> 方法是 安全且幂等 的，因为它们是 只读 操作，只要开发者遵循规范要求的去处理请求，无论 <code>GET</code> 和 <code>HEAD</code> 操作多少次，服务器上的数据都是安全的</li>
<li><code>POST</code> / <code>PUT</code> / <code>DELETE</code> 这些方法都会 增上改服务器上的资源，所以是 不安全 的</li>
<li><code>DELETE</code> 和 <code>PUT</code> 方法是 幂等 的，因为 <code>DELETE</code> 是 删除资源，多次删除，效果都是资源不存在，所以也是 幂等 的，另一个 <code>PUT</code> 是 更新数据，多次更新数据，结果都一样，所以是 幂等 的</li>
<li>但是 <code>POST</code> 是不幂等的，因为多次 <code>POST</code> 请求，会创建多个资源，所以 不是幂等 的</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>在 <code>HTTP</code> 协议里：
<ul>
<li>所谓的 “<strong>安全</strong>” 是指：请求方法不会 “破坏” 服务器上的资源，即：<strong>不会对服务器上的资源造成实质的修改</strong></li>
<li>所谓的 “<strong>幂等</strong>” 实际上是一个数学用语，被借用到了 <code>HTTP</code> 协议里，意思是：<strong>多次执行相同的操作，结果也都是相同的，即：多次 “幂” 后结果 “相等”</strong></li>
</ul>
</li>
<li>分类：
<ul>
<li>安全的方法：<code>GET</code> / <code>HEAD</code></li>
<li>不安全的方法：<code>POST</code> / <code>DELETE</code> / <code>PUT</code></li>
<li>幂等的方法：<code>GET</code> / <code>HEAD</code> / <code>DELETE</code> / <code>PUT</code></li>
<li>不幂等的方法：<code>POST</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="GET-和-POST-请求的区别？"><a class="headerlink" href="#GET-和-POST-请求的区别？"></a>GET 和 POST 请求的区别？</h3>
<p>答：</p>
<ul>
<li><code>GET</code> 请求是 从服务器获取资源，<code>POST</code> 请求是 向服务器提交数据</li>
<li><code>GET</code> 方法是 只读 操作，所以是 安全且幂等 的，而 <code>POST</code> 方法会修改服务器上的资源，并且多次 <code>POST</code> 请求，会创建多个资源，所以 不是安全，也不是幂等 的</li>
<li><code>GET</code> 请求的请求参数放在 <code>URL</code> 中的查询字符串中，浏览器对 <code>URL</code> 长度限制，所以 <code>GET</code> 请求的请求参数会有长度限制，而 <code>POST</code> 请求的请求参数是放在请求体中，<code>POST</code> 请求的请求参数长度没有限制</li>
</ul>
<p><strong>补充</strong>：</p>
<p>从几个角度分析：</p>
<ol>
<li>两个请求的语义上的区别</li>
<li>两个请求的是否是安全且幂等的？</li>
<li>请求参数的区别</li>
</ol>
<h3 id="GET-请求一定是安全且幂等的吗？"><a class="headerlink" href="#GET-请求一定是安全且幂等的吗？"></a>GET 请求一定是安全且幂等的吗？</h3>
<p>答：</p>
<p><strong>不一定</strong>，要看实际的 <code>GET</code> 请求，如果 <strong>开发者遵循了规范去处理请求</strong>，也就是 <code>GET</code> 请求的实现是获取资源，那么就是安全且幂等的，但是 <strong>如果开发者处理 <code>GET</code> 请求的方式是 新增数据</strong>，这时候 <code>GET</code> 请求就 不是安全且幂等的</p>
<hr>
<h3 id="HTTP-有什么状态码？"><a class="headerlink" href="#HTTP-有什么状态码？"></a>HTTP 有什么状态码？</h3>
<p>答：</p>
<p><code>HTTP</code> 状态共有 <code>5</code> 类：</p>
<ul>
<li><strong>数字 <code>1</code> 开头的状态码</strong>：表示目前是 <strong>协议处理的中间状态</strong>，还需要后续操作，比如：客户端请求服务端从  <code>HTTP</code> 切换为 <code>WebSocket</code> 通信的时候，服务端如果同意切换，就会回 <code>101</code> 状态码</li>
<li><strong>数字 <code>2</code> 开头的状态码</strong>：表示 <strong>服务器收到并成功处理了客户端的请求</strong>，比如：<code>200</code> 状态码是代表 服务端 成功响应了 客户端 的请求</li>
<li><strong>数字 <code>3</code> 开头的状态码</strong>：表示 <strong>服务端的资源发生了变动</strong>，<strong>需要进行 重定向 了</strong>，比如：<code>301</code> 是代表永久重定向、<code>302</code> 代表临时重定向</li>
<li><strong>数字 <code>4</code> 开头的状态码</strong>：<strong>是 客户端错误，表示客户端发送的请求报文有误，服务器无法处理</strong>，比如：<code>404</code>  状态码表示资源在本服务器上未找到</li>
<li><strong>数字 <code>5</code> 开头的状态码</strong>：<strong>是 服务端错误，服务器在处理时内部发生了错误</strong>，比如：<code>502</code> 状态码是 <code>nginx</code> 服务器作为代理时返回的错误码，表示 <code>nginx</code> 服务器自身工作正常，但是访问后端服务器时发生了错误，具体的错误需要去排查后端服务器</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>100</code> 类状态码属于 <strong>提示信息，是协议处理中的一种中间状态，实际用到的比较少</strong>
<ul>
<li>“<code>101 Switching Protocols</code>”：<strong>请求者已要求服务器切换协议，服务器已确认并准备切换</strong>
<ul>
<li>它的意思是客户端使用 <code>Upgrade</code> 头字段，要求在 <code>HTTP</code> 协议的基础上改成其他的协议继续通信，比如：<code>WebSocket</code>。而如果服务器也同意变更协议，就会发送状态码 <code>101</code>，但这之后的数据传输就不会再使用 <code>HTTP</code> 了</li>
</ul>
</li>
</ul>
</li>
<li><code>200</code> 类状态码表示 <strong>服务器成功处理了客户端的请求</strong>
<ul>
<li>“<code>200 OK</code>”是 <strong>最常见的成功状态码</strong>：表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 <code>HEAD</code> 请求，通常在响应头后都会有 <code>body</code> 数据</li>
<li>“<code>204 No Content</code>” 是 <strong>另一个很常见的成功状态码</strong>，它的含义与 “<code>200 OK</code>” 基本相同，但响应头后没有 <code>body</code> 数据。所以对于 <code>Web</code> 服务器来说，正确地区分 <code>200</code> 和 <code>204</code> 是很必要的</li>
<li>“<code>206 Partial Content</code>” 是 <strong><code>HTTP</code> 分块下载或断点续传的基础</strong>，在客户端发送 “ 范围请求 ”、要求获取资源的部分数据时出现，它与 <code>200</code> 一样，也是服务器成功处理了请求，但 <code>body</code> 里的数据不是资源的全部，而是其中的一部分</li>
</ul>
</li>
<li><code>300</code> 类状态码表示 <strong>客户端请求的资源发生了变动，需要客户端用新的 <code>URL</code> 重新发送请求获取资源，也就是重定向</strong>
<ul>
<li>“ <code>301 Moved Permanently</code> ”：<strong>代表 永久性的重定向</strong>，值得注意的是，这种重定向跳转，从严格意义来讲不是服务器跳转，而是客户端跳转的。这个 “ 跳 ” 的动作是服务器是通过回传状态码 <code>301</code> 来下达给客户端的，让客户端完成跳转</li>
<li>“ <code>302 Found</code> ”：<strong>代表 临时跳转</strong>。例如：<code>URL</code> 地址 A 可以向 <code>URL</code> 地址 B 上跳转，但这并不是永久性的，在经过一段时间后，<code>URL</code> 地址 A 还可能向 <code>URL</code> 地址 C 上跳转</li>
<li>“ <code>304 Not Modified</code> ”：<strong>服务器通过返回状态码 <code>304</code> 可以告诉客户端请求资源成功</strong>，但是这个资源不是由服务器提供返回给客户端的，而是客户端本地浏览器缓存中就有的这个资源，因为可以从缓存中获取这个资源，从而节省传输的开销</li>
</ul>
</li>
<li><code>400</code> 类状态码表示 <strong>客户端发送的报文有误，服务器无法处理</strong>
<ul>
<li>“ <code>400 Bad Request</code> ”：表示 <strong>请求报文有错误</strong>，但具体是数据格式错误、缺少请求头还是 <code>URI</code> 超长它没有明确说，只是一个笼统的错误，客户端看到 <code>400</code> 只会是 “ 一头雾水 ”、“不知所措”</li>
<li>“ <code>403 Forbidden</code> ”：代表 <strong>请求的服务器资源权限不够</strong>，也就是没有权限去访问服务器的资源，或者请求的 <code>IP</code> 地址被封掉了</li>
<li>“ <code>404 Not Found</code> ”：代表 <strong>服务器上没有该资源</strong>，或者说服务器找不到客户端请求的资源，是最常见的请求错误码</li>
</ul>
</li>
<li><code>500</code> 类状态码表示 <strong>客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码</strong>
<ul>
<li>“ <code>500 Internal Server Error</code> ”：代表 <strong>服务器程序错误，也就是说请求的网页程序本身报错了</strong>。在服务器端的网页程序出错。由于现在的浏览器都会对状态码 <code>500</code> 做一定的处理，所以在一般情况下会返回一个定制的错误页面</li>
<li>“ <code>501 Not Implemented</code> ”：<strong>服务器不具备完成请求的功能</strong>。 例如：服务器无法识别请求方法时可能会返回此代码。</li>
<li>“ <code>502 Bad Gateway</code> ”：<strong>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</strong></li>
<li>“ <code>503 Service Unavailable</code> ”：<strong>表示服务器当前很忙，暂时无法响应客户端</strong>。我们上网时有时候遇到的 “网络服务正忙，请稍后重试” 的提示信息就是状态码 <code>503</code></li>
<li>“ <code>504 Gateway Timeout</code> ”：<strong>服务器作为网关或代理，但是没有及时从上游服务器收到请求</strong></li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225150709886.png" alt="HTTP状态码五大类" loading="lazy"></p>
<p><strong>详细链接</strong>：[12 响应状态码该怎么用？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/12">https://learn.lianglianglee.com/专栏/透视HTTP协议/12</a>  响应状态码该怎么用？.md)</p>
<hr>
<h3 id="什么情况下会出现502错误码呢？"><a class="headerlink" href="#什么情况下会出现502错误码呢？"></a>什么情况下会出现502错误码呢？</h3>
<p>答：</p>
<p>如果客户端访问服务器是通过 <code>Nginx</code> 来反向代理到应用服务器，那么如果应用服务器出现了故障，导致<code>Nginx</code> 无法从应用服务器获取到响应，这时候 <code>Nginx</code> 就会返回 <code>502</code> 错误码给客户端</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>502</code> （Bad Gateway）状态代码表示服务器在充当网关或代理时，在尝试满足请求时从它访问的入站服务器接收到无效响应</li>
<li>简单理解就是，<code>502</code> 其实是由 <strong>网关代理</strong>（<code>Nginx</code>）发出的，是因为 <strong>网关代理把客户端的请求转发给了服务端，但服务端却发出了无效响应，而这里的无效响应</strong>，一般是指 <code>TCP</code> 的 <code>RST</code> 报文或四次挥手的 <code>FIN</code> 报文
<ul>
<li><strong>屏蔽掉具体有哪些服务器的代理方式</strong> 就是所谓的 <strong>反向代理</strong></li>
<li>异常情况下，收发双方都不一定正常，连四次挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接：<code>RST</code> 一般用来异常地关闭一个连接，它是TCP包头中的一个标志位，在收到置这个标志位的数据包后，连接就会被关闭，此时接收到 <code>RST</code> 的一方，在应用层会看到一个 <code>connection reset</code> 或 <code>connection refused</code> 的报错</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225163323375.png" alt="FIN与Errors502" loading="lazy"></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225163442521.png" alt="RST与Errors502" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/722318.html">502问题怎么排查？你学会了吗？-502问题怎么解决</a></p>
<hr>
<h3 id="有个服务出现了504，你觉得这个服务是出了什么问题？"><a class="headerlink" href="#有个服务出现了504，你觉得这个服务是出了什么问题？"></a>有个服务出现了504，你觉得这个服务是出了什么问题？</h3>
<p>答：</p>
<p><code>504</code>是 <strong>网关超时错误</strong>，通常是 <strong><code>Nginx</code> 将请求代理到后端应用时，后端应用没有在规定的时间返回数据</strong>，需要开发检查下应用那块有什么耗时的操作，比如：<strong>是否出现了 <code>sql</code> 慢查询，接口是否发生死循环、死锁</strong> 等问题，然后后端服务器系统负载高不高</p>
<p><strong>链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9xSkSpQs-hzHJx7MumSEEg">面试又跪了，504 错误码是什么问题？</a></p>
<hr>
<h3 id="重定向是哪一类状态码？临时重定向和永久重定向有什么区别？"><a class="headerlink" href="#重定向是哪一类状态码？临时重定向和永久重定向有什么区别？"></a>重定向是哪一类状态码？临时重定向和永久重定向有什么区别？</h3>
<p>答：</p>
<ul>
<li>重定向 是数字 <code>3</code> 开头的状态码
<ul>
<li>客户端收到 <code>301</code> 状态码后，会记忆重定向后的 <code>URL</code> 地址，这样下一次访 <code>301</code> 状态码是代表<strong>永久重定向</strong>，问的时候，不需要访问旧 <code>URL</code>，直接跳转到新 <code>URL</code> 访问</li>
<li><code>302</code> 状态码代表 <strong>临时重定向</strong>，客户端收到 <code>302</code> 状态码后，不会记忆重定向后的 <code>URL</code> 地址，下一次访问的时候，还需要访问旧的 <code>URL</code>，再跳转访问新的 <code>URL</code></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>301</code> 永久重定向，浏览器会记住
<ul>
<li>假如：当你访问 <code>a.com</code> 时，永久重定向到了 <code>b.com</code>；那么下一次访问  <code>a.com</code> 时浏览器会直接跳转到 <code>b.com</code> 不会再请求 <code>a.com</code></li>
</ul>
</li>
<li><code>302</code> 临时重定向，浏览器不会记忆
<ul>
<li>假如：加入当你访问 <code>a.com</code> 时 临时重定向到了 <code>b.com</code>；那么下一次当你请求 <code>a.com</code> 时，浏览器还会先请求 <code>a.com</code> ，然后再重定向到 <code>b.com</code></li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110941264">重定向的理解301，302 - 知乎</a></p>
<hr>
<h3 id="HTTP-是长连接还是短连接？"><a class="headerlink" href="#HTTP-是长连接还是短连接？"></a>HTTP 是长连接还是短连接？</h3>
<p>答：</p>
<p><code>HTTP 1.0</code> 虽然支持长连接，但是 <strong>默认的连接行为是 短链接</strong>，从 <code>HTTP1.1</code> 版本之后，都是 <strong>默认长连接了</strong></p>
<p><strong>补充</strong>：</p>
<p>在 <code>HTTP 1.0</code> 中默认是关闭的，如果浏览器要开启 <code>Keep-Alive</code>，它必须在请求的包头中添加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接<br>
从 <code>HTTP 1.1</code> 开始， 就默认是开启了 <code>Keep-Alive</code>，如果要关闭 <code>Keep-Alive</code>，需要在 <code>HTTP</code> 请求的包头里添<br>
加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:close</span><br></pre></td></tr></table></figure>
<p>现在大多数浏览器都默认是使用 <code>HTTP/1.1</code>，所以 <code>Keep-Alive</code> 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了，<strong><code>HTTP</code> 长连接的优势是可以减少了 <code>TCP</code> 连接资源的开销</strong></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html#http-%E7%9A%84-keep-alive">4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding</a></p>
<hr>
<h3 id="HTTP-长连接和短连接的区别？"><a class="headerlink" href="#HTTP-长连接和短连接的区别？"></a>HTTP 长连接和短连接的区别？</h3>
<p>答：</p>
<ul>
<li><strong>短连接</strong>：每次通信请求都需要建立新的连接，请求完成后立即关闭连接。这样每次请求都需要建立连接和释放连接，会增加通信开销和延迟</li>
<li><strong>长连接</strong>：在通信过程中保持连接的持续性，多次请求可以共享同一个连接。在长连接中，客户端和服务器建立连接后可以进行多次请求和响应，减少了连接建立和释放的开销，提高了通信效率</li>
</ul>
<p><strong>补充</strong>：</p>
<p><strong>短连接</strong>：每次通信请求都需要建立新的连接，请求完成后立即关闭连接，下次请求还需要重新建立 <code>TCP</code> 连<br>
接</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225170142392.png" alt="短链接" loading="lazy"></p>
<p><strong>长连接</strong>：在通信过程中保持连接的持续性，多次请求可以共享同一个 <code>TCP</code> 连接</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225170330269.png" alt="长连接" loading="lazy"></p>
<hr>
<h3 id="HTTP-长连接有什么好处？"><a class="headerlink" href="#HTTP-长连接有什么好处？"></a>HTTP 长连接有什么好处？</h3>
<p>答：</p>
<p><strong>长连接 可以在一次 <code>TCP</code> 连接中可以发送和响应多个 <code>HTTP</code> 请求，可以减少了 <code>TCP</code> 连接资源创建和断开的开销</strong></p>
<p><strong>补充</strong>：</p>
<ul>
<li>短连接：在一次 <code>TCP</code> 连接中只能发送和响应一个 <code>HTTP</code> 请求，即：建立<code>TCP</code> → 请求资源 → 响应资源 → 释放连接</li>
<li>长连接：在一次 <code>TCP</code> 连接中可以发送和响应多个 <code>HTTP</code> 请求，即：建立TCP → 请求资源 → 响应资源 → 请求资源 → 响应资源 → 请求资源 → 响应资源 → 请求资源 → 响应资源 → …  → 释放连接</li>
</ul>
<hr>
<h3 id="HTTP-1-0-和-HTTP-1-1-的区别？"><a class="headerlink" href="#HTTP-1-0-和-HTTP-1-1-的区别？"></a>HTTP/1.0 和 HTTP/1.1 的区别？</h3>
<p>答：</p>
<ul>
<li><strong>长连接</strong>：<code>HTTP/1.1</code> 默认的连接行为是 <strong>长连接</strong>，而 <code>HTTP/1.0</code> 虽然也支持 长连接，但是默认是使用 <strong>短连接</strong></li>
<li><strong>请求管道化</strong>：<code>HTTP/1.1</code> 支持 <strong>请求管道传输</strong>（<code>pipline</code>）的方式，<code>HTTP/1.0</code> 不支持这个模式，<code>HTTP/1.0</code> <strong>请求和响应必须是串行的</strong>，当一个请求和它响应完成之后，才能发送下一个请求，而 <code>HTTP/1.1</code> 由于支持管道传输方式，因此可以并发发送 <code>HTTP</code> 请求，能够提高 <code>HTTP</code> 请求的效率，但是 <code>HTTP</code> 响应还是得按顺序响应，只有 <code>HTTP/2.0</code> 实现了 <code>HTTP</code> 请求和响应的并发传输的能力</li>
<li><strong><code>host</code> 字段</strong>：<strong>通过 <code>host</code> 头部字段，一个物理服务器可以承载多个域名或站点</strong>
<ul>
<li><code>HTTP/1.0</code> 没有 <code>host</code> 字段，<code>HTTP/1.1</code> 新增了 <code>host</code> 字段</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP/1.0</code> 和 <code>HTTP/1.1</code> 两者的主要区别体现在：</p>
<ul>
<li>
<p><strong>长连接</strong>：在 <code>HTTP/1.0</code> 中，默认使用的是短连接，也就是每次请求都要重新建立一次连接。<code>HTTP</code> 是基于<code>TCP/IP</code> 协议的，每一次建立或者断开连接，都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大，因此最好能维持一个长连接，可以用长连接来发多个请求。<code>HTTP 1.1</code> 起，默认使用长连接 <code>connection:keep-alive</code></p>
</li>
<li>
<p><strong>请求管道化</strong>：<code>HTTP 1.1</code> 支持<strong>请求管道化，即：在一个持久连接上可以同时发送多个请求</strong>，而 <code>HTTP 1.0</code> 不支持请求管道化，<code>HTTP/1.0</code> 请求和响应必须是串行的，当一个请求和它响应完成之后，才能发送下一个请求，而 <code>HTTP/1.1</code> 由于支持管道传输方式，因此可以并发发送 <code>HTTP</code> 请求，能够提高 <code>HTTP</code> 请求的效率</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225171615799.png" alt="请求管道化" loading="lazy"></p>
</li>
<li>
<p><strong><code>Host</code>头字段</strong>：<code>HTTP/1.0</code> 没有 <code>host</code> 字段，<code>HTTP/1.1</code> 新增了 <code>host</code> 字段，通过 <code>Host</code> 头部字段，一个物理服务器可以承载多个域名或站点</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225171807127.png" alt="Host头字段" loading="lazy"></p>
</li>
<li>
<p><strong>错误响应码</strong>：在 <code>HTTP 1.1</code> 中，新增了 <code>24</code> 个错误状态响应码</p>
<ul>
<li>例如： <code>409</code>（Conflict）：表示请求的资源与资源的当前状态发生冲突</li>
<li><code>410</code>（Gone）：表示服务器上的某个资源被永久性的删除</li>
</ul>
</li>
<li>
<p><strong>缓存处理</strong>：<code>HTTP 1.0</code> 中，主要使用 <code>header</code> 头里的 <code>If-Modified-since</code>、<code>Expires</code> 来做为缓存判断<br>
的标准；<code>HTTP 1.1</code>，则引入了更多的缓存控制策略，如：<code>Entity tag</code>、<code>If-Unmodified-since</code>、<code>If-Match</code>、<code>If-None-Match</code>等</p>
</li>
<li>
<p><strong>带宽优化及网络连接的使用</strong>：<code>HTTP 1.0</code> 中，存在一些浪费带宽的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象传送了过来，并且不支持断点续传功能；<code>HTTP 1.1</code> 中，则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206</code>（Partial Content），这样方便开发者自由的选择，以便于充分利用带宽和连接</p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/717215.html">阿里一面：HTTP 1.0 和 HTTP 1.1 有什么区别？-51CTO.COM</a></p>
<hr>
<h3 id="HTTP-1-1-和-HTTP-2-0-的区别？"><a class="headerlink" href="#HTTP-1-1-和-HTTP-2-0-的区别？"></a>HTTP/1.1 和 HTTP/2.0 的区别？</h3>
<p>答：</p>
<ul>
<li>我认为 <code>HTTP/1.1</code> 和 <code>HTTP/2.0</code> 最大的区别在于：
<ul>
<li><strong><code>HTTP/1.1</code> 无法实现请求和响应的并发传输，而<code>HTTP/2.0</code>  能够实现请求和响应的并发传输</strong>
<ul>
<li><strong>原因</strong>：<code>HTTP/1.1</code> 虽然支持了管道化请求模式，能够并发传输 <code>HTTP</code> 请求，但是 <code>HTTP</code> 响应还是需要按顺序返回，无法做到 <code>HTTP</code> 响应并发传输。<code>HTTP/2.0</code> 引入了 <code>stream</code> 的概念，不同的 <code>HTTP</code> 请求和响用不同的 <code>stream</code> 来区分，多个 <code>stream</code> 复用一条 <code>TCP</code> 连接，只需要一条连接就可以达到了并发传输的效果</li>
</ul>
</li>
<li><strong><code>HTTP2.0</code> 在 <code>HTTP</code> 报文格式上也做了改进，<code>HTTP2.0</code> 用了 <code>HPACK</code> 算法压缩了 <code>HTTP</code> 头部，同时将<code>HTTP/1.1</code> 纯文本的格式改进成了二进制格式，提高了数据传输的效率。<code>HTTP2.0</code> 还支持服务器主动推送资源</strong>，比如：客户端在从服务器获取 <code>HTML</code> 文件时，可能这个页面渲染还需要其他 <code>CSS</code>，这时候服务器可以接主动推送 <code>CSS</code> 文件，可以减少了消息传递的次数</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP/2.0</code> 相比 <code>HTTP/1.1</code> 性能上的改进：</p>
<ol>
<li><strong>并发传输</strong>（最重要的区别）</li>
<li><strong>头部压缩 + 二进制格式</strong></li>
<li><strong>服务器主动推送资源</strong></li>
</ol>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http2.html">3.6 HTTP/2 牛逼在哪？ | 小林coding</a></p>
<hr>
<h3 id="HTTP-2-0-和-HTTP-3-0-的区别？"><a class="headerlink" href="#HTTP-2-0-和-HTTP-3-0-的区别？"></a>HTTP/2.0 和 HTTP/3.0 的区别？</h3>
<p>答：</p>
<ul>
<li><strong><code>HTTP 2.0</code> 和 <code>3.0</code> 最大区别</strong>：<strong>传输层使用的协议不同</strong>。<strong>以往 <code>HTTP</code> 都是基于 <code>TCP</code> 协议进行传输，这次<code>HTTP3.0</code> 改用 <code>UDP</code> 协议</strong>
<ul>
<li><code>HTTP/2.0</code> 并发传输的特性，是在一条 <code>TCP</code> 连接上实现的这里会有 <code>TCP</code> 队头阻塞的问题，在传输过程中，假设：某个 <code>stream</code> 发生了丢包，服务端不仅不能处理这个<code>stream</code>，也不能处理其他 <code>stream</code>，必须等这个包重传了，才能继续处理其他 <code>stream</code></li>
<li>为了解决这个问题 <code>HTTP/3.0</code> 将传输层改用 <code>UDP</code> 协议，并在 <code>UDP</code> 基础上实现了一个可靠传输的 <code>QUIC</code> 协议，当某个流发生丢包时，只会阻塞这个 <code>stream</code> ，其他 <code>stream</code> 不会受到影响，因此不存在队头阻塞问题</li>
</ul>
</li>
<li>除此之外：
<ul>
<li><code>HTTP/3.0</code> 连接建立方面比 <code>HTTP/2.0</code> 更高效，<code>HTTP/2.0</code> 建立连接的时候需要 <code>3</code> 次 <code>TCP</code> 握手 + <code>TLS</code> 四次握手，而 <code>HTTP3.0</code> 的 <code>QUIC</code> 协议只需要 <code>3</code> 次握手就能完成连接建立（包括 <code>TLS</code> 握手建立）</li>
<li>最后还有一点，<strong><code>HTTP/3.0</code> 在网络环境切换的过程，可以不需要重新建立连接</strong>。以往 <code>HTTP</code> 都是基于 <code>TCP</code> 协议进行传输，<code>TCP</code> 是根据 四元组信息 唯一确认一条连接，如果 四元组信息 某一个信息发生变化了，这时候就需要断开连接，重新建立连接，比如：<code>4G</code> 网络切换到 <code>WIFI</code> 网络的时候，所有的 <code>TCP</code> 连接都需要重新建立，<strong>而 <code>HTTP/3.0</code> 是在应用层通过连接 <code>ID</code> 来唯一确认连接的，即使网络发生切换，也不会影响原本的连接，消除重连的成本</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>先提出 <code>HTTP 2.0</code> 的缺陷，存在 <code>TCP</code> 队头阻塞问题,，然后再提 <code>HTTP/3.0</code> 是怎么解决的，最后再提 <code>HTTP3.0</code> 还有什么新特性</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http3.html#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">3.7 HTTP/3 强势来袭 | 小林coding</a></p>
<hr>
<h3 id="HTTP-是无状态的吗？"><a class="headerlink" href="#HTTP-是无状态的吗？"></a>HTTP 是无状态的吗？</h3>
<p>答：</p>
<p>是的，<code>HTTP</code> 是无状态的，一般我们会通过 <code>Cookie</code>、<code>Session</code>、<code>Token</code> 这些机制来维护用户的状态</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 是 <strong>无状态</strong> 的，这意味着 <strong>每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息，在每个 <code>HTTP</code> 请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的</strong></li>
<li>因此 <strong>服务器不知道请求两次之间是否是同一个用户</strong>。这会带来一个问题，用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的，每次进行页面跳转的时候，得重新登录</li>
<li>虽然 <code>HTTP</code> 本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是：使用 <code>Cookie</code>、<code>Session</code>、<code>Token</code> 来跟踪用户状态。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能</li>
</ul>
<hr>
<h3 id="HTTP-用户后续的操作，服务端如何知道属于同一个用户？"><a class="headerlink" href="#HTTP-用户后续的操作，服务端如何知道属于同一个用户？"></a>HTTP 用户后续的操作，服务端如何知道属于同一个用户？</h3>
<h3 id="如果服务端是一个集群机器？"><a class="headerlink" href="#如果服务端是一个集群机器？"></a>如果服务端是一个集群机器？</h3>
<p>答：</p>
<p><strong>问题1</strong>：</p>
<ul>
<li>可以使用 <code>Session</code> <code>Cookie</code> 的机制 ，达到身份识别的效果</li>
<li>比如：我用 账号 和 密码 登录某电商，登录成功后，网站服务器会校验 用户 和 密码，如果没问题，网站服务器就会生成一个唯一 <code>session id</code> 来标识我，然后将该 <code>session id</code> 设置到 <code>Cookie</code> 中发送给客户端，客户端再次访问网站时，会将该 <code>Cookie</code> 发送给服务器，服务器通过 <code>Cookie</code> 中的 <code>Session ID</code> 可以获取用户之前的状态信息，免去了重复登录的麻烦，实现了状态保持</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP</code> 是 无状态 的，可以通过 <code>Session</code> <code>Cookie</code> 机制保持用户登陆的状态</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226140419599.png" alt="image-20241226140419599" loading="lazy"></p>
<ol>
<li>用户 向 服务器 发送 用户名 和 密码</li>
<li>服务器验证通过后，在当前对话（<code>session</code>）里面保存相关数据，比如：用户角色、登录时间等等</li>
<li>服务器向用户返回一个 <code>session id</code>，写入用户的 <code>Cookie</code>（响应头字段 <code>Set-Cookie=session id</code>）</li>
<li>用户随后的每一次请求，都会通过 <code>Cookie</code>（请求头字段 <code>Cookie</code>），将 <code>session id</code> 传回服务器</li>
<li>服务器收到 <code>session id</code>，找到前期保存的数据，由此得知用户的身份</li>
</ol>
<p><strong>问题2</strong>：</p>
<ul>
<li>如果服务端是一个 <strong>集群机器</strong> 的话， 可以用一台 <code>Redis</code> 来保存 <code>session</code> 数据，达到共享 <code>session</code> 的效果，不过这种方案存在 <strong>单点 的问题</strong>，如果 <code>Redis</code> 挂了，可能所有用户登陆状态都会消失了，虽然可以通过搭建 <code>Redis</code> 集群来保证避免 单点 问题，但是我觉得这个方案成本太高了</li>
<li>一种比较低的解决成本方案是，不用 <code>session</code>，而是改用 <code>JWT</code> 来实现用户凭证会比较好，<strong>因为 <code>JWT</code> 的状态信息是保存在客户端的，服务端不再保存状态信息，天然适合分布式系统</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>seesion</code> 这种方式扩展性不好，因为 <code>session</code> 状态信息是保存在服务器内存的，如果服务器是 集群，就要求 <code>session</code> 数据共享到每一台服务器，否则会出问题，比如：客户端登陆后，如果有一台服务器的内存没有 <code>session id</code> 的状态信息，当客户端请求到这台服务器后，服务器发现 <code>session id</code> 的状态信息不存在，就会让客户端重新进行用户登陆</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226140944417.png" alt="Session集群复制" loading="lazy"></p>
</li>
<li>
<p><strong>解决方案</strong>：</p>
<ul>
<li>
<p><strong>第一种方案</strong>：<strong>将 <code>session id</code> 集中保存在 <code>redis</code> 或者 <code>MySQL</code></strong>，服务器集群通过判断 <code>session id</code> 的状态信息在不在 <code>redis</code> 或者 <code>MySQL</code>，来确定用户是否已经登陆</p>
</li>
<li>
<p>这种方案的缺陷是 单点故障 的问题（虽然也可以对 <code>redis</code> 搭建集群，但是架构的成本太高了）</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226141154038.png" alt="解决方案一" loading="lazy"></p>
</li>
<li>
<p><strong>第二种方案</strong>：服务器索性不保存 <code>session</code> 数据了，把状态信息保存在客户端，每次请求都发回服务器，这个就是 <strong><code>token</code> 机制</strong>，为了保证 <code>token</code> 不被中间人篡改，可以 <strong>使用 <code>JWT</code> 的方式来进行身份识别</strong>，通常分布式系统都是采用 <code>JWT</code> 来进行身份状态识别</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226141418256.png" alt="JWT认证" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html#cookie-session">凭证 | 凤凰架构</a></p>
<hr>
<h3 id="如果禁用-Cookie，怎么实现-Session？"><a class="headerlink" href="#如果禁用-Cookie，怎么实现-Session？"></a>如果禁用 Cookie，怎么实现 Session？</h3>
<p>答：</p>
<p>可以通过重写 <code>URL</code> 来实现 <code>Session</code> 机制，就是在 <code>URL</code> 中增加 <code>session id</code> 请求参数</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>禁用 <code>Cookie</code> 代表无法使用响应头无法使用 <code>Set-Cookie</code> 字段，以及请求头无法使用 <code>Cookie</code> 字段，这时候就没办法通过 <code>HTTP</code> <code>Cookie</code> 传输 <code>Session id</code> 了</p>
</li>
<li>
<p>这时候可以重写 <code>URL</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始的URL: http://taobao.com/getitem?name=baymax&amp;action=buy</span><br><span class="line">重写后的uRL:http://taobao.com/getitem?sessionid=1wui87htentg&amp;name=baymax&amp;action=buy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="cookie-和-session-的区别？"><a class="headerlink" href="#cookie-和-session-的区别？"></a>cookie 和 session 的区别？</h3>
<p>答：</p>
<ul>
<li><strong>存储位置</strong>：<code>Cookie</code> 存储在<strong>浏览器</strong>，<code>Session</code> 存储在<strong>服务端</strong></li>
<li><strong>存储大小</strong>：<code>Cookie</code> 是存储在浏览器的，浏览器对单个 <code>Cookie</code> 存储大小有限制的，限制保存的数据不能超过 <code>4K</code>，而 <code>Session</code> 是存储在服务端的，所以没有这个限制</li>
<li><strong>安全性</strong>：<code>Cookie</code> 存储在客户端，比较容易遭到不法获取，会容易遭到 <code>XSS</code> 和 <code>CSRF</code> 的攻击，而 <code>Session</code>  存储在服务端，安全性相对 <code>Cookie</code> 要好一些</li>
<li><strong>有效期</strong>：<code>Cookie</code> 可设置为长时间保持，比如：经常使用的默认登录功能，<code>Session</code> 一般失效时间较短，客户端关闭或者 <code>Session</code> 超时都会失效</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>Cookie</code> 是 <strong>服务器 发送到 用户浏览器 并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>
<ul>
<li>通常，它用于 <strong>告知服务器两个请求是否来自同一浏览器</strong>。如：保持用户的登录状态，<code>Cookie</code> 使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能</li>
</ul>
</li>
<li><code>Session</code> 代表着 <strong>服务器 和 客户端 一次会话的过程</strong>。<code>Session</code> 对象存储 特定用户会话 所需的属性及配置信息。这样，当用户在应用程序的 <code>Web</code> 页之间跳转时，存储在 <code>Session</code> 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 <code>Session</code> 超时失效时会话结束</li>
<li><code>Cookie</code> 和 <code>Session</code> 都是 <code>Web</code> 开发中用于跟踪用户状态的技术，但它们在 <strong>存储位置、存储大小、安全性、生命周期</strong> 等方面存在显著差异：</li>
<li><strong>存储位置</strong>：
<ul>
<li><code>Cookie</code> 的数据存储在客户端（通常是浏览器）。当 浏览器 向 服务器 发送请求时，会自动附带 <code>Cookie</code> 中的数据</li>
<li><code>Session</code> 的数据存储在服务器端。服务器为每个用户分配一个唯一的 <code>Session ID</code>，这个 <code>ID</code> 通常通过 <code>Cookie</code> 或 <code>URL</code> 重写的方式发送给客户端，客户端后续的请求会带上这个 <code>Session ID</code>，服务器根据 <code>ID</code> 查找对应的 <code>Session</code> 数据</li>
</ul>
</li>
<li><strong>存储大小</strong>：
<ul>
<li>单个 <code>Cookie</code> 的大小限制通常在 <code>4KB</code> 左右，而且大多数浏览器对每个域名的总 <code>Cookie</code> 数量也有限制</li>
<li>由于 <code>Session</code> 存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小</li>
</ul>
</li>
<li><strong>安全性</strong>：
<ul>
<li><code>Cookie</code> 相对不安全，因为数据存储在客户端，容易受到 <code>XSS</code>（跨站脚本攻击）的威胁。不过，可以通过设置 <code>HttpOnly</code> 属性来防止 <code>JavaScript</code> 访问，减少 <code>XSS</code> 攻击的风险，但仍然可能受到<code>CSRF</code>（跨站请求伪造）的攻击</li>
<li><code>Session</code> 通常认为比 <code>Cookie</code> 更安全，因为敏感数据存储在服务器端。但仍然需要防范 <code>Session</code> 劫持（通过获取他人的<code>Session ID</code>）和会话固定攻击。</li>
</ul>
</li>
<li><strong>生命周期</strong>：
<ul>
<li><code>Cookie</code> 可以设置过期时间，过期后自动删除。也可以设置为会话 <code>Cookie</code>，即：浏览器关闭时自动删除</li>
<li><code>Session</code> 在默认情况下，当用户关闭浏览器时，<code>Session</code> 结束。但服务器也可以设置 <code>Session</code> 的超时时间，超过这个时间未活动，<code>Session</code>也会失效</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Cookie、session-和-Token-有什么区别？"><a class="headerlink" href="#Cookie、session-和-Token-有什么区别？"></a>Cookie、session 和 Token 有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>存储位置不同</strong>：
<ul>
<li><code>Cookie</code> <strong>存储在 客户端</strong>，即：浏览器中的文本文件，通过在 <code>HTTP</code> 头中传递给服务器来进行通信</li>
<li><code>Session</code> 是 <strong>服务器端 的存储方式</strong>，通常存储在服务器的内存或数据库中</li>
<li><code>Token</code> 也是<strong>存储在 客户端</strong>，但是通常以加密的方式存储在客户端的 <code>localStorage</code> 或 <code>sessionStorage</code> 中</li>
</ul>
</li>
<li><strong>数据安全性不同</strong>：
<ul>
<li><code>Cookie</code> <strong>存储在 客户端</strong>，可能会被窃取或篡改，因此对敏感信息的存储需要进行加密处理</li>
<li><code>Session</code> <strong>存储在 服务器端</strong>，通过一个 <code>Session ID</code> 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露</li>
<li><code>Token</code> 通常<strong>使用 加密算法 生成</strong>，有效期较短且单向不可逆，可以提供较高的安全性</li>
</ul>
</li>
<li><strong>跨域支持不同</strong>：
<ul>
<li>为了防止安全事故，因此 <code>Cookie</code> 是不支持跨域传输的，也就是<strong>不同域名下的 <code>Cookie</code> 是不能相互访问</strong></li>
<li><code>Session</code> 机制通常是通过 <code>Cookie</code> 来保存 <code>Session ID</code> 的，<strong>因此 <code>Session ID</code> 默认情况下也是不支持跨域的</strong></li>
<li>但 <code>Token</code> 可以轻松实现跨域，因为 <code>Token</code> 是存储在客户端的 <code>localStorage</code> 或者作为请求头的一部分发送到服务器的，所以<strong>不同的域名 <code>Token</code> 信息传输通常是不受影响的</strong></li>
</ul>
</li>
<li><strong>状态管理不同：</strong>
<ul>
<li><code>Cookie</code> 是应用程序通过在客户端存储临时数据，用于实现状态管理的一种机制</li>
<li><code>Session</code> 是服务器端记录用户状态的方式，服务器会为每个会话分配一个唯一的 <code>Session ID</code>，并将其与用户状态相关联</li>
<li><code>Token</code> 是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>Cookie</code>、<code>Session</code> 和 <code>Token</code> 通常都是用来保存用户登录信息的技术，但三者有很大的区别，简单来说：<code>Cookie</code> 适用于 简单的状态 管理，<code>Session</code> 适用于 需要保护用户敏感信息的场景，而 <code>Token</code> 适用于 状态无关的身份验证和授权</p>
<hr>
<h3 id="简述-JWT-的原理和校验机制？"><a class="headerlink" href="#简述-JWT-的原理和校验机制？"></a>简述 JWT 的原理和校验机制？</h3>
<p>答：</p>
<ul>
<li><code>JWT</code> 令牌是由 3 个部分组成，分别是：<strong>头部、负载、签名</strong>
<ul>
<li><strong>头部：描述令牌使用的签名算法，负载：描述的是用户信息</strong>，比如：用户名称、过期时间等等</li>
<li><strong>头部</strong> 和 <strong>负载</strong> 都是 <strong>不会被加密</strong> 的，只是会用 <code>base64</code> 编码</li>
<li><strong>最后一部分是 签名</strong>，<strong>是对 头部 和 负载 两部分数据的签名</strong>，<strong>签名的过程是，使用 头部 的签名算法，通过 服务器的密钥 对 前面两部分 内容进行 加密 计算</strong></li>
</ul>
</li>
<li><strong>校验 <code>JWT</code> 令牌的过程</strong>：
<ul>
<li>服务端 收到 客户端 发过来的 <code>JWT</code> 令牌后，服务端 会取出 头部 和 负载 数据，然后用自己的 密钥 对 这两部分数据 进行 加密 计算，将得到的 加密结果 和 客户端 发过来 <code>JWT</code> 的签名进行对比</li>
<li>如果相同，就表示前面两部分没有被中间人篡改，这时候服务器就可以进行其他验证，比如：检查 <code>JWT</code> 是否过期，如果也没问题，就会正常执行业务逻辑</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226152441440.png" alt="JWT令牌" loading="lazy"></p>
<ul>
<li>左边的字符串呈现了 <code>JWT</code> 令牌的本体，右边的 <code>JSON</code> 结构是 <code>JWT</code> 令牌中携带的信息</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226152604782.png" alt="JWT格式" loading="lazy"></p>
<ul>
<li>
<p><code>JWT</code> 格式是 <code>header.payload.signature</code></p>
</li>
<li>
<p><code>JWT</code> 共由 3 个部分信息组成：</p>
<ul>
<li>
<p><code>Header</code>（头部）：描述了 <strong>令牌的类型</strong>（统一为 <code>type:JWT</code>）以及 <strong>令牌签名的算法</strong>（默认 <code>HMACSHA256</code> 算法），<code>header</code> 信息不做加密，只做一般的 <code>base64</code> 编码，目的是替换 <code>URL</code> 里面有特殊含义</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153256258.png" alt="Header头部" loading="lazy"></p>
</li>
<li>
<p><code>Payload</code>（负载）：这是 <strong>令牌真正需要向服务端传递的信息</strong>。针对 认证 问题，负载至少应该包含能够告知服务端 “这个用户是谁” 的信息，<code>JWT</code> 的负载部分是可以完全自定义的，根据具体要解决的问题不同，设计自己所需要的信息。<code>Payload</code> 信息不做加密，只做一般的 <code>base64</code> 编码，目的是替换 <code>URL</code> 里面有特殊含义</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153314524.png" alt="Payload负载" loading="lazy"></p>
</li>
<li>
<p><code>Signature</code>（签名）：<strong>是对前两部分的签名，防止数据篡改</strong>。签名的意思是：使用在 <code>Header</code> 中公开的特定签名算法，通过特定的密钥（<code>Secret</code>，由服务器进行保密，不能公开）对前面两部分内容进行加密计算</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153615889.png" alt="Signature签名" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p><strong>验证 <code>JWT</code> 令牌的流程</strong>：</p>
<ol>
<li>服务端 收到 客户端 发过来 <code>JWT</code> 令牌之后，取出 <code>header + payload</code>，然后 服务端 根据自己的加密密钥进行加密计算</li>
<li>然后把 加密 的结果和 客户端 发过来 <code>JWT</code> 的 <code>signature</code> 进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了</li>
<li>当令牌验证为没有被篡改后，服务器可以进行其他验证，比如：是否过期、用户是否有权限访问 等等</li>
</ol>
</li>
</ul>
<hr>
<h3 id="JWT-令牌为什么能解决集群部署？"><a class="headerlink" href="#JWT-令牌为什么能解决集群部署？"></a>JWT 令牌为什么能解决集群部署？</h3>
<p>答：</p>
<p><code>JWT</code> 包含 身份验证 和 会话信息，可以让服务器无需存储会话信息，就让服务器成为无状态的了，从而比较容易实现扩展</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>JWT</code> 令牌通过在令牌中包含所有必要的 身份验证 和 会话信息，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。<strong>当用户进行登录认证后，服务器将生成一个 <code>JWT</code> 令牌并返回给客户端。客户端在后续的请求中携带该令牌，服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息，而无需访问共享的会话存储</strong></li>
<li>由于 <code>JWT</code> 令牌是自包含的，服务器可以独立地对令牌进行验证，而不需要依赖其他服务器或共享存储</li>
<li>这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和容错性</li>
</ul>
<hr>
<h3 id="JWT-有什么缺点？"><a class="headerlink" href="#JWT-有什么缺点？"></a>JWT 有什么缺点？</h3>
<p>答：</p>
<ul>
<li><code>JWT</code> 的最大缺点是 <strong>令牌难以主动失效，一旦 <code>JWT</code> 签发了，在到期之前就会始终有效，除非服务器搞了额外的逻辑</strong>，比如：设计一个 “黑名单” 的额外的逻辑，用来把要主动失效的令牌集中存储起来，然后，每次使用 <code>JWT</code> 进行请求的话都会先判断这个 <code>JWT</code> 是否存在于黑名单中</li>
<li><strong><code>JWT</code> 要防止盗用的问题</strong>，因为 <code>JWT</code> 包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限，<strong>为了减少盗用，<code>JWT</code> 的有效期应该设置得比较短，而且不应该使用 <code>HTTP</code> 协议明码传输，要使用 <code>HTTPS</code>  协议传输</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p><strong><code>JWT</code> 的缺点</strong>：</p>
<ul>
<li><strong>令牌难以主动失效</strong>：<code>JWT</code> 令牌一旦签发，理论上就和认证服务器再没有什么瓜葛了，在到期之前就会始终有效，除非服务器部署额外的逻辑去处理失效问题，这对某些管理功能的实现是很不利的
<ul>
<li>譬如一种颇为常见的需求是：要求一个用户只能在一台设备上登录，在 B 设备登录后，之前已经登录过的 A 设备就应该自动退出。如果采用 <code>JWT</code>，就必须设计一个 “黑名单” 的额外的逻辑，用来把要主动失效的令牌集中存储起来，而无论这个黑名单是实现在 <code>Session</code>、<code>Redis</code> 或者 数据库 中，都会让服务退化成有状态服务，降低了 <code>JWT</code> 本身的价值，但黑名单在使用 <code>JWT</code> 时依然是很常见的做法，需要维护的黑名单一般是很小的状态量，许多场景中还是有存在价值的</li>
</ul>
</li>
<li><strong>必须考虑令牌在客户端如何存储</strong>：严谨地说，这个并不是 <code>JWT</code> 的问题而是系统设计的问题。如果授权之后，操作完关掉浏览器就结束了，那把令牌放到内存里面，压根不考虑持久化才是最理想的方案。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的。这样的话，想想客户端该把令牌存放到哪里 是 <code>Cookie</code>？、<code>localStorage</code>？、<code>Indexed DB</code>？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充用户的身份做任何事情。为了减少盗用，<code>JWT</code> 的有效期应该设置得比较短，而且 <code>JWT</code> 不应该使用 <code>HTTP</code> 协议明码传输，要使用 <code>HTTPS</code> 协议传输</li>
</ul>
<hr>
<h3 id="什么是跨域？什么情况下会发生跨域请求？"><a class="headerlink" href="#什么是跨域？什么情况下会发生跨域请求？"></a>什么是跨域？什么情况下会发生跨域请求？</h3>
<p>答：</p>
<ul>
<li><strong>当一个网页去尝试访问不同源的资源的时候，就意味着发生了 跨域请求</strong>，只要 <strong>域名、协议、端口</strong> 这三个信息任意一个不同，都认为是不同源的 <code>URL</code></li>
<li><strong>跨域请求 在 浏览器 上是 不被允许的</strong>，只要在浏览器上发生跨域请求操作时，浏览器就会自动抛出的错误。如果想绕过这个限制，可以用 跨域资源共享（<code>CORS</code>）技术
<ul>
<li><strong>实现的方式</strong>：服务器需要在 <strong>响应头</strong> 上添加 <code>Access-Control-Allow-Origin</code> 的字段，这个字段是设置为需要放行的域名，浏览器识别到了，才能放行该请界</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>在浏览器环境下，当一个网页的脚本尝试去访问不同源（域名、协议、端口）的资源时，就会发生跨域请求。<strong>同源策略 是 浏览器 的一种安全机制，它限制了一个网页中的脚本只能访问同源下的资源，而不能直接访问其他域下的资源</strong></li>
<li>在以下情况下会发生跨域请求：
<ol>
<li><strong>域名不同</strong>：当浏览器中的网页从一个域名（例如：<code>www.example.com</code>）发起请求访问另一个域名(例如：<code>api.example.com</code>）的资源时，就会发生跨域请求</li>
<li><strong>协议不同</strong>：当浏览器中的网页从一个协议（例如：<code>http://</code>)发起请求访问另一个协议（例如：<code>https://</code>）的资源时，也会发生跨域请求</li>
<li><strong>端口不同</strong>：当浏览器中的网页从一个端口（例如：<a target="_blank" rel="noopener" href="http://example.com:8080">http://example.com:8080</a>）发起请求访问另一个端口（例如：<a target="_blank" rel="noopener" href="http://example.com:3000">http://example.com:3000</a>）的资源时，同样会发生跨域请求。</li>
</ol>
</li>
<li>跨域请求会受到 同源策略 的限制，可以通过下面这些方式绕过限制：
<ol>
<li><strong>使用反向代理</strong>：通过 <code>Nginx</code> 等工具设置反向代理，将跨域请求转发到目标服务器</li>
<li><strong><code>JSONP</code></strong>：网页通过添加一个 <code>script</code> 元素，向服务器请求 <code>JSON</code> 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。缺点是：只支持 <code>get</code> 请求，不支持 <code>post</code> 请求</li>
<li><strong><code>CORS</code></strong>：在服务端设置响应头部信息，允许特定源的请求访问</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/689093.html">跨域是个什么鬼，你搞明白了吗？-跨域是指什么</a></p>
<hr>
<h3 id="RestFul-是什么？RestFul-请求的-URL-有什么特点？"><a class="headerlink" href="#RestFul-是什么？RestFul-请求的-URL-有什么特点？"></a>RestFul 是什么？RestFul 请求的 URL 有什么特点？</h3>
<p>答：</p>
<ul>
<li><code>RestFul</code> 是一种 <code>API</code> 接口设计规范，<strong>用 <code>URL</code> 定位资源，用 <code>HTTP</code> 方法表示接口的动作，用 <code>HTTP</code> 状态码表示接口处理的情况</strong></li>
<li><code>RestFul</code> 风格的 <code>HTTP</code> 接口可以通过 <code>URL</code> 就能判定这个接口是做什么的
<ul>
<li><code>/articles POST</code> ：代表新增一个文章</li>
<li><code>/articles GET</code> ：代表获取全部文章</li>
<li>有可能后边带参数进行一些过滤查询或分页，<code>/articles/1 GET</code>：代表获取 <code>id</code> 为 <code>1</code> 这篇文章</li>
<li><code>/articles/1 PUT</code>：代表更新 <code>id</code> 为 <code>1</code> 的文章</li>
<li>请求体可能会带一些更新内容，<code>/articles/1 DELETE</code>：代表删除 <code>id</code> 为 <code>1</code> 的文章</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>RestFul</code> 简单理解就是用 <code>URL</code> 定位资源，用 <code>HTTP</code> 动词（<code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>）描述操作</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南 - 阮一峰的网络日志</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28557115">(13 封私信 / 33 条消息) 怎样用通俗的语言解释REST，以及RESTful？ - 知乎</a></p>
<hr>
<h2 id="HTTPS"><a class="headerlink" href="#HTTPS"></a>HTTPS</h2>
<hr>
<h3 id="HTTP-和-HTTPS-有什么区别？"><a class="headerlink" href="#HTTP-和-HTTPS-有什么区别？"></a>HTTP 和 HTTPS 有什么区别？</h3>
<p>答：</p>
<p>我的理解主要有 4 个方面的区别：</p>
<ul>
<li><strong>安全性</strong>：<code>HTTP</code> 是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。而 <code>HTTPS</code> 通过使用 <code>SSL/TLS</code> 协议对数据进行加密，提供了更高的安全性和数据保护</li>
<li><strong>建立连接</strong>：<code>HTTP</code> 连接建立相对简单， <code>TCP</code> 三次握手之后便可进行 <code>HTTP</code> 的报文传输。而 <code>HTTPS</code> 在 <code>TCP</code>  三次握手之后，还需进行 <code>SSL/TLS</code> 的握手过程，才可进入加密报文传输</li>
<li><strong>端口号</strong>：<code>HTTP</code> 默认使用 端口号 <code>80</code> 进行通信，而 <code>HTTPS</code> 默认使用端口号 <code>443</code></li>
<li><strong>证书</strong>：<code>HTTPS</code> 需要使用数字证书来验证服务器的身份，并确保数据传输的安全性。证书由受信任的第三方机构颁发，用于证明服务器的身份和所有权。而 <code>HTTP</code> 没有使用证书进行身份验证和加密</li>
</ul>
<hr>
<h3 id="了解过哪些加密算法？"><a class="headerlink" href="#了解过哪些加密算法？"></a>了解过哪些加密算法？</h3>
<p>答：</p>
<ul>
<li>我主要了解 <strong>对称加密算法、非对称加密算法、哈希算法</strong> 这三种加密算法：</li>
<li>在 <code>HTTPS</code> 协议里，<strong>对称加密算法</strong> 和 <strong>非对称加密算法</strong> 这两种算法都会用到
<ul>
<li>对称加密算法就是用一个密钥进行加解密，比如：<code>AES</code> 算法；非对称加密则是有 2 个密钥，分别是 公钥和 私钥，比如：<code>RSA</code>算法。对称加密算法 适用于 大量数据 的 加密 和 解密，而 非对称加密算法 适用于 密钥交换 和 数字签名 等场景</li>
</ul>
</li>
<li><strong>哈希算法</strong> 主要用过 <code>MD5</code> 算法，<strong>哈希算法 是一种 单向算法</strong>，用户可以通过 哈希算法 对目标信息生成一段特定长度的唯一的哈希值，却不能通过这个哈希值重新获得目标信息，所以用于数据完整性校验方面</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://blog.51cto.com/zhangchiworkos/3226867">常用的加密算法_51CTO博客_常用的加密算法有哪些</a></p>
<hr>
<h3 id="对称加密和非对称加密是什么？各自有哪些算法？"><a class="headerlink" href="#对称加密和非对称加密是什么？各自有哪些算法？"></a>对称加密和非对称加密是什么？各自有哪些算法？</h3>
<p>答：</p>
<ul>
<li>对称加密 和 解密 都是用 <strong>同一个密钥</strong> 进行操作，加密 和 解密 过程速度较快，适合对大量数据进行加密，对称密钥必须保密，不能明文传输，常见的对称加密算法有 <code>AES</code>、<code>DES</code>等</li>
<li>非对称加密使用 <strong>两个密钥</strong>，分别是 公钥 和 私钥，加密 和 解密 过程相对较慢，适合对少量数据进行加密。公钥 可以 任意分发，而 私钥 必须 保密，可以通过 <strong>公钥加密对称密钥，私钥解密</strong> 的方式，保证对称密钥的安全传输，常见的非对称加密算法有 <code>RSA</code>、<code>ECC</code> 等</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><strong>密钥区别</strong>：</p>
<ol>
<li><strong>对称加密</strong>：使用同一个密钥进行加密和解密。这意味着加密方和解密方必须事先共享同一个密钥，并且保证这个密钥的安全</li>
<li><strong>非对称加密</strong>：使用一对密钥，一个公开密钥（公钥）用于加密，一个私有密钥（私钥）用于解密。公钥可以公开分享，而私钥必须保持私密</li>
</ol>
</li>
<li>
<p><strong>加密速度区别</strong>:</p>
<ol>
<li><strong>对称加密</strong>：通常更快，因为它使用较简单的算法来处理大量数据</li>
<li><strong>非对称加密</strong>：由于其复杂的数学运算，尤其是在处理大量数据时，比对称加密得多</li>
</ol>
</li>
<li>
<p><strong>使用场景区别</strong>：</p>
<ol>
<li><strong>对称加密</strong>：适用于需要快速处理大量数据的场景，如：文件加密、数据库加密、网络数据传输加密等</li>
<li><strong>非对称加密</strong>：由于其速度较慢，通常用于加密少量数据或用于加密对称加密中使用的密钥</li>
</ol>
</li>
<li>
<p><strong>典型的加密算法</strong>：</p>
<ul>
<li>
<p><strong>对称加密算法</strong>：<code>AES</code>（高级加密标准）、<code>DES</code>（数据加密标准）、<code>3DES</code>（三重数据加密算法）等</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226163425830.png" alt="对称加密算法" loading="lazy"></p>
</li>
<li>
<p><strong>非对称加密算法</strong>：<code>RSA</code>、<code>ECC</code>（椭圆曲线密码学）等</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226163448040.png" alt="非对称加密算法" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903638117122056">浅谈常见的七种加密算法及实现数字签名、信息加密 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通 - 掘金</a></p>
<hr>
<h3 id="对称和非对称的加密算法的区别？"><a class="headerlink" href="#对称和非对称的加密算法的区别？"></a>对称和非对称的加密算法的区别？</h3>
<p>答：</p>
<ul>
<li>我理解的区别：
<ol>
<li>对称 加密 和 解密 都是用 同一个密钥 进行操作，加密和解密过程速度较快，适合对大量数据进行加密，对称密钥必须保密，不能明文传输</li>
<li>非对称 加密使用 两个密钥，分别是 公钥 和 私钥，加密和解密过程相对较慢，适合对少量数据进行加密。公钥可以任意分发，而私钥必须保密，可以通过公钥加密对称密钥，私钥解密的方式，保证对称密钥的安全传输</li>
</ol>
</li>
<li><code>HTTPS</code> 采用的就是这样的混合加密方式
<ul>
<li>在 <strong>通信建立前</strong> 采用 <strong>非对称加密</strong> 的方式 <strong>交换「对称密钥」，后续就不再使用非对称加密</strong>。在 <strong>通信过程中</strong> 全部 <strong>使用「对称密钥」的方式加密明文数据</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>可以从 <strong>加解密速度 + 密钥传输安全性</strong> 两个方向来说明区别</p>
<hr>
<h3 id="假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？"><a class="headerlink" href="#假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？"></a>假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？</h3>
<p>答：</p>
<p><strong>使用对称加密算法比较好</strong>，因为对称加密算法运算速度是比非对称加密更快的，比较适合数据量大常见的加密</p>
<p><strong>补充</strong>：</p>
<ul>
<li>对称密钥加密速度会比非对称密钥快，针对数据量比较大的场景，要选择对称密钥来加密。对称加密比非对称加密快的原因：
<ul>
<li>对称加密 主要的运算是 <strong>位运算</strong>，速度非常快，如果使用硬件计算，速度会更快，但是非对称加密计算一般都比较复杂，比如：<code>RSA</code>，它里面涉及到 大数乘法、大数模 等等运算</li>
<li>除了慢，可能还有一个缺点就是需要更多的位数，相同强度的对称密钥要比非对称密钥短。对称密钥一般都 128 位、256 位，而 <code>RSA</code> 一般要 2048 位，不过圆曲线的会短一点</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1672173">为什么非对称加密比对称加密慢？-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="HTTPS-建立的过程是怎么样的？"><a class="headerlink" href="#HTTPS-建立的过程是怎么样的？"></a>HTTPS 建立的过程是怎么样的？</h3>
<p>答：</p>
<ul>
<li>首先 客户端 要和 服务端 先进行 <code>TCP</code> 三次握手建立 <code>TCP</code> 连接。接下来，会进行 <code>TLS</code> 四次握手：
<ol>
<li><strong>第一次 <code>TLS</code> 握手</strong>：客户端首先会发一个 <code>Client Hello</code> 消息，消息里面有 <strong>客户端使用的 <code>TLS</code> 版本号、支持的密码套件列表、客户端生成的随机数</strong>，这个随机数是用来后面生成对称密钥元素之一</li>
<li><strong>第二次 <code>TLS</code> 握手</strong>：当服务端收到客户端的消息后，会返回 <code>Server Hello</code> 消息给的客户端，消息里面有服务器确认的 <code>TLS</code> 版本号、密码套件、服务端生成的随机数。接着服务端为了证明自己的身份，会发送 <code>Server Certificate</code> 给客户端，这个消息里含有数字证书。随后，服务端发了 <code>Server Hello Done</code> 消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次握手完毕
<ul>
<li><strong>校验证书</strong>：客户端收到服务端的数字证书的时候，会对校验服务端的证书，如果证书是合法的，客户端会用 <code>CA</code> 机构的公钥解密数字证书拿到服务端的公钥</li>
</ul>
</li>
<li><strong>第三次 <code>TLS</code> 握手</strong>：客户端再次生成一个随机数，用服务端的公钥加密后，通过 <code>Client Key Exchange</code> 消息传给服务端。服务端收到后，用服务端的私钥解密得到客户端的第二个随机数。到这里，服务端和客户端双方都有 3 个随机数，双方根据已经得到的三个随机数，会根据算法生成对称密钥。生成完对称密钥后，客户端会发一个消息告诉服务端开始使用对称加密方式发送消息，并且还会对之前所有发送的数据做个摘要，再用对称加密加密一下，让服务器做个验证，验证对称密钥是否可用，以及之前握手信息是否有被中途篡改</li>
<li><strong>第四次 <code>TLS</code> 握手</strong>：服务器也是同样的操作，发送消息告诉客户端开始用对称加密方式发送消息，并且也会对数据做个摘要，并用对称密钥加密一下，让客户端做个校验，如果双方都验证加密和解密没问题，那么 <code>TLS</code> 四次握手正式完成了</li>
</ol>
</li>
<li>最后，就用对称密钥加解密 <code>HTTP</code> 请求和响应了</li>
</ul>
<p><strong>补充</strong>：</p>
<img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226181009225.png" alt="HTTPS建立过程" style="zoom:150%;">
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226181118952.png" alt="HTTPS建立过程" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="为什么需要三个随机数？"><a class="headerlink" href="#为什么需要三个随机数？"></a>为什么需要三个随机数？</h3>
<p>答：</p>
<p>因为计算机生成的随机数其实是一个伪随机，那么只用一个随机数来生成的对称密钥很容易就被破解了，<strong>用三个伪随机数就十分接近随机了，这样称密钥破解的难度都变高了</strong></p>
<p><strong>补充</strong>：</p>
<ul>
<li>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 <code>SSL</code> 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性</li>
<li>对于 <code>RSA</code> 密钥交换算法来说，<code>pre-master-key</code>（第三个随机数）本身就是一个随机数，再加上 <code>hello</code> 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥</li>
<li><code>pre master</code>（第三个随机数）的存在在于 <code>SSL</code> 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<code>pre master secret</code>就有可能被猜出来，那么仅适用<code>pre master secret</code>（第三个随机数）作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 <code>pre master secret</code> 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志</a></p>
<hr>
<h3 id="一次HTTPS需要几次RTT（就是几个来回）？"><a class="headerlink" href="#一次HTTPS需要几次RTT（就是几个来回）？"></a>一次HTTPS需要几次RTT（就是几个来回）？</h3>
<p>答：</p>
<p><code>HTTPS</code> 是四次握手，那么就是 2 次 <code>RTT</code></p>
<p><strong>补充</strong>：</p>
<p><code>RTT</code> 是往返的延时，<code>HTTPS</code> 是四次握手，也就是代表 2 次往返，那么就是 2 次 <code>RTT</code></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="你了解业界现在有一个RTT建立HTTPS连接的方案吗？"><a class="headerlink" href="#你了解业界现在有一个RTT建立HTTPS连接的方案吗？"></a>你了解业界现在有一个RTT建立HTTPS连接的方案吗？</h3>
<p>答：</p>
<p>基于 <code>ECDHE</code> 密钥交换的 <code>HTTPS</code> 连接方案，可以实现1 个 <code>RTT</code> 建立 <code>HTTPS</code> 连接</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>TLS</code> 1.2 版本如果使用的是 <code>RSA</code> 密钥交换算法，那么需要 4 次握手，也就是要花费 2 <code>RTT</code>，才可以进行应用数据的传输</p>
</li>
<li>
<p>因此如果可以，尽量选用 <code>ECDHE</code> 密钥交换算法（<code>TLS</code> 1.3 版本使用）替换 <code>RSA</code> 算法，因为该算法由于支持<code>「TLS False start」</code>，客户端可以在 <code>TLS</code> 协议的第 3 次握手后，第 4 次握手之前，发送加密的应用数据，以此将 <code>TLS</code> 握手的消息往返由 2 <code>RTT</code> 减少到 1 <code>RTT</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228131547077.png" alt="TSL四次握手" loading="lazy"></p>
</li>
<li>
<p>下图左边是基于 <code>RSA</code> 算法的 <code>HTTPS</code> 建立流程，需要 2 个 <code>RTT</code>，右边是基于 <code>ECDHE</code> 算法的 <code>HTTPS</code> 建立流程，只需要 1 个 <code>RTT</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228131744258.png" alt="RSA算法与ECDHE算法的对比" loading="lazy"></p>
<ul>
<li>上图的右边部分就是 <code>TLS</code> 1.3（基于 <code>ECDHE</code> 算法）的握手过程，可以发现 <code>TLS</code> 1.3 <strong>把 <code>Hello</code> 和 公钥 交换这两个消息合并成了一个消息</strong>，于是这样就减少到只需 1 <code>RTT</code> 就能完成 <code>TLS</code> 握手</li>
<li>具体的做法是：客户端在 <code>Client Hello</code> 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥，服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 <code>RTT</code>，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了</li>
<li>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥</li>
<li>经过这 1 个 <code>RTT</code>，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_optimize.html">3.5 HTTPS 如何优化？ | 小林coding</a>、<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_ecdhe.html#ecdhe-%E7%AE%97%E6%B3%95">3.4 HTTPS ECDHE 握手解析 | 小林coding</a></p>
<hr>
<h3 id="HTTPS-过程进行了多少次非对称加密？多少次对称加密？"><a class="headerlink" href="#HTTPS-过程进行了多少次非对称加密？多少次对称加密？"></a>HTTPS 过程进行了多少次非对称加密？多少次对称加密？</h3>
<p>答：</p>
<ul>
<li><strong>还未 <code>HTTPS</code> 握手之前</strong>：
<ul>
<li>服务端在向 <code>CA</code> 机构注册证书的时候，<code>CA</code> 机构会用 <code>CA</code> 私钥会对服务端的公钥进行签名，形成数字证书，这里涉及了 1 次非对称加密</li>
</ul>
</li>
<li><strong><code>HTTPS</code> 握手期间</strong>：
<ul>
<li>客户端会用服务端的公钥加密随机数，服务端再用私钥解密，这里涉及了 1 次非对称加密</li>
<li>客户端和服务端生成对称密钥之后，都需要对之前握手的数据做个摘要，并用对称密钥加密一下，这个过程客户端和操作都会涉及到，所以 <code>HTTPS</code> 握手期间用了 2 次对称加密，客户端和服务端各做了一次</li>
</ul>
</li>
<li><strong><code>HTTPS</code> 握手完成之后</strong>：
<ul>
<li><code>HTTPS</code> 数据传输期间都是用对称密钥进行加密和解密</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>可以分 <code>HTTPS</code> 握手之前、期间、之后三个时间段来回答</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="SSL-握手流程为什么要使用非对称加密？"><a class="headerlink" href="#SSL-握手流程为什么要使用非对称加密？"></a>SSL 握手流程为什么要使用非对称加密？</h3>
<p>答：</p>
<ul>
<li>我的理解主要是为了保护对称加密钥不被中间人窃取，如果对称加密钥被窃取了，使用这个对称加密钥加密的 <code>HTTP</code> 报文就很容易被破解了</li>
<li>在 <code>HTTPS</code> 协议进行 <code>TLS</code> 握手的时候，客户端生成随机数，这个是生成对称加密钥元素之一，它会被公钥加密后传输给服务端，由服务端用私钥解密，这里就保证了对称加密钥的安全
<ul>
<li>因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="为什么-HTTPS-不用非对称加密算法加密-HTTP-报文？"><a class="headerlink" href="#为什么-HTTPS-不用非对称加密算法加密-HTTP-报文？"></a>为什么 HTTPS 不用非对称加密算法加密 HTTP 报文？</h3>
<p>答：</p>
<p>非对称加密算法的加密和解密操作相对比对称加密算法更消耗 <code>CPU</code> 计算力，也更耗时，而 <code>HTTP</code> 报文通常包含大量的数据，如果直接使用非对称加密算法对整个报文进行加密和解密，会导致性能下降和延迟增加</p>
<p><strong>补充</strong>：</p>
<p>要重点说明非对称加密算法更消耗 <code>CPU</code> 计算力，不适合用来频繁的加解密</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6855129005688340494">为什么非对称加密比对称加密慢？这个问题是一个读者面试时遇到的一个问题，准备过面试的人应该都记得，非对称加密与对称加密的区 - 掘金</a></p>
<hr>
<h3 id="HTTPS-会对-URL-加密吗？"><a class="headerlink" href="#HTTPS-会对-URL-加密吗？"></a>HTTPS 会对 URL 加密吗？</h3>
<p>答：</p>
<p><code>URL</code> 是属于 <code>HTTP</code> 报文头部的信息，<code>HTTPS</code> 会对整个 <code>HTTP</code> 报文都会加密，所以 <code>HTTPS</code> 是会对 <code>URL</code> 加密的</p>
<p><strong>补充</strong>：</p>
<p>很多人看到浏览器的地址栏就以为 <code>HTTPS</code> 不会对 <code>URL</code> 进行加密，实际上 <code>URL</code> 是属于 <code>HTTP</code> 报文头部的信息，<code>HTTPS</code> 会对整个 <code>HTTP</code> 报文（<code>header + body</code>）都加密，所以 <code>HTTPS</code> 是会对 <code>URL</code> 加密，之所以浏览器能明文显示 <code>URL</code>，是因为浏览器已经帮我们解密好了</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247518634&amp;idx=1&amp;sn=b1d36ef60ed5c53d89b9b2f953d149f8&amp;chksm=f98dcd00cefa4416730ed8a9bb5684a9572bc68ab9b05cb72eef5020f97b917d59d02d867340&amp;scene=178&amp;cur_album_id=1337204681134751744#rd">字节一面：HTTPS 会加密 URL 吗？</a></p>
<hr>
<h3 id="CA-机构如何验证server身份？"><a class="headerlink" href="#CA-机构如何验证server身份？"></a>CA 机构如何验证server身份？</h3>
<p>答：</p>
<p>服务端在向 <code>CA</code> 机构申请证书的时候，<code>CA</code> 机构会通过自己的私钥对服务器的一些信息进行数字签名，然后在 <code>HTTPS</code> 握手阶段的时候，服务端会发送证书给客户端来验证，客户端实际上已经内置了 <code>CA</code> 机构的公钥，那么就用这个公钥来验证服务端的数字证书是否是可信的</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228140417498.png" alt="CA机构流程" loading="lazy"></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228140509980.png" alt="CA机构流程" loading="lazy"></p>
<hr>
<h3 id="证书是绿色的是什么意思？"><a class="headerlink" href="#证书是绿色的是什么意思？"></a>证书是绿色的是什么意思？</h3>
<p>答：</p>
<p><strong>代表网站是 可信的</strong>，浏览器在 <code>HTTPS</code> 握手阶段会对网站服务器下发的证书进行校验,，如果校验成功，代表网站的身份的可信的，是被 <code>CA</code> 机构认证过的</p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/zhishi/dyl10.html">SSL证书是什么-什么是SSL证书-华为云</a></p>
<hr>
<h3 id="自己随便编一个证书可以吗？需要去什么地方注册？"><a class="headerlink" href="#自己随便编一个证书可以吗？需要去什么地方注册？"></a>自己随便编一个证书可以吗？需要去什么地方注册？</h3>
<p>答：</p>
<ul>
<li><strong>不可以</strong>
<ul>
<li>浏览器在校验这个证书的时候，会认为是非法的证书，这时候浏览器会显示访问的网站是不可信</li>
<li>得去 <code>CA</code> 机构申请证书，浏览器才会认为是合法的证书，这样才能正常的访问网站的内容</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>数字证书的作用</strong>：是用来认证 公钥持有者 的身份，以防止第三方进行冒充
<ul>
<li>说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。我们用证书来认证公钥持有者的身份（服务端的身份）</li>
</ul>
</li>
<li>那证书又是怎么来的？又该怎么认证证书呢？为了让服务端的公钥被大家信任，服务端的证书都是由 <code>CA</code> （<code>Certificate Authority</code>，证书认证机构）签名的，<code>CA</code> 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h2 id="RPC"><a class="headerlink" href="#RPC"></a>RPC</h2>
<hr>
<h3 id="RPC-的作用是什么？"><a class="headerlink" href="#RPC-的作用是什么？"></a>RPC 的作用是什么？</h3>
<p>答：</p>
<ul>
<li><code>RPC</code> 是远程过程调用，主要运用于微服务之间的通信</li>
<li>它的作用是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，让我们更专注于业务逻辑，而无需关注底层网络通信的细节</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>RPC</code> 的全称是 <code>Remote Procedure Call</code>，即：远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 <code>RPC</code> 调用了？显然并不够</li>
<li>我理解的 <code>RPC</code> 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。这就好比建在小河上的桥一样连接着河的两岸，如果没有小桥，我们需要通过划船、绕道等其他方式才能到达对面，但是有了小桥之后，我们就能像在路面上一样行走到达对面，并且跟在路面上行走的体验没有区别</li>
<li>所以我认为，<strong><code>RPC</code>的作用就是体现在这样两个方面</strong>：
<ul>
<li><strong>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法</strong></li>
<li><strong>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么有HTTP协议了？还要用RPC？"><a class="headerlink" href="#为什么有HTTP协议了？还要用RPC？"></a>为什么有HTTP协议了？还要用RPC？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 和 <code>RPC</code> 其实是两个维度的东西， <code>HTTP</code> 指的是 通信协议。而 <code>RPC</code> 则是远程调用，其对应的是本地调用。<code>RPC</code> 的通信可以用 <code>HTTP</code> 协议，也可以自定义协议，是不做约束的</li>
<li>用 <code>HTTP</code> 传输数据会有比较多的信息，比如：头部有各种字段信息，数据载体则一般是用 <code>json</code> 格式，而 <code>RPC</code> 因为它定制化程度更高，可以采用体积更小的 <code>protobuf</code> 或 其他序列化协议 去保存结构体数据，同时也不需要像 <code>HTTP</code> 那样考虑各种浏览器行为，比如：<code>302</code> 重定向跳转啥的，因此性能也会更好一些，这也是在公司内部微服务中抛弃 <code>HTTP</code>，选择使用 <code>RPC</code> 的最主要原因</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>RPC</code> 本质上不算是协议，而是一种调用方式，而像 <code>gRPC</code> 和 <code>Thrift</code> 这样的具体实现，才是协议，它们是实现了 <code>RPC</code> 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 <code>RPC</code> 有很多种实现方式，不一定非得基于 <code>TCP</code> 协议</li>
<li>从发展历史来说，<code>HTTP</code> 主要用于 <code>B/S</code> 架构，而 <code>RPC</code> 更多用于 <code>C/S</code> 架构。但现在其实已经没分那么清了，<code>B/S</code> 和 <code>C/S</code> 在慢慢融合。很多软件同时支持多端，所以对外一般用 <code>HTTP</code> 协议，而内部集群的微服务之间则采用 <code>RPC</code> 协议进行通讯</li>
<li><code>RPC</code> 其实比 <code>HTTP</code> 出现的要早，且比目前主流的 <code>HTTP/1.1</code> 性能要更好，所以大部分公司内部都还在使用<code>RPC</code></li>
<li><code>HTTP/2.0</code> 在 <code>HTTP/1.1</code>的基础上做了优化，性能可能比很多 <code>RPC</code> 协议都要好，但由于是这几年才出来的</li>
<li>所以也不太可能取代掉 <code>RPC</code></li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_rpc.html">3.8 既然有 HTTP 协议，为什么还要有 RPC？ | 小林coding</a></p>
<hr>
<h2 id="Nginx"><a class="headerlink" href="#Nginx"></a>Nginx</h2>
<hr>
<h3 id="Nginx-位于七层网络结构的哪一层？"><a class="headerlink" href="#Nginx-位于七层网络结构的哪一层？"></a>Nginx 位于七层网络结构的哪一层？</h3>
<p>答：</p>
<p><strong>应用层</strong>，<code>nginx</code> 是七层负载均衡</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228143328555.png" alt="OSI vs TCP/IP" loading="lazy"></p>
<ul>
<li>常说的七层和四层负载均衡，是用 <code>OSI</code> 网络模型来描述的，七层对应的是应用层，四层对应的是传输<br>
层</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1843920">讲讲亿级PV的负载均衡架构-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="Nginx-有哪些负载均衡算法？"><a class="headerlink" href="#Nginx-有哪些负载均衡算法？"></a>Nginx 有哪些负载均衡算法？</h3>
<p>答：</p>
<ul>
<li>我了解到的主要有 <strong>普通轮询、加权轮询、<code>IP</code> 哈希、<code>URL</code> 哈希、最短响应时间、最短连接</strong> 这些负载均衡算法</li>
<li>大体上可以分为下面几类：
<ol>
<li><strong>任务平分类</strong>：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的 “平均” 可以是绝对数量的平均，也可以是比例或者权重上的平均，比如：轮询 和 加权轮询算法</li>
<li><strong>负载均衡类</strong>：负载均衡系统根据服务器的负载来进行分配，可以用 <code>CPU</code> 负载来衡量，也可以用连接数 <code>I/O</code> 使用率、网卡吞吐量等来衡量系统的压力。比如：最短连接数算法</li>
<li><strong>性能最优类</strong>：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器，比如：最短响应时间算法</li>
<li><strong><code>Hash</code>类</strong>：负载均衡系统根据任务中的某些关键信息进行<code>Hash</code>运算，将相同<code>Hash</code>值的请求分配到同一台服务器上，比如：<code>IP</code>哈希和<code>URL</code>算法</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>Nginx</code>支持的负载均衡算法包括：
<ol>
<li><strong>轮询</strong>：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况</li>
<li><strong>加权轮询</strong>：按照权重分配请求给后端服务器，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率</li>
<li><strong><code>IP</code>哈希</strong>：根据客户端<code>IP</code>地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如：会话保持</li>
<li><strong><code>URL</code>哈希</strong>：按访问的<code>URL</code>的哈希结果来分配请求，使每个<code>URL</code>定向到一台后端服务器，可以进一步提高后端缓存服务器的效率</li>
<li><strong>最短响应时间</strong>：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡</li>
<li><strong>最短连接</strong>：新请求会发送到并发连接最少的服务节点</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247530864&amp;idx=2&amp;sn=6bd22fd310534b35eaee0683bf8b7ec1&amp;chksm=f98d3ddacefab4cc364ae0e2b78fa807262e1c3fafea79f882aa5c29f48d59a88e3fe1acfb53&amp;token=1615262746&amp;lang=zh_CN#rd">面试官：你背一下负载均衡算法？</a></p>
<hr>
<h3 id="什么是反向代理？什么是正向代理？"><a class="headerlink" href="#什么是反向代理？什么是正向代理？"></a>什么是反向代理？什么是正向代理？</h3>
<p>答：</p>
<p>正向代理 代理的 客户端 这一方，而 反向代理 是代理 服务器 这一方，可以通过负载均衡策略，将请求分发到不同服务器上</p>
<p><strong>补充</strong>：</p>
<ul>
<li>正向代理 是位于用户设备和互联网之间的服务器。它代理的是客户端，是站在用户一方的。其真实客户端对于服务器不可见
<ul>
<li><strong>正向代理通常用于</strong>：
<ol>
<li><strong>保护客户端，隐藏客户端真实 <code>IP</code>，免受攻击</strong></li>
<li><strong>避免网络浏览限制</strong>（科学上网）</li>
<li><strong>阻止访问某些内容</strong></li>
<li><strong>提高访问速度</strong>。通常代理服务器会有较大的硬盘缓冲区，将一些响应结果缓存在服务器端，以便后续用户取用</li>
</ol>
</li>
</ul>
</li>
<li>反向代理 是一种服务器，它接受客户端的请求，将请求转发给网络服务器，然后将结果返回给客户端，就像代理服务器处理了请求一样
<ul>
<li>反向代理代理的是服务器，是和网络服务器站在一方的。其真实服务器对于客户端不可见。这就是它叫 “反向” 的原因</li>
<li><strong>反向代理可用于</strong>：
<ol>
<li><strong>保护服务器，隐藏服务器真实 <code>IP</code></strong></li>
<li><strong>负载均衡，根据访问流量和服务器负载情况，将请求分发到不同服务器上</strong></li>
<li><strong>缓存静态内容以及部分短时间的大量动态请求</strong></li>
<li><strong>作为应用层防火墙提供防护，加密/解密 <code>SSL</code> 通信</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="TCP-三次握手"><a class="headerlink" href="#TCP-三次握手"></a>TCP 三次握手</h2>
<hr>
<h3 id="TCP头部有哪些字段？"><a class="headerlink" href="#TCP头部有哪些字段？"></a>TCP头部有哪些字段？</h3>
<p>答：</p>
<ul>
<li>我印象中 <code>TCP</code> 头部字段主要有 出序列号、确认号、源端口号、目的端口号、标记位：<code>SYN</code>、<code>ACK</code>、<code>FIN</code>、<code>RST</code>、头部长度、窗口大小，可扩展的选项这些</li>
<li>其中，序列号和确认号都是 32 位大小，序列号可以保证数据的有序性，接收方会按照发送方顺序发送的数据来组装有序的数据，确认号可以保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。然后，源端口号和目的端口号是 16 位大小，源端口是发送方使用的端口号，目的端口是接收方使用的端口号，端口的作用是标识 <code>TCP</code> 连接是哪个进程的</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103143224515.png" alt="TCP报文段的首部格式" loading="lazy"></p>
<ul>
<li><strong>源端口</strong>：16 位，标识报文的返回地址</li>
<li><strong>目的端口</strong>：16 位，指明接收方计算机上的应用程序接口</li>
<li><strong>序列号</strong>：32 位，在建立连接时由计算机生成的随机数作为其初始值，通过 <code>SYN</code> 包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序问题</li>
<li><strong>确认号</strong>：32 位，指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题</li>
<li><strong>数据偏移/首部长度</strong>：4 位，<code>TCP</code> 首部可能含有可选项内容，所以 <code>TCP</code> 报头的长度是不确定的，报头不包含任何任选字段则长度为 20 字节，4位首部长度字段所能表示最大长度为 60 字节。首部长度也叫数据偏移，因为首部长度实际上指示了数据区在报文段中的起始偏移值</li>
<li><strong>保留</strong>：6 位，为将来定义新的用途保留，现在一般置 0</li>
<li><strong>校验和</strong>：16 位，由发送端填充，接收端对 <code>TCP</code> 报文段执行 <code>CRC</code> 算法以检验 <code>TCP</code> 报文段在传输过程中是否损坏，这个校验不仅包括 <code>TCP</code> 头部，也包括数据部分。这是 <code>TCP</code> 实现可靠传输的一个重要保障</li>
<li><strong>窗口</strong>：16 位，是 <code>TCP</code> 流量控制的一个手段。通过窗口告诉对方本端的 <code>TCP</code> 接收缓冲区还能容纳多少字节的数据，这样对方可以控制发送数据的速度，从而达到流量控制。窗口大小为 16 bit字段，因而窗口大小最大为 65535</li>
<li><strong>紧急指针</strong>：16 位，只有当 <code>URG</code> 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。使用紧急指针是发送端向另一端发送紧急数据的一种方式</li>
<li><strong>选项和填充</strong>：<code>TCP</code> 头部的最后一个选项字段是可变长的可选信息。这部分最多包含40字节，因为 <code>TCP</code> 头部最长是 60 字节
<ul>
<li>最常见的可选字段是最长报文大小 <code>MSS</code>，每个连接方通常都在通信的第一个报文段中指明这个选项，它表示本端所能接受的最大报文段的长度</li>
</ul>
</li>
<li><strong>数据部分</strong>：<code>TCP</code> 报文段中的数据部分是可选的。在连接建立或者终止时，双方交换的报文段仅有 <code>TCP</code> 首部；如果一方没有数据要发送，也会使用没有任何数据的首部来确认收到的数据;在处理超时的许多情况中，也会发送不带任何数据的报文段</li>
</ul>
<p>还包括控制位：</p>
<ul>
<li><code>URG</code>：<strong>紧急指针标志</strong>，为 1 时表示紧急指针有效，该报文应该优先传送，为 0 则忽略紧急指针</li>
<li><code>ACK</code>：<strong>确认序号标志</strong>，为 1 时表示确认号有效，为 0 表示报文中不含确认信息。携带 <code>ACK</code> 标识的 <code>TCP</code> 报文段被称为确认报文段</li>
<li><code>RST</code>：<strong>重置连接标志</strong>，用于重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求。称携带 <code>RST</code> 标志的 <code>TCP</code> 报文段为复位报文段</li>
<li><code>SYN</code>：<strong>表示请求建立一个连接</strong>。称携带 <code>SYN</code> 标志的 <code>TCP</code> 报文段为同步报文段</li>
<li><code>FIN</code>：<strong>finish 标志</strong>，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。称携带<code>FIN</code> 标志的 <code>TCP</code> 报文段为结束报文段</li>
<li><code>PSH</code>：<strong>push 标志</strong>，为 1 表示是带有 <code>push</code> 标志的数据，指示接收方在接收到该报文段以后，应优先将这个报文段交给应用程序，而不是在缓冲区排队</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jummyer/p/11026966.html">TCP之报文首部格式 - Jummyer - 博客园</a></p>
<hr>
<h3 id="说一下TCP三次握手的过程？"><a class="headerlink" href="#说一下TCP三次握手的过程？"></a>说一下TCP三次握手的过程？</h3>
<p>答：</p>
<p><code>TCP</code> 三次握手的过程：</p>
<ol>
<li>最开始双方的 <code>TCP</code> 连接都处于 <code>close</code> 状态，服务端首先会监听一个端口，处于 <code>Listen</code> 状态</li>
<li>在第一次握手的时候，客户端会随机生成初始化序号，放到 <code>TCP</code> 报文头部的序号字段中，同时把 <code>SYN</code> 标志设置为 1，这样就表示 <code>SYN</code> 报文。接着把这个 <code>SYN</code> 报文发送给服务端，之后<strong>客户端处于 <code>SYN_SENT</code>状态</strong></li>
<li>服务端收到 <code>SYN</code> 报文后，首先服务端也会随机生成初始化序号，放到 <code>TCP</code> 报文头部的序号字段中，然后对 客户端的初始化序号+1 作为确认号，放到 <code>TCP</code> 报文头部的确认应答字段中，并将 <code>SYN</code> 和 <code>ACK</code> 标志设置为 1，这样就表示 <code>SYN-ACK</code> 报文，后把该报文发给客户端，之后<strong>服务端处于 <code>SYN_RCVD</code> 状态</strong></li>
<li>客户端收到服务端 <code>SYN-ACK</code> 报文后，客户端会回一个 <code>ACK</code> 确认报文，该报文的确认号是 服务端的初始化序号+1，并且 <code>ACK</code> 标志会设置为 1。之后客户端处于 <code>ESTABLISHED</code> 状态</li>
<li>服务端收到 <code>ACK</code> 确认报文后，服务端也进入处于 <code>ESTABLISHED</code> 状态</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103145903444.png" alt="TCP三次握手的过程" loading="lazy"></p>
<hr>
<h3 id="为什么需要三次握手？两次不行吗？"><a class="headerlink" href="#为什么需要三次握手？两次不行吗？"></a>为什么需要三次握手？两次不行吗？</h3>
<p>答：</p>
<p>我的理解主要有两个原因：</p>
<ul>
<li>第一个原因是：<strong>三次握手可以有效防止历史连接的建立，避免资源浪费</strong>。假设：网络中残留一个序号为 90 的 <code>SYN</code> 报文，现在客户端向服务端发起了建立连接的请求，发送了一个序号为 100 的 <code>SYN</code> 报文，如果这时候服务端先收到的是序号为 90 的 <code>SYN</code> 报文，就代表收到了历史连接，这时候服务端会回复确认号为 90+1 的 <code>SYN-ACK</code> 报文，客户端收到后，发现其实自己期望收到的确认号是 100+1，而不是 90+1，所以会断开连接，并且回 <code>RST</code> 给服务端，服务端收到 <code>RST</code> 也就会断开连接了，这样就避免了历史连接的建立。如果是两次握手的话，服务端在收到第一次握手就会建立连接，如果这时候建立的历史连接，那么就会造成资源浪费了</li>
<li>第二个原因是：<strong>三次握手可以确认客户端和服务端是否同时具备发送和接收的能力</strong>。第一握手代表客户端具有发送能力，当服务端收到第一次握手并且响应了第二次握手，实际上这里就证明了服务端具有发送和接收，客户端收到了第二次握手，然后响应了第三次握手，才代表客户端有接收的能力。如果是两次握手的话，只能证明服务端具有发送和接收能力，以及客户端的发送能力，但是无法证明客户端具有接收的能力。</li>
</ul>
<p>以上就是我觉得 <code>TCP</code> 需要三次握手的原因</p>
<hr>
<h3 id="如果第一次握手丢包，会发生什么？"><a class="headerlink" href="#如果第一次握手丢包，会发生什么？"></a>如果第一次握手丢包，会发生什么？</h3>
<p>答：</p>
<p>如果第一次握手丢包了，达到超时重传的时机的话，会进行重传 <code>SYN</code> 报文，如果重传次数达到最大次数，还是没有收到第二次握手的话，客户端就会断开链接了</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>当客户端想和服务端建立 <code>TCP</code> 连接的时候，首先第一个发的就是 <code>SYN</code> 报文，然后进入到 <code>SYN_SENT</code> 状态</p>
</li>
<li>
<p>在这之后，如果客户端迟迟收不到服务端的 <code>SYN-ACK</code> 报文（第二次握手），就会触发「超时重传」机制，重传 <code>SYN</code> 报文，而且重传的 <code>SYN</code> 报文的序列号都是一样的</p>
</li>
<li>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦</p>
</li>
<li>
<p>当客户端在 1 秒后没收到服务端的 <code>SYN-ACK</code> 报文后，客户端就会重发 <code>SYN</code> 报文，那到底重发几次呢?在 <code>Linux</code> 里，客户端的 <code>SYN</code> 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制，这个参数是可以自定义的，默认值一般是 5</p>
</li>
<li>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 <code>ACK</code>，客户端就不再发送 <code>SYN</code> 包，然后断开 <code>TCP</code> 连接。所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右</p>
</li>
<li>
<p>举个例子，假设 <code>tcp_syn_retries</code> 参数值为 3，那么当客户端的 <code>SYN</code> 报文一直在网络中丢失时，会发生下图的过程：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103151047088.png" alt="第一次握手丢包" loading="lazy"></p>
</li>
<li>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 <code>SYN</code> 报文后，由于 <code>tcp_syn_retries</code> 为 3，已达到最大重传次数，于是再等待段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（<code>SYN-ACK</code> 报文）那么客户端就会断开连接</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如果第二次握手丢包，会发生什么？"><a class="headerlink" href="#如果第二次握手丢包，会发生什么？"></a>如果第二次握手丢包，会发生什么？</h3>
<p>答：</p>
<p>我的理解第二次握手 <code>SYN-ACK</code> 报文其实有两个目的</p>
<ol>
<li>第一个是报文中的 <code>ACK</code>，是对第一次握手的确认报文，那么当第二次握手的丢失的时候，就会导致客户端长时间没有收到 <code>ACK</code> 而触发超时重传 <code>SYN</code> 报文（第一次握手）</li>
<li>第二个是报文中的 <code>SYN</code>，是服务端发起建立 <code>TCP</code> 连接的报文，那么当第二次握手的丢失的时候，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 <code>SYN-ACK</code> 报文</li>
</ol>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的</strong>：
<ol>
<li><strong>第二次握手里的 <code>ACK</code>， 是对第一次握手的确认报文</strong></li>
<li><strong>第二次握手里的 <code>SYN</code>，是服务端发起建立 <code>TCP</code> 连接的报文</strong></li>
</ol>
</li>
<li>因为第二次握手报文里是包含对客户端的第一次握手的 <code>ACK</code> 确认报文，所以，如果客户端迟迟没有收到第一次握手，那么客户端就觉得可能自己的 <code>SYN</code> 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 <code>SYN</code> 报文</li>
<li>然后，因为第二次握手中包含服务端的 <code>SYN</code> 报文，所以当客户端收到后，需要给服务端发送 <code>ACK</code> 确认报文（第三次握手），服务端才会认为该 <code>SYN</code> 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 <code>SYN-ACK</code> 报文。</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103151727981.png" alt="第二次握手丢包" loading="lazy"></p>
<hr>
<h3 id="如果第三次握手丢包，会发生什么？"><a class="headerlink" href="#如果第三次握手丢包，会发生什么？"></a>如果第三次握手丢包，会发生什么？</h3>
<p>答：</p>
<p>我的理解是第三次握手的 <code>ACK</code> 是对第二次握手的 <code>SYN</code> 报文的确认，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 <code>SYN-ACK</code> 报文，直到收到第三次握手，或者达到最大重传次数</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103151930175.png" alt="第三次握手丢包" loading="lazy"></p>
<hr>
<h3 id="TCP的半连接队列和全连接队列了解过吗？"><a class="headerlink" href="#TCP的半连接队列和全连接队列了解过吗？"></a>TCP的半连接队列和全连接队列了解过吗？</h3>
<p>答：</p>
<ul>
<li><strong>半连接队列</strong>：服务端收到客户端发起的 <code>SYN</code> 请求后，内核会把未完成握手的连接存储到半连接队列，等待完成三次握手后转移到全连接队列</li>
<li><strong>全连接队列</strong>：服务端收到第三次握手的 <code>ACK</code> 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列，等待进程调用 <code>accept</code> 函数时把连接取出来</li>
</ul>
<p><strong>补充</strong>：</p>
<p>在 <code>TCP</code> 三次握手的时候，<code>Linux</code> 内核会维护两个队列，分别是：</p>
<ul>
<li><strong>半连接队列，也称 <code>SYN</code> 队列</strong></li>
<li><strong>全连接队列，也称 <code>accept</code> 队列</strong></li>
</ul>
<p>服务端收到客户端发起的 <code>SYN</code> 请求后，内核会把该连接存储到半连接队列，并向客户端响应 <code>SYN+ACK</code>，接着客户端会返回 <code>ACK</code>，服务端收到第三次握手的 <code>ACK</code> 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 <code>accept</code> 队列，等待进程调用 <code>accept</code> 函数时把连接取出来</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103152305131.png" alt="TCP的半连接队列和全连接队列" loading="lazy"></p>
<hr>
<h2 id="TCP-四次挥手"><a class="headerlink" href="#TCP-四次挥手"></a>TCP 四次挥手</h2>
<hr>
<h3 id="TCP-四次挥手的过程？"><a class="headerlink" href="#TCP-四次挥手的过程？"></a>TCP 四次挥手的过程？</h3>
<p>答：</p>
<ol>
<li>客户端打算关闭连接，此时会发送一个 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态</li>
<li>服务端收到 <code>FIN</code> 报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭</li>
<li>客户端在 <code>TIME_WAIT</code> 状态经过 <strong>2MSL</strong>，一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭</li>
</ol>
<p>以上就是四次挥手的过程，每个方向都需要一个 <code>FIN</code> 和一个 <code>ACK</code>，因此通常被称为四次挥手</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103153256326.png" alt="TCP 四次挥手" loading="lazy"></p>
<hr>
<h3 id="为什么-TCP-需要四次挥手？三次挥手不行吗？"><a class="headerlink" href="#为什么-TCP-需要四次挥手？三次挥手不行吗？"></a>为什么 TCP 需要四次挥手？三次挥手不行吗？</h3>
<p>答：</p>
<ul>
<li>我的理解是 <code>TCP</code> 是全双工协议，双方都具备发送和接收的能力，那么在断开连接的期间，要确保双方能发送完自己的数据</li>
<li>当客户端发送第一次挥手后，也就是 <code>FIN</code> 报文的时候，其实就代表客户端告诉服务端 “我不会再发送数据了”，服务端收到后，服务器收到客户端的 <code>FIN</code> 报文时，内核会马上回一个 <code>ACK</code> 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 <code>FIN</code> 报文，而是将发送 <code>FIN</code> 报文的控制权交给服务端应用程序，如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数。所以第二次挥手和第三次挥手通常不会合并一起发送，而是分开发送，所以就需要四次挥手</li>
<li>如果只有三次挥手，那么就可能出现一方还有数据没有发送完就被迫关闭连接的情况，这会导致数据的丢失</li>
</ul>
<p><strong>补充</strong>：</p>
<p>要重点表述四次握手的原因是，<code>TCP</code> 是全双工的协议，需要双方确认自己不再发送数据的时候，才会主动发送 <code>FIN</code> 报文</p>
<hr>
<h3 id="TIME-WAIT-是如何产生的？"><a class="headerlink" href="#TIME-WAIT-是如何产生的？"></a>TIME_WAIT 是如何产生的？</h3>
<p>答：</p>
<p>当 <code>TCP</code> 连接的主动关闭方关闭连接，与被动关闭方进行了四次挥手的时候，在主动关闭方发送完第四次挥手后，也就是最后一个 <code>ACK</code> 报文后，主动关闭方的 <code>TCP</code> 连接就会进入到 <code>TIME_WAIT</code> 状态，这个状态会持续 2MSL 的时长，以确保对方已经收到了最后一个 <code>ACK</code> 报文</p>
<p><strong>补充</strong>：</p>
<p><code>TIME_WAIT</code> 状态是发生在客户端，其实不是的，<strong>准确来说 <code>TIME_WAIT</code> 状态发生在主动关闭连接的一方，客户端和服务端都可以作为主动关闭连接的一方</strong></p>
<hr>
<h3 id="为什么-TIME-WAIT-状态要等待-2MSL？"><a class="headerlink" href="#为什么-TIME-WAIT-状态要等待-2MSL？"></a>为什么 TIME_WAIT 状态要等待 2MSL？</h3>
<p>答：</p>
<p>我的理解主要有两个原因：</p>
<ul>
<li>第一个原因：<strong>主要是为了避免本次连接的历史报文，被新的连接接收到这些历史报文，从而导致出错</strong> ，<code>MSL</code> 表示 <code>TCP</code> 报文在网络中最大的存活时长，等待 2MSL 就可以让两个方向的报文可以在网络中自然消失这样新的连接就不会接收到历史报文了</li>
<li>第二个原因，<strong>是为了确保第四次挥手 <code>ACK</code> 报文能被接收，从而帮助被动关闭方正常关闭连接</strong>。如果主动关闭方的第四次挥手的 <code>ACK</code> 报文丢失了，由于被动关闭方没有收到这个 <code>ACK</code> 报文，它会超时重传 <code>FIN</code> 包，主动关闭方 <code>TIME_WAIT</code> 状态等待期间会重新发送 <code>ACK</code> 报文，如果没有 <code>TIME_WAIT</code> 状态，那么就没办法重新发生 <code>ACK</code> 报文，也就没办法帮助被动关闭方正常关闭连接了</li>
</ul>
<p>以上就是我对 <code>TIME_WAIT</code> 状态的理解</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>MSL</code> 是 <code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 <code>TCP</code> 报文基于是 <code>IP</code> 协议的，而 <code>IP</code> 头中有一个 <code>TTL</code> 字段，是 <code>IP</code> 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 <code>ICMP</code> 报文通知源主机</li>
<li><code>MSL</code> 与 <code>TTL</code> 的区别：<code>MSL</code> 的单位是时间，而 <code>TTL</code> 是经过路由跳数。所以 <code>MSL</code> 应该要大于等于 <code>TTL</code> 消耗为 0 的时间，以确保报文已被自然消亡</li>
<li><code>TTL</code> 的值一般是 64，<code>Linux</code> 将 <code>MSL</code> 设置为 30 秒，意味着 <code>Linux</code> 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</li>
<li><code>TIME_WAIT</code> 等待 2 倍的 <code>MSL</code>，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。比如：如果被动关闭方没有收到断开连接的最后的 <code>ACK</code> 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 <code>FIN</code> 后，会重发 <code>ACK</code> 给被动关闭方，一来一去正好 2 个 <code>MSL</code></li>
<li>可以看到 2MSL时长，这其实是相当于至少允许报文丢失一次。比如：若 <code>ACK</code> 在一个 <code>MSL</code> 内丢失，这样被动方重发的 <code>FIN</code> 会在第 2 个 <code>MSL</code> 内到达，<code>TIME_WAIT</code> 状态的连接可以应对</li>
<li>为什么不是 4 或者 8MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比</li>
<li>2MSL 的时间是从客户端接收到 <code>FIN</code> 后发送 <code>ACK</code> 开始计时的。如果在 <code>TIME_WAIT</code> 时间内，因为客户端的 <code>ACK</code> 没有传输到服务端，客户端又接收到了服务端重发的 <code>FIN</code> 报文，那么 2MSL 时间将重新计时。在<code>Linux</code> 系统里 2MSL 默认是 68 秒，那么一个 MSL 也就是 38 秒。<code>Linux</code> 系统停留在 <code>TIME_WAIT</code> 的时间为固定的 60 秒</li>
</ul>
<hr>
<h3 id="TIME-WAIT-过多有什么危害"><a class="headerlink" href="#TIME-WAIT-过多有什么危害"></a>TIME_WAIT 过多有什么危害?</h3>
<p>答：</p>
<ul>
<li>客户端和服务端 <code>TIME_WAIT</code> 过多，造成的影响是不同的
<ul>
<li>如果客户端（主动发起关闭连接方）的 <code>TIME_WAIT</code> 状态过多，占满了所有端口资源，那么就无法对「目的<code>IP</code> + 目的 <code>PORT</code>」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的</li>
<li>因此，客户端（发起连接方）都是和「目的 <code>IP</code> + 目的 <code>PORT</code>」都一样的服务端建立连接的话，当客户端的 <code>TIME_WAIT</code> 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的<code>IP</code> + 目的 <code>PORT</code>」都一样的服务端建立连接了</li>
<li>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组 <code>(源IP、源端口、目的IP、目的端口)</code> 信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</li>
</ul>
</li>
<li>如果服务端（主动发起关闭连接方）的 <code>TIME_WAIT</code> 状态过多，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 <code>TCP</code> 连接，因此理论上服务端可以建立很多连接，但是 TCP连接过多，会占用系统资源，比如：文件描述符、内存资源、CPU 资源、线程资源等</li>
</ul>
<p><strong>补充</strong>：</p>
<p>过多的 <code>TIME_WAIT</code> 状态主要的危害有两种：</p>
<ol>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768~61000 也可以通过<code>net.ipv4.ip .local_port_range</code> 参数指定范围</li>
</ol>
<p>客户端和服务端 <code>TIME_WAIT</code> 过多，造成的影响是不同的。所以要从客户端过多 <code>TIME_WAIT</code> 状态和服务端过多 <code>TIME_WAIT</code> 状态来回答</p>
<hr>
<h3 id="怎么解决-TIME-WAIT-状态过多的问题？"><a class="headerlink" href="#怎么解决-TIME-WAIT-状态过多的问题？"></a>怎么解决 TIME_WAIT 状态过多的问题？</h3>
<p>答：</p>
<ul>
<li>如果是客户端有大量 <code>time_wait</code> 状态，可以考虑开启 <code>tcp_tw_reuse</code> 参数，当发起新连接的时候，会复用处于 <code>time_wait</code> 状态的连接</li>
<li>如果是服务端的话，尽量让主动断开连接的方式，由客户端来进行，可以在应用层设计一个逻辑，当服务端要断开连接的时候，发送一个消息给客户端，客户端收到之后，由客户端来断开 <code>tcp</code> 连接，这样服务端就不会有 <code>time_wait</code> 状态了。</li>
</ul>
<p><strong>补充</strong>：</p>
<p>可以分客户端和服务端来回答</p>
<ul>
<li>客户端：开启 <code>tcp_tw_reuse</code> 参数，客户端在调用 <code>connect()</code> 函数时，内核会随机找一个 <code>time_wait</code> 状态超过 1 秒的连接给新的连接复用</li>
<li>服务端：服务端不主动断开 <code>tcp</code> 连接，将断开 <code>tcp</code> 连接的主动权交给客户端</li>
</ul>
<hr>
<h3 id="服务端产生大量-TIME-WAIT-状态的原因是什么？"><a class="headerlink" href="#服务端产生大量-TIME-WAIT-状态的原因是什么？"></a>服务端产生大量 TIME_WAIT 状态的原因是什么？</h3>
<p>答：</p>
<p>主动关闭方才会有 <code>TIME_WAIT</code> 状态，当服务端有大量 <code>TIME_WAIT</code> 状态的连接的时候，代表服务端主动关闭了连接，我觉得可能的原因是：</p>
<ul>
<li><strong><code>HTTP</code> 没有使用长连接，这时候客户端和服务端都是短连接</strong>，服务端发送完 <code>HTTP</code> 响应后，就会主动关闭了连接，如果有大量的短连接过来，那么服务端就会出现大量的 <code>TIME_WAIT</code> 状态，如果是这个问题的话，解决方式就是让客户端和服务端都开启 HTTP <code>Keep-Alive</code> 机制</li>
<li><strong><code>HTTP</code> 长连接的请求数量设置过小，<code>Web</code> 服务端通常会有个参数，来定义一条 <code>HTTP</code> 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接</strong>。比如：<code>Nginx</code> 的 <code>keepalive_requests</code> 这个参数，默认是 100，味着每个 <code>HTTP</code> 长连接最多只能跑 100 次请求，因为当 <code>QPS</code> 请求很高的时候，<code>Nginx</code> 就会频繁的关闭连接，那么此时服务端上就会出大量的 <code>TIME_WAIT</code> 状态。解决的方式也很简单，调大 <code>Nginx</code> 的 <code>keepalive_requests</code> 参数就行</li>
</ul>
<p><strong>补充</strong>：</p>
<p>主动关闭方才会有 <code>TIME_WAIT</code> 状态，所以就要分析服务端为什么会主动关闭连接？</p>
<ul>
<li>第一个场景：<code>HTTP</code> 没有使用长连接</li>
<li>第二个场景：<code>HTTP</code> 长连接的请求数量达到上限</li>
</ul>
<hr>
<h3 id="服务端产生大量-CLOSE-WAIT-状态的原因是什么？"><a class="headerlink" href="#服务端产生大量-CLOSE-WAIT-状态的原因是什么？"></a>服务端产生大量 CLOSE_WAIT 状态的原因是什么？</h3>
<p>答：</p>
<ul>
<li>我觉得问题原因在于，<strong>是服务端没有及时调用 <code>close</code> 关闭连接的函数，导致出现大量 <code>CLOSE_WAIT</code> 状态的连接</strong>，因为只有正确调用了 <code>close</code> 关闭连接函数的时候，<code>TCP</code> 连接状态才会有从 <code>CLOSE_WAIT</code> 状态变为 <code>LAST_ACK</code> 状态</li>
<li>我觉得大概率服务端的代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 <code>close</code></li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>CLOSE_WAIT</code> 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 <code>close</code> 函数关闭连接，那么就无法发出 <code>FIN</code> 报文，从而无法使得 <code>CLOSE_WAIT</code> 状态的连接转变为 <code>LAST_ACK</code> 状态</li>
<li>所以，当服务端出现大量 <code>CLOSE_WAIT</code> 状态的连接的时候，说明服务端的程序没有调用 <code>close</code> 函数关闭连接</li>
</ul>
<hr>
<h3 id="如果server发送FIN之后，因为client挂掉了，收不到回应，会发生什么？"><a class="headerlink" href="#如果server发送FIN之后，因为client挂掉了，收不到回应，会发生什么？"></a>如果server发送FIN之后，因为client挂掉了，收不到回应，会发生什么？</h3>
<p>答：</p>
<p>会触发超时重传机制，重传 <code>FIN</code> 报文，如果 <code>FIN</code> 报文达到最大的重传次数之后，还是没有收到响应，那么<code>server</code> 就会断开链接了</p>
<p><strong>补充</strong>：</p>
<p>只要发送的数据没有收到响应，都会触发超时重传，重传达到最大次数之后，就会关闭连接了</p>
<hr>
<h3 id="如果客户端宕机重启，收到了server-的-FIN，会发生什么？"><a class="headerlink" href="#如果客户端宕机重启，收到了server-的-FIN，会发生什么？"></a>如果客户端宕机重启，收到了server 的 FIN，会发生什么？</h3>
<p>答：</p>
<p>既然客户端宕机重启了，之前的 <code>TCP</code> 连接信息就不存在了，那么如果收到 <code>server</code> 的 <code>FIN</code>，会回 <code>RST</code> 报文给<code>server</code>，<code>server</code> 收到 <code>RST</code> 报文就会断开连接</p>
<p><strong>补充</strong>：</p>
<p>如果 <code>TCP</code> 连接信息没有了，那么再次收到该 <code>TCP</code> 连接的报文，就会回 <code>RST</code> 报文</p>
<hr>
<h2 id="TCP-与-UDP"><a class="headerlink" href="#TCP-与-UDP"></a>TCP 与 UDP</h2>
<hr>
<h3 id="TCP-和-UDP-有什么区别？"><a class="headerlink" href="#TCP-和-UDP-有什么区别？"></a>TCP 和 UDP 有什么区别？</h3>
<p>答：</p>
<p>我觉得主要有这几个方面的区别：</p>
<ul>
<li><code>TCP</code> 是面向连接的协议，在发送数据的时候，需要先建立 <code>TCP</code> 三次握手，而 <code>UDP</code> 无连接的协议，直接就可以发送数据</li>
<li><code>TCP</code> 会通过超时重传、流量控制、拥塞控制保证数据的可靠传输，而 <code>UDP</code> 并没有这些特性，<code>UDP</code> 不考虑数据的可靠性</li>
<li><code>TCP</code> 发送的数据是以字节流的形式，没有边界。而 <code>UDP</code> 是一个包一个包的发送，是有边界的</li>
</ul>
<p>所以，综合来看:</p>
<ul>
<li><code>TCP</code> 的优势在于可以保证数据的可靠性，但是缺陷就是实时性没有 <code>UDP</code> 协议好</li>
<li><code>UDP</code> 的优势在于足够简单，不用建立连接，数据直接丢过去即可，并且 <code>UDP</code> 包头比 <code>TCP</code> 包头小很多</li>
</ul>
<p>所以 <code>UDP</code> 实时性和速度方面是比 <code>TCP</code> 好的</p>
<p><strong>补充</strong>：</p>
<ul>
<li>可以从几个角度分析：连接、可靠性、传输方式</li>
<li>最后总结，这两个协议的优劣势</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/chinese/news/tcp-vs-udp-which-is-faster/">TCP vs UDP——哪个协议更快？</a></p>
<hr>
<h3 id="什么时候用-TCP？什么时候用-UDP？"><a class="headerlink" href="#什么时候用-TCP？什么时候用-UDP？"></a>什么时候用 TCP？什么时候用 UDP？</h3>
<p>答：</p>
<ul>
<li>如果主要关注数据接收的可靠性和顺序，可以选使用 <code>TCP</code>，比如：<code>FTP</code>协议、<code>HTTP</code>协议都是基于 <code>TCP</code> 协议进行传输数据</li>
<li>如果主要关注的是速度和实时性，而且并不在意某些数据包的丢失，可以选使用 <code>UDP</code> 协议，比如：直播视频会议场景</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>UDP</code> 和 <code>TCP</code> 应用场景：</p>
<ul>
<li><code>TCP</code> 传输速度慢，但是数据传输可靠性高</li>
<li><code>UDP</code> 传输速度快，但是不保证传输的可靠性</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103161818273.png" alt="TCP vs UDP" loading="lazy"></p>
<hr>
<h3 id="此时此刻的视频面试用的-UDP-还是-TCP？UDP丢包会有什么现象？"><a class="headerlink" href="#此时此刻的视频面试用的-UDP-还是-TCP？UDP丢包会有什么现象？"></a>此时此刻的视频面试用的 UDP 还是 TCP？UDP丢包会有什么现象？</h3>
<p>答：</p>
<p>我觉得是 <code>UDP</code> 协议，因为视频会议这个场景下，重要的是实时性，<code>UDP</code> 协议实时性比 <code>TCP</code> 好，采用 <code>UDP</code> 协议传输音视频数据的话，如果发生了丢包，只是就丢失某一瞬间的画面和语音，然后还可以继续进行会议沟通，不会太影响视频会议的体验，如果是采用 <code>TCP</code> 协议的，由于 <code>TCP</code> 是可靠传输，如果发生了丢包，可能画面就卡住不动，等丢包重传才会推进画面，这样实时性就比较差了</p>
<p><strong>详细链接</strong>：[34 UDP 协议：UDP 和 TCP 相比快在哪里？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/34">https://learn.lianglianglee.com/专栏/重学操作系统-完/34</a>  UDP 协议：UDP 和 TCP 相比快在哪里？.md)</p>
<hr>
<h3 id="UDP-怎么改造变为可靠传输？"><a class="headerlink" href="#UDP-怎么改造变为可靠传输？"></a>UDP 怎么改造变为可靠传输？</h3>
<p>答：</p>
<ul>
<li>我会在应用层<strong>增加序列号字段，用来确保 <code>UDP</code> 的数据可以按序接收，同时还会增加确认号，用来实现超时重传机制</strong>，当超过一定时间内没收到已发送数据的确认号，就重传该数据包</li>
<li>我还会在应用层开辟一个缓冲区，用来实现滑动窗口，有了滑动窗口这样发送数据可以先批量发送数据，不需要等上一个数据的确认了才能发送，提高了发送速率，同时还可以<strong>基于滑动窗口实现流量控制</strong>，用来保证发送方能按接收方的接收能力发送数据，避免发送的数据对方接收不了而发生数据丢失</li>
<li>最后，为了保证整个网络的带宽环境，还需要<strong>实现拥塞控制，确保发送方的数据，不会占满整个带宽</strong></li>
<li>我觉得 UDP 实现可靠传输相比 TCP 可靠传输有几点优势：
<ol>
<li><strong>拥塞控制算法可以根据不同的应用选用不同的拥塞控制算法</strong>，而 <code>TCP</code> 选用拥塞控制算法的时候，是所有应用都使用这一套拥塞控制算法</li>
<li><strong>升级方便</strong>，<code>TCP</code> 是在内核实现的，升级 <code>TCP</code> 需要升级操作系统，而 <code>UDP</code> 可靠传输是在应用层实现的，升级协议就像升级软件一样简单</li>
<li><strong>可以实现网络连接迁移</strong>，在应用层用连接<code>id</code>来唯一标识一个连接，不必像 <code>TCP</code> 那样，是通过四元组才确定连接的，只要四元组的信息发生了变化，就需要重新建立连接</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>按照 <code>TCP</code> 协议怎么实现可靠传输的方式，在应用层实现一遍就好了，最后可以补充说明基于 <code>UDP</code> 协议实现的可靠传输相比于 <code>TCP</code> 有什么优势</p>
<hr>
<h3 id="TCP-和-UDP-可以共用一个端口吗？"><a class="headerlink" href="#TCP-和-UDP-可以共用一个端口吗？"></a>TCP 和 UDP 可以共用一个端口吗？</h3>
<p>答：</p>
<ul>
<li><strong>可以的</strong></li>
<li><code>socket</code> 是根据五元组信息唯一确认的：<strong>协议类型、源 ip 地址、源端口、目标 ip 地址、目标端口</strong>，只要有一个信息不同，就会认为是不同的 <code>socket</code>，不会引起冲突，所以 <code>TCP</code> 和 <code>UDP</code> 是可以共用一个端口号的</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>在数据链路层中，通过 <code>MAC</code> 地址来寻找局域网中的主机。在网际层中，通过 <code>IP</code> 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序</p>
</li>
<li>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包</p>
</li>
<li>
<p>传输层有两个传输协议分别是 <code>TCP</code> 和 <code>UDP</code>，在内核中是两个完全独立的软件模块。当主机收到数据包后，可以在 <code>IP</code> 包头的「协议号」字段知道该数据包是 <code>TCP/UDP</code>，所以可以根据这个信息确定送给哪个模块（<code>TCP/UDP</code>）处理，送给 <code>TCP/UDP</code> 模块的报文根据「端口号」确定送给哪个应用程序处理</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103163730480.png" alt="TCP、UDP公用一个端口号" loading="lazy"></p>
</li>
<li>
<p>因此， <code>TCP/UDP</code> 各自的端口号也相互独立，如：<code>TCP</code> 有一个 80 号端口，<code>UDP</code> 也可以有一个 80 号端口，二者并不冲突</p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97">4.18 TCP 和 UDP 可以使用同一个端口吗？ | 小林coding</a></p>
<hr>
<h2 id="TCP-可靠性"><a class="headerlink" href="#TCP-可靠性"></a>TCP 可靠性</h2>
<hr>
<h3 id="TCP-是如何保证可靠性的？"><a class="headerlink" href="#TCP-是如何保证可靠性的？"></a>TCP 是如何保证可靠性的？</h3>
<p>答：</p>
<ul>
<li><strong>连接建立</strong>：<code>TCP</code> 建立连接的时候，需要三次握手，这个过程可以证明双方都具有发送和接收的能力，并且能避免历史连接的建立</li>
<li><strong>序列号与确认应答</strong>：<code>TCP</code> 头部有序列字段，可以保证数据的有序性，还有确认号，用来确认收到了数据</li>
<li><strong>数据包重传</strong>：如果发送方发送的数据，长时间没有收到确认报文，就会触发超时重传，重传丢失的报文</li>
<li><strong>滑动窗口机制</strong>：<code>TCP</code> 有流量控制的机制，发送方会根据接收方的接收窗口来发送数据报文，可以避免发送方发送的数据报文太大，导致接收方接收不了而丢包的问题</li>
<li><strong>拥塞控制</strong>：<code>TCP</code> 有拥塞控制的机制， 通过慢启动、拥塞避免、拥塞发生，快速重传和快速恢复等算法调整发送速率来避免网络拥塞。当网络出现拥塞时，<code>TCP</code> 会降低发送速率，以减少网络负载，保证数据的可靠传输</li>
</ul>
<p><strong>补充</strong>：</p>
<p>从 连接建立、序列号与确认应答、数据包重传、滑动窗口机制、拥塞控制 方面回答</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding</a></p>
<hr>
<h3 id="TCP-流量控制和拥塞控制的区别？"><a class="headerlink" href="#TCP-流量控制和拥塞控制的区别？"></a>TCP 流量控制和拥塞控制的区别？</h3>
<p>答：</p>
<p>这两个机制都是 <code>TCP</code> 协议实现可靠传输的因素，主要区别在于：</p>
<ul>
<li><strong>流量控制</strong>：这是一个<strong>端到端的控制机制</strong>，目的是防止发送方发送的数据过快，导致接收方处理不过来。这通过滑动窗口机制实现，接收方在 <code>ACK</code> 报文中告诉发送方自己的接收窗口大小，这样就告诉了发送方可以接收的最大数据量</li>
<li><strong>拥塞控制</strong>：这是一个<strong>网络层面的控制机制</strong>，目的是防止过多的数据包同时在网络中传输，导致网络拥塞，主要是通过慢启动、拥塞避免、拥塞发生，快速重传和快速恢复，这几种算法实现的</li>
</ul>
<p>所以，流量控制关注的是保护接收方不被淹没，而拥塞控制关注的是保护网络不被过载</p>
<hr>
<h3 id="滑动窗口怎么设计的？解决什么问题？"><a class="headerlink" href="#滑动窗口怎么设计的？解决什么问题？"></a>滑动窗口怎么设计的？解决什么问题？</h3>
<p>答：</p>
<p><strong>发送方和接收方在内核各自都有一个缓冲区</strong>，发送缓冲区和接收缓冲区上都各有一个窗口，<strong>发送方的窗口表示可发送的最大数据量，接收方的窗口表示可接收的最大数据量</strong>：</p>
<ul>
<li>发送方有了发送窗口后，那么发送方可以不用等待已发送数据的确认报文，就可以继续发送下一批数据，提高了发送的速率</li>
<li>接收方有了接收窗口后，可以实现流量控制，把接收方的接收窗口告诉给发送方，让发送方按自己的接收情况来发送数据，避免发送方发送的数据过快，导致接收方处理不过来</li>
</ul>
<hr>
<h3 id="TCP-协议拥塞控制怎么实现的？"><a class="headerlink" href="#TCP-协议拥塞控制怎么实现的？"></a>TCP 协议拥塞控制怎么实现的？</h3>
<p>答：</p>
<ul>
<li><code>TCP</code>协议的拥塞控制主要通过五个算法来实现：<strong>慢启动、拥塞避免、超时重传、快速重传 和 快速恢复</strong>
<ul>
<li><strong>慢启动</strong>：发送方开始时<strong>设置一个较小的拥塞窗口大小</strong>，在每收到一个对新的报文段的确认后，每当成功发送跟拥塞窗口大小等量的数据后，拥塞窗口大小就会翻倍，以指数方式增长，直到拥塞控制窗口达到慢启动门限</li>
<li><strong>拥塞避免</strong>：当窗口大小达到慢启动门限后，就进入拥塞避免阶段，每当成功发送跟拥塞窗口大小等量的数据后，拥塞窗口大小就会增加一个报文段的大小，以线性方式增长</li>
<li><strong>拥塞发生</strong>：随着发送速率慢慢增长，可能网络会出现拥塞，发生了数据包丢失，这时候就需要重传数据重传机制主要有两种，一个是超时重传和快速重传</li>
<li><strong>超时重传</strong>：当发生了超时重传，慢启动门限会设置为拥塞窗口的一半，并且将拥塞窗口恢复为初始值，接着就重新开始慢启动，发送速率就会瞬间下降了很多</li>
<li><strong>快速重传和快速恢复</strong>：当发送方连续收到三个重复确认时，就认为发生了丢包，这时候拥塞窗口会减少到原来的一半，然后慢启动门限设置为减少后的拥塞窗口大小，然后进入到快速恢复阶段，这时候会把拥塞控制窗口+3，3 的意思是确认有 3 个数据包被收到了，然后重传丢失的报文，如果收到重传丢失报文的 <code>ACK</code> 后，将拥塞窗口设置为慢启动门限，这样就直接进入拥塞避免，继续增大发送速率</li>
</ul>
</li>
<li>这些拥塞控制算法，可以让 <code>TCP</code> 协议能够根据网络状况动态调整发送速率，避免因为过大的流量导致网络拥赛</li>
</ul>
<p><strong>补充</strong>：</p>
<p>慢启动 → 拥塞避免 → 超时重传 → 慢启动：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103170048663.png" alt="慢启动 → 拥塞避免 → 超时重传 → 慢启动" loading="lazy"></p>
<p>慢启动 → 拥塞避免 → 快速重传 → 快速恢复 → 拥塞避免：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103170155815.png" alt="慢启动 → 拥塞避免 → 快速重传 → 快速恢复 → 拥塞避免" loading="lazy"></p>
<hr>
<h3 id="TCP-的延迟应答和累计应答是什么？"><a class="headerlink" href="#TCP-的延迟应答和累计应答是什么？"></a>TCP 的延迟应答和累计应答是什么？</h3>
<p>答：</p>
<ul>
<li><strong><code>TCP</code> 的延迟应答</strong> 是指接收方不立即发送 <code>ACK</code>确认接收到的数据，而是延迟一段时间后再发送 <code>ACK</code>。这样可以等待是否有更多的数据要发送，从而减少 <code>ACK</code> 报文的数量，提高网络利用率</li>
<li><strong><code>TCP</code> 的累计应答</strong> 是指接收方可以一次性确认接收到多个连续的数据包，而不是每收到一个数据包就发送一个 <code>ACK</code>。这样可以减少 <code>ACK</code> 报文的数量，提高网络效率</li>
</ul>
<p><strong>补充</strong>：</p>
<p><strong>延迟应答</strong>：<code>TCP</code> 在接收到对端的报文后并不会立即发送 <code>ACK</code>，而是等待一段时间发送 <code>ACK</code>，以便将 <code>ACK</code> 和要发送的数据一块发送，好处是能减少 <code>ACK</code> 报文的数量，提高网络利用率。延迟时间不能无限延长，否则对方端会认为丢包超时而造成超时重传。<code>Linux</code> 采用动态调节算法来确定等待的时间。延迟应答如下图：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103170529587.png" alt="TCP延迟应答" loading="lazy"></p>
<p><strong>累计应答</strong>：接收方可以一次性确认接收到多个连续的数据包，而不是每收到一个数据包就发送一个 <code>ACK</code>。这样可以减少 <code>ACK</code> 报文的数量，提高网络效率。累计应答如下图：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103170635627.png" alt="TCP累计应答" loading="lazy"></p>
<hr>
<h2 id="TCP-场景问题"><a class="headerlink" href="#TCP-场景问题"></a>TCP 场景问题</h2>
<hr>
<h3 id="TCP-拆包沾包原因是什么？怎么解决？"><a class="headerlink" href="#TCP-拆包沾包原因是什么？怎么解决？"></a>TCP 拆包沾包原因是什么？怎么解决？</h3>
<p>答：</p>
<ul>
<li>我的理解 <code>TCP</code> 是一个<strong>面向字节流</strong>协议，并不关心数据包的边界
<ul>
<li>如果发送的数据包超过 <code>MSS</code> 大小或者接收窗口大小后，会被拆分多个 <code>TCP</code> 段发送，这时候站在应用层的角度，就是一个完整的数据包被拆开了</li>
<li>如果发送的数据包太小，<code>TCP</code> 还有一个 <code>Nagle</code> 算法，会把多个小数据包堆积成一个 <code>TCP</code> 段发送，这时候就会感觉数据包是粘合一起发送的</li>
</ul>
</li>
<li>其实我认为，<code>TCP</code> 拆包沾包并不是 <code>TCP</code> 的问题，只是因为 <code>TCP</code> 的特性，才出现的现象，所以要解决拆包和沾包，主要是在应用层进行处理的，比方说有这些解决方案：
<ul>
<li><strong>固定消息长度的方式</strong>，每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用</li>
<li><strong>特定分隔符的方式</strong>，可以在每次发送报文的尾部加上特定分隔符，接收方就可以根据特殊分隔符进行消息拆分。比方说，<code>HTTP</code> 请求报文就是通过空白行的方式，分隔了请求头和请求体。这种方案需要注意的是分隔符的选择一定要避免和消息体中字符相同，以免冲突</li>
<li><strong>消息长度 + 消息内容的方式</strong>，消息头中存放消息的总长度，例如：使用 4 字节的 <code>int</code> 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 <code>Len</code>，然后紧接着读取长度为 <code>Len</code> 的字节数据，该数据即判定为一个完整的数据报文，这个方案项目开发中最常用的一种方法，因为使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如：消息版本、算法类型等</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：[06 粘包拆包问题：如何获取一个完整的网络包？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty">https://learn.lianglianglee.com/专栏/Netty</a> 核心原理剖析与 RPC 实践-完/06  粘包拆包问题：如何获取一个完整的网络包？.md)</p>
<hr>
<h3 id="TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？"><a class="headerlink" href="#TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？"></a>TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 的 <code>Keep-Alive</code> 是叫 <code>HTTP</code> 长连接，该功能是由应用程序实现的，可以使得用同一个 <code>TCP</code> 连接来发送和接收多个 <code>HTTP</code> 请求和应答，减少了 <code>HTTP</code> 短连接带来的多次 <code>TCP</code> 连接建立和释放的开销</li>
<li><code>TCP</code> 的 <code>Keepalive</code> 是叫 <code>TCP</code> 保活机制，该功能是由内核实现的，当客户端和服务端双方长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会<strong>发送探测报文</strong>，来检测对方是否还在线，然后来决定是否要关闭该连接</li>
</ul>
<p><strong>补充</strong>：</p>
<p>实现的层面不同：</p>
<ul>
<li><code>HTTP</code> 的 <code>Keep-Alive</code>，是由应用层（用户态）实现的，称为 <code>HTTP</code> 长连接</li>
<li><code>TCP</code> 的 <code>Keepalive</code>，是由 <code>TCP</code> 层（内核态）实现的，称为 <code>TCP</code> 保活机制</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html#http-%E7%9A%84-keep-alive">4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding</a></p>
<hr>
<h3 id="MTU是啥？MSS是啥？"><a class="headerlink" href="#MTU是啥？MSS是啥？"></a>MTU是啥？MSS是啥？</h3>
<p>答：</p>
<p><code>MTU</code> 是一个网络包的最大长度，一般是 1500 字节，<code>MSS</code> 是除去 <code>IP</code> 包和 <code>TCP</code> 包的数据的最大长度，<code>IP</code> 层如果超过 <code>MTU</code> 大小就会分片，<code>TCP</code> 如果有超过 <code>MSS</code>的应用数据就要分段</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103171903334.png" alt="MTU vs MSS" loading="lazy"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 1500 字节。当 <code>IP</code> 层有一个超过 <code>MTU</code> 大小的数据要发送，那么 <code>IP</code> 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 <code>MTU</code></li>
<li><code>MSS</code>：除去 <code>IP</code> 和 <code>TCP</code> 头部之后，一个网络包所能容纳的 <code>TCP</code> 数据的最大长度。当 <code>TCP</code> 层有一个超过<code>MSS</code> 大小的应用数据，那么 <code>TCP</code> 层就要针对应用层数据进行分片，把数据分片成若干片，保证每一个分片都小于 <code>MSS</code></li>
</ul>
<hr>
<h3 id="IP层会分片，为什么TCP层还需要MSS呢？"><a class="headerlink" href="#IP层会分片，为什么TCP层还需要MSS呢？"></a>IP层会分片，为什么TCP层还需要MSS呢？</h3>
<p>答：</p>
<ul>
<li>如果交给 <code>IP</code> 来进行分片，如果某一个 <code>IP</code> 分片丢失了，整个 <code>IP</code> 报文的所有分片都得重传。因为 <code>IP</code> 层本身没有超时重传机制，它由传输层的 <code>TCP</code> 来负责超时和重传</li>
<li>当某一个 <code>IP</code> 分片丢失后，接收方的 <code>IP</code> 层就无法组装成一个完整的 <code>TCP</code> 报文（头部 + 数据），也就无法将数据报文送到 <code>TCP</code> 层，所以接收方不会响应 <code>ACK</code> 给发送方，因为发送方迟迟收不到 <code>ACK</code> 确认报文，所以会触发超时重传，就会重发整个 <code>TCP</code> 报文（头部 +数据）</li>
<li>应用层的数据在 <code>TCP</code> 层经过 <code>MSS</code> 分片之后，每一个分片都具备 <code>TCP</code> 头部信息，这样经过 <code>MSS</code> 分片后的报文，如果某一个丢失了，只需要重传这一个丢失的 <code>TCP</code> 报文就可以了，而不用重传所有的分片，大大增加了重传的效率</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>当 <code>IP</code> 层有一个超过 <code>MTU</code> 大小的数据（<code>IP</code>头部 + <code>TCP</code> 头部 + <code>TCP</code> 数据）要发送，那么 <code>IP</code> 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 <code>MTU</code>。把一份 <code>IP</code> 数据报进行分片以后，由目标主机的 <code>IP</code> 层来进行重新组装后，再交给上一层 <code>TCP</code> 传输层</li>
<li>这看起来井然有序，但这存在隐患的，那么当如果一个 <code>IP</code> 分片丢失，整个 <code>IP</code> 报文的所有分片都得重传，<strong>因为 <code>IP</code> 层本身没有超时重传机制，它由传输层的 <code>TCP</code> 来负责超时和重传</strong>。当某一个 <code>IP</code> 分片丢失后，接收方的 <code>IP</code> 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 <code>TCP</code> 层，所以接收方不会响应 <code>ACK</code> 给发送方，因为发送方迟迟收不到 <code>ACK</code> 确认报文，所以会触发超时重传，就会重发「整个 <code>TCP</code> 报文（头部 +数据）」</li>
<li>因此，可以得知由 <code>IP</code> 层进行分片传输，是非常没有效率的所以，为了达到最佳的传输效能 <code>TCP</code> 协议在建立连接的时候通常要协商双方的 <code>MSS</code> 值，当 <code>TCP</code> 层发现数据超过 <code>MSS</code> 时，则就先会进行分片，当然由它形成的 <code>IP</code> 包的长度也就不会大于 <code>MTU</code> ，自然也就不用 <code>IP</code> 分片了</li>
<li>经过 <code>TCP</code> 层分片后，如果一个 <code>TCP</code> 分片丢失后，进行重发时也是以 <code>MSS</code> 为单位，而不用重传所有的分片，大大增加了重传的效率</li>
</ul>
<hr>
<h3 id="一个服务端进程最多可以建立多少条-TCP-连接？"><a class="headerlink" href="#一个服务端进程最多可以建立多少条-TCP-连接？"></a>一个服务端进程最多可以建立多少条 TCP 连接？</h3>
<p>答：</p>
<ul>
<li>一条 <code>TCP</code> 连接是通过 <strong>源<code>IP</code>地址、目的<code>IP</code>地址、源端口、目的端口</strong> 这四个信息唯一确定的。服务端进程通常是会固定监听一个端口，等待客户端的连接请求，现在假设服务端的 <code>IP</code> 地址和 端口号 都是不变，那么 <strong>一个服务端进程最大能支持的理论连接数 等于 客户端的 <code>IP</code> 数量 * 客户端的端口数量</strong>，也就是 2 的 48 次方个连接数量</li>
<li>这个只是一个理论值，实际上服务端还会受系统资源的限制，比如：文件描述符的最大数量、CPU和内存资源</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>TCP</code> 是通过 四元组 唯一确认一条 <code>TCP</code> 连接的</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103180651534.png" alt="TCP四元组" loading="lazy"></p>
</li>
<li>
<p>源 <code>IP</code> 地址和目的 <code>IP</code> 地址的字段（32 位）是在 <code>IP</code> 头部中，作用是定位网络中的主机。源端口和目的端口的字段（16 位）是在 <code>TCP</code> 头部中，作用是告诉 <code>TCP</code> 协议应该把报文发给哪个进程。服务端通常固定在某个本地端口上监听，等待客户端的连接请求。比如：我网站的服务端是 <code>nginx</code>，监听了 <code>80</code> 端口</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103180847471.png" alt="我网站的服务端是 nginx，监听了 `80` 端口" loading="lazy"></p>
</li>
<li>
<p>那么假设服务端的 <code>IP</code> 地址和端口号不变，客户端 <code>IP</code> 和端口是可变的,一个服务端进程最大能支持的理论连接数：*<em>一个服务端进程最大能支持的理论连接数 = 客户端的 IP 数量 <em>客户端的端口数量</em></em></p>
</li>
<li>
<p>对 IPv4，客户端的 <code>IP</code> 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是一个服务端进程最大能支持的理论连接数为 2 的 48 次方</p>
</li>
<li>
<p>实际上服务端最大并发 <code>TCP</code> 连接数远不能达到理论上限，会受以下因素影响：</p>
</li>
<li>
<p>文件描述符限制，每个 <code>TCP</code> 连接都是一个文件，如果文件描述符被占满了，会发生 <code>Too many open files</code>。<code>Linux</code> 对可打开的文件描述符的数量分别作了三个方面的限制：</p>
<ul>
<li>系统级：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看</li>
<li>用户级：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看</li>
<li>进程级：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看</li>
</ul>
</li>
<li>
<p>内存限制，每个 <code>TCP</code> 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 <code>OOM</code></p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/l9ggXLAEHp4LTjd2Qsyqtg">腾讯三面：一台服务器，最大支持的TCP连接数是多少？</a></p>
<hr>
<h3 id="一个机器最多可以建立多少条-TCP-连接？"><a class="headerlink" href="#一个机器最多可以建立多少条-TCP-连接？"></a>一个机器最多可以建立多少条 TCP 连接？</h3>
<p>答：</p>
<ul>
<li>一条 <code>TCP</code> 连接是由四元组组成的，服务器设备上可以有多个进程监听多个端口，然后如果服务器所有端口都被用来监听的话，<strong>理论上最大可以建立的 <code>TCP</code> 连接数 等于 客户端 <code>IP</code>数 x 客户端端口数 x 服务端端口数，也就是 <code>2^32 x 2^16 x 2^16</code></strong></li>
<li>上面这个只是理论值，实际中由于服务器硬件资源的限制是无法达到的，比如：内存资源的限制，我之前了解到每一条静止的 <code>TCP</code> 连接内存占用大概 <code>3.3K</code>，如果服务器的物理内存是 <code>4G</code>，那么最大只能建立 100 万左右（<code>4GB/3.3KB</code>）的连接了</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484207&amp;idx=1&amp;sn=50ae06628062bcdd5b2aff044f34fa80&amp;scene=21#wechat_redirect">漫画 | 一台Linux服务器最多能支撑多少个TCP连接？</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343607982">漫画 | 花了七天时间测试，我彻底搞明白了 TCP 的这些内存开销! - 知乎</a></p>
<hr>
<h3 id="如果已经建立了连接，但是服务端突然出现断电了会发生什么？"><a class="headerlink" href="#如果已经建立了连接，但是服务端突然出现断电了会发生什么？"></a>如果已经建立了连接，但是服务端突然出现断电了会发生什么？</h3>
<p>答：</p>
<p>服务端突然断电的后：</p>
<ul>
<li>如果客户端接下来会发送数据，那么由于服务端断电了，客户端已发送的数据就没办法得到确认，于是就会<strong>发生超时重传，重传次数达到上限之后，客户端就会断开 <code>TCP</code> 连接了</strong></li>
<li>如果客户端接下来不会再发送数据，那么要<strong>看客户端有没有开启 <code>TCP</code> 保活机制</strong>：
<ul>
<li>如果没有开启的话，客户端的 <code>TCP</code> 状态将一直保持不变</li>
<li>如果有开启了 <code>TCP</code> 保活机制，双方超过一段时间没有进行数据交互的话，内核就会触发 <code>TCP</code> 保活机制，定时发送探测报文，因为服务端断电了，客户端发送的探测报文，都不会得到响应，那么探测次数达到上限，还未收到响应的话，客户端就会断开 <code>TCP</code> 连接了</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>分情况讨论：</p>
<ul>
<li>客户端会发送数据的情况</li>
<li>客户端不会发送数据的情况
<ul>
<li>客户端没有开启 <code>TCP</code> 保活机制的情况</li>
<li>客户端有开启 <code>TCP</code> 保活机制的情况</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83">4.12 TCP 连接，一端断电和进程崩溃有什么区别？ | 小林coding</a></p>
<hr>
<h3 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a class="headerlink" href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3>
<p>答：</p>
<p>服务端进程崩溃的话，内核会负责回收服务端进程的资源，会发送 <code>FIN</code> 报文，和客户端进行四次挥手断开连接</p>
<p><strong>补充</strong>：</p>
<p><code>TCP</code> 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 <code>TCP</code> 连接资源,于是内核会发送第一次挥手 <code>FIN</code> 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 <code>TCP</code> 四次挥手的过程</p>
<hr>
<h3 id="TCP-中-SYN-洪水是什么？如何防止？"><a class="headerlink" href="#TCP-中-SYN-洪水是什么？如何防止？"></a>TCP 中 SYN 洪水是什么？如何防止？</h3>
<p>答：</p>
<ul>
<li><code>SYN</code> 洪水攻击就是攻击者伪造大量不同 <code>IP</code> 地址的 <code>SYN</code> 报文发送给服务端，服务端每收到 <code>SYN</code> 报文后，会把还没完成连接建立的 <code>socket</code>，存放在 <code>tcp</code> 半连接队列，然后响应 <code>syn-ack</code> 报文，但是这些 <code>IP</code> 地址都是不存在的，这样服务端就无法收到第三次握手，这样就会导致 <code>tcp</code> 半连接队列被占满了，占满后，服务端就无法再建立 <code>tcp</code> 连接了，不能给正常的用户提供服务了</li>
<li>解决的方式，我觉得最好的是<strong>开启 <code>tcp</code> 的 <code>syn_cookie</code> 机制</strong>，它可以在服务端第二次握手的时候，生成一个伪随机的序列号，用于验证客户端的 <code>SYN</code> 包。只有在客户端回应服务器的 <code>ACK</code> 包时，服务器才会分配资源，所以可以在不使用 <code>SYN</code> 半连接队列的情况下成功建立连接，相当于绕过了 <code>SYN</code> 半连接来建立连接。其次的话，可以通过<strong>调整内核参数来增大半连接队列的大小，以及减少 <code>syn+ack</code> 重传的次数来避免 <code>SYN</code> 洪水攻击</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>TCP</code> 连接建立是需要三次握手，假设攻击者短时间伪造不同 <code>IP</code> 地址的 <code>SYN</code> 报文，服务端每接收到一个报文，就进入 <code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 <code>IP</code> 主机的 <code>ACK</code> 应答，久而久之就会占满服务端的 <code>TCP</code> 半连接队列，使得服务端不能为正常用户服务</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103182411065.png" alt="SYN洪水" loading="lazy"></p>
<p>解决方式：</p>
<ul>
<li><strong>开启 <code>tcp_syncookies</code> 功能</strong>，开启 <code>syncookies</code> 功能就可以在不使用 <code>SYN</code> 半连接队列的情况下成功建立连接，相当于绕过了 <code>SYN</code> 半连接来建立连接</li>
<li><strong>增大半连接队列</strong>，通过增大 <code>net.ipv4.tcp_max_syn_backlog</code>，增大 <code>listen()</code> 函数中的 <code>backlog</code>，增大<code>net.core.somaxconn</code>，这三个参数来增大半连接队列</li>
<li><strong>通过减少 <code>tcp_synack _retries</code> 参数来减少 <code>SYN+ACK</code> 重传次数</strong>，当服务端受到 <code>SYN</code> 攻击时，就会有大量处于 <code>SYN_RECV</code> 状态的 <code>TCP</code> 连接，处于这个状态的 <code>TCP</code> 会重传 <code>SYN+ACK</code>，当重传超过次数达到上限后，就会断开连接。那么针对 <code>SYN</code> 攻击的场景，我们可以减少 <code>SYN+ACK</code> 的重传次数，以加快处于 <code>SYN_RECV</code> 状态的 <code>TCP</code> 连接断开</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/">SYN 洪水 DDoS 攻击 | Cloudflare</a></p>
<hr>
<h2 id="网络层"><a class="headerlink" href="#网络层"></a>网络层</h2>
<hr>
<h3 id="ping-的工作原理说一下？"><a class="headerlink" href="#ping-的工作原理说一下？"></a>ping 的工作原理说一下？</h3>
<p>答：</p>
<p><code>ping</code> 是通过 <code>ICMP</code> 协议来实现的，<code>ping</code> 的时候，会发送类型为回送请求的 <code>ICMP</code> 报文，对方接收到之后，就会回复类型为回送应答的 <code>ICMP</code> 报文</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103183603800.png" alt="ping一下会发生什么？" loading="lazy"></p>
<p><code>ping</code> 命令是用来探测目标 <code>ip</code> 地址是否可以访问：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250103183202673.png" alt="ping命令" loading="lazy"></p>
<ul>
<li><code>ping</code> 命令执行的时候，源主机首先会构建一个 <code>ICMP</code> 回送请求消息数据包，由 <code>ICMP</code> 协议将这个数据包连同服务端 <code>IP</code> 一起交给 <code>IP</code> 层，<code>IP</code> 层将以服务端 <code>IP</code> 作为目的地址，本机 <code>IP</code> 地址作为源地址，协议字段设置为 1，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包；然后加入<code>MAC</code>头；如果在本地 <code>ARP</code> 映射表中查找出服务端 <code>IP</code> 所对应的 <code>MAC</code> 地址，则可以直接使用，如果没有，则需要发送 <code>ARP</code> 协议查询 <code>MAC</code> 地址。获得 <code>MAC</code> 地址后，由数据链路层构建一个数据帧，目的地址是 <code>IP</code> 层传过来的 <code>MAC</code> 地址，源地址则是本机的 <code>MAC</code> 地址；还要附加上一些控制信息，依据以太网的介质访问规则将它们传送出去</li>
<li>目的收到这个数据帧后，先检查它的目的 <code>MAC</code> 地址，并和本机的 <code>MAC</code> 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 <code>IP</code> 数据包从帧中提取出来，交给本机的 <code>IP</code> 层。<code>IP</code> 层检查后，将有用的信息提取后交给 <code>ICMP</code> 协议。主机 B 会构建一个 <code>ICMP</code> 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给主机A</li>
<li>在规定的时间内，源主机如果没有接到 <code>ICMP</code> 的应答包，则说明目标主机不可达；如果接收到了 <code>ICMP</code> 回送响应消息，则说明目标主机可达</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/4_ip/ping.html">5.2 ping 的工作原理 | 小林coding</a></p>
<hr>
<h3 id="交换机和路由器有什么区别？"><a class="headerlink" href="#交换机和路由器有什么区别？"></a>交换机和路由器有什么区别？</h3>
<p>答：</p>
<ul>
<li>交换机工作在 <code>MAC</code> 层，称为二层网络设备，主要处理数据帧的转发和交换，交换机会根据 <code>MAC</code> 地址来转发数据包，实现局域网内设备之间的通信</li>
<li>路由器工作在 <code>IP</code> 层，称为三层网络设备，主要负责 <code>IP</code> 数据包的转发和路由选择，路由器会根据 <code>IP</code> 地址来转发数据包，实现不同网络之间的通信</li>
</ul>
<p><strong>补充</strong>：</p>
<ol>
<li>网络层级不一样</li>
<li>功能不一样</li>
</ol>
<hr>
<h3 id="什么是-IP-地址？"><a class="headerlink" href="#什么是-IP-地址？"></a>什么是 IP 地址？</h3>
<p>答：</p>
<p><code>IP</code> 地址是用于在计算机网络上唯一标识和定位网络中的设备，<code>IP</code> 地址允许计算机在网络上相互通信和交换数据，在 <code>TCP/IP</code> 协议中，<code>IP</code> 地址与 <code>MAC</code> 地址结合使用，实现了设备之间的通信和数据传输</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>IP</code> 地址是用于在网络中唯一标识和定位设备的一种地址，<code>IP</code> 地址是网络层协议中使用的一种地址，它分为<code>IPv4</code>地址和<code>IPv6</code>地址两种类型
<ol>
<li><code>IPv4</code>地址：<code>IPv4</code>地址是 32 位的二进制地址，通常用点分十进制表示，如：<code>192.168.1.1</code>。<code>IPv4</code>地址由四个8位字节组成，每个字节范围从0到255之间，共计可表示约42亿个不同的地址。然而，由于<code>IPv4</code>地址资源有限，目前已经出现了地址枯竭的问题</li>
<li><code>IPv6</code>地址：为了解决<code>IPv4</code>地址资源枯竭的问题，<code>IPv6</code>地址被引入并取代了<code>IPv4</code>地址。<code>IPv6</code>地址是 128 位的地址，采用冒号分隔的八组十六进制数表示，如：<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>。<code>IPv6</code> 地址提供了极其庞大的地址空间，理论上可以支持几乎无限数量的设备连接到互联网</li>
</ol>
</li>
<li><code>IP</code>地址的作用是在互联网上唯一标识一个设备或主机，使得数据包能够准确地被发送到目的地。在<code>TCP/IP</code> 协议中，<code>IP</code> 地址与 <code>MAC</code> 地址结合使用，实现了设备之间的通信和数据传输</li>
</ul>
<hr>
<h3 id="什么是-mac-地址？"><a class="headerlink" href="#什么是-mac-地址？"></a>什么是 mac 地址？</h3>
<p>答：</p>
<p><code>MAC</code> 地址是在数据链路层中使用的标识符，只在局域网范围内有效。在互联网通信中，数据包最终是通过 <code>IP</code> 地址来路由和传递的，而在局域网中则是通过 <code>MAC</code> 地址来实现设备之间的直接通信。<code>MAC</code> 地址与 <code>IP</code> 地址结合起来，共同协助实现了数据在网络中的正确传输和交换</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>MAC</code> 地址是网络设备在数据链路层中使用的物理地址，用于唯一标识网络设备。每个网络设备都有一个唯一的 <code>MAC</code> 地址，通常由 48 位二进制数表示，分为 6 个十六进制数对，用冒号或短线分隔，如：<code>00:1A:2B:3C:4D:5E</code></li>
<li><code>MAC</code> 地址主要用于通过局域网传输数据时，帮助网络设备进行识别和寻址。与 <code>IP</code> 地址不同，<code>MAC</code> 地址是固定的且与硬件设备绑定，不会因为设备连接到不同网络而改变。当数据包在局域网内传输时，源设备将目标设备的 <code>MAC</code> 地址作为目标地址写入数据包头部，以确保数据包能够准确地从发送者传输到接收者</li>
<li>需要注意的是，<code>MAC</code> 地址是在数据链路层中使用的标识符，只在局域网范围内有效。在互联网通信中，数据包最终是通过 <code>IP</code> 地址来路由和传递的，而在局域网中则是通过 <code>MAC</code> 地址来实现设备之间的直接通信。<code>MAC</code> 地址与 <code>IP</code> 地址结合起来，共同协助实现了数据在网络中的正确传输和交换</li>
</ul>
<hr>
<h3 id="IP地址和MAC地址有什么区别？"><a class="headerlink" href="#IP地址和MAC地址有什么区别？"></a>IP地址和MAC地址有什么区别？</h3>
<p>答：</p>
<ul>
<li><code>IP</code> 地址用于在 网络中 唯一标识和定位设备，它是在网络层使用的地址，用于实现不同网络之间的通信</li>
<li><code>MAC</code> 地址用于在 局域网中 唯一标识和定位设备，它是在数据链路层使用的地址，用于实现局域网内设备之间的通信</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http">2.2 键入网址到网页显示，期间发生了什么？ | 小林coding</a>、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb/?p=33&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0">3.7 MAC地址、IP地址以及ARP协议（1） — MAC地址_哔哩哔哩_bilibili</a></p>
<hr>
<h3 id="为什么有了IP地址，还需要MAC地址？"><a class="headerlink" href="#为什么有了IP地址，还需要MAC地址？"></a>为什么有了IP地址，还需要MAC地址？</h3>
<p>答：</p>
<ul>
<li>只有 <code>MAC</code>，没有 <code>IP</code>，网卡的实现上极其困难。如果只使用 <code>MAC</code> 地址的话，路由器就需要记住每个 <code>MAC</code> 地址所在的子网是哪一个，而世界上有 2 的 48 次方个 <code>MAC</code> 地址，这就意味着即使我们给每个 <code>MAC</code> 地址只留 1 字节的储存空间，每个路由器也需要 256 TB 的内存，这显然是不可能实现的</li>
<li>只有 <code>IP</code>，没有 <code>MAC</code>，<code>IP</code> 地址的局限。<code>IP</code> 地址是要设备上线以后，才能根据他进入了哪个子网来分配的，在设备还没有 <code>IP</code> 地址的时候（或者分配 <code>IP</code> 地址的过程中），还需要用 <code>MAC</code> 地址来区分不同的设备，并根据 <code>MAC</code> 地址通信</li>
</ul>
<p><strong>补充</strong>：</p>
<p>可以从只有 <code>mac</code> 没有 <code>ip</code> 会有什么问题，只有 <code>ip</code> 没有 <code>mac</code> 会有什么问题来回答</p>
<hr>
<h3 id="NAT是什么协议？"><a class="headerlink" href="#NAT是什么协议？"></a>NAT是什么协议？</h3>
<p>答：</p>
<ul>
<li><code>NAT</code> 协议在网络层工作，会将私有 <code>IP</code> 地址转换为公网 <code>IP</code> 地址，这样可以实现局域网的设备与互联网其他设备的通信</li>
<li><code>NAT</code> 协议比较常见的转换操作是端口转换，多个私有 <code>IP</code> 地址可以共享一个公网 <code>IP</code> 地址，通过端口来区分不同的私有 <code>IP</code> 地址。所以，<code>NAT</code> 协议的优势在于可以节省公共 <code>IP</code> 地址资源，因为多个内部设备可以共享同一个公共 <code>IP</code> 地址</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>图中有两个客户端 <code>192.168.1.10</code> 和 <code>192.168.1.11</code> 同时与服务器 <code>183.232.231.172</code> 进行通信，并且这两个客户端的本地端口都是 <code>1025</code></li>
<li>此时，两个私有 <code>IP</code> 地址都转换 <code>IP</code> 地址为公有地址 <code>120.229.175.121</code>，但是以不同的端口号作为区分。于是，生成一个 <code>NAPT</code> 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 <code>A</code>、<code>B</code> 能同时与服务器之间进行通信</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104143001749.png" alt="NAT地址转换" loading="lazy"></p>
<hr>
<h3 id="192-168-1-100-24-中的斜杠代表什么意思？"><a class="headerlink" href="#192-168-1-100-24-中的斜杠代表什么意思？"></a>192.168.1.100/24 中的斜杠代表什么意思？</h3>
<p>答：</p>
<ul>
<li>斜杠（<code>/</code>）后面的数字表示子网掩码的位数
<ul>
<li>比如：<code>192.168.1.100/24</code> 中的斜杠后面的数字 <code>24</code> 表示子网掩码的位数，子网掩码用于划分 <code>IP</code> 地址中的网络部分和主机部分。将子网掩码和 <code>IP</code> 地址进行 <strong>与</strong> 运算，就可以得到网络号</li>
<li>具体来说，<code>192.168.1.100/24</code> 表示前 24 位是网络部分，后 8 位是主机部分</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>主要关注网络号和主机号的概念，</p>
</li>
<li>
<p><code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于网络号，x 的范围是 0 ~ 32 比如：<code>10.100.122.2/24</code>，这种地址表示形式就是 <code>CIDR</code>，<code>/24</code> 表示前 <code>24</code> 位是网络号，剩余的 <code>8</code> 位是主机号</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104143607878.png" alt="10.100.122.2/24" loading="lazy"></p>
<ul>
<li>
<p>还有另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号</p>
</li>
<li>
<p>将子网掩码和 <code>IP</code> 地址按位计算 <code>AND</code>，就可得到网络号</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104143747336.png" alt="将子网掩码和IP地址按位计算AND" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="网络攻击问题"><a class="headerlink" href="#网络攻击问题"></a>网络攻击问题</h2>
<hr>
<h3 id="DNS-劫持是什么？"><a class="headerlink" href="#DNS-劫持是什么？"></a>DNS 劫持是什么？</h3>
<p>答：</p>
<p>当我们访问网站的时候， 实际上是会先进行域名解析得到网站服务器的 <code>IP</code> 地址，然后才进行后续的访问。<code>DNS</code> 劫持利用了这个过程中的漏洞，攻击者在 <code>DNS</code> 服务器上篡改 <code>DNS</code> 解析结果，将域名解析到攻击者控制的恶意服务器上，这时候我们访问的域名就被重定向到恶意网站上</p>
<p><strong>补充</strong>：</p>
<p><code>DNS</code> 劫持就是黑客劫持了 <code>DNS</code> 服务器，篡改了 <code>DNS</code> 解析结果，将 <code>client</code> 请求的域名解析到错误的 <code>IP</code> 地址上，让真实服务器拿不到请求，更多发生在诱导、钓鱼、广告植入、诈骗等诸多场景</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104144029110.png" alt="DNS劫持" loading="lazy"></p>
<ul>
<li>解决办法：手动更换公共 <code>DNS</code> 服务器，绕过被劫持的 <code>DNS</code> 服务器</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rp4y1a7xQ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0">【硬核科普】能上QQ但是打不开网页？详解DNS服务，DNS解析，DNS劫持和污染_哔哩哔哩_bilibili</a></p>
<hr>
<h3 id="DNS-污染是什么？"><a class="headerlink" href="#DNS-污染是什么？"></a>DNS 污染是什么？</h3>
<p>答：</p>
<p><code>DNS</code> 污染就是得到了一个虚假的结果，攻击者监听 <code>DNS</code> 查询，一旦发现查询的域名与自己是匹配的，就把自己伪装成目标域名服务器，然后返回虚假的结果给用户，这样用户域名解析的结果就是错误的，无法和正确的目标服务器 <code>IP</code> 进行通信</p>
<p><strong>补充</strong>：</p>
<p><code>DNS</code> 污染是一种让一般用户由于得到虚假目标主机 <code>IP</code> 而不能与其通信的方法，是一种 <code>DNS</code> 缓存投毒攻击（<code>DNS cache poisoning</code>）</p>
<ul>
<li>工作方式是：由于通常的 <code>DNS</code> 查询没有任何认证机制，而且 <code>DNS</code> 查询通常基于的 <code>UDP</code> 是 无连接不可靠 的协议，因此 <code>DNS</code> 的查询非常容易被篡改，通过对 <code>UDP</code> 端口 <code>53</code> 上的 <code>DNS</code> 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（<code>NS</code>，<code>Name Server</code>）给查询者 返回虚假结果</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104144416698.png" alt="DNS污染" loading="lazy"></p>
<ul>
<li><code>DNS</code> 污染症状：目前一些在被禁止访问的网站基本都是通过 <code>DNS</code> 污染来实现的，例如：<code>YouTube</code>、<code>facebook</code> 等网站</li>
<li>解决办法：
<ol>
<li>绕过被污染的非权威 <code>DNS</code> 服务器，直接访问干净的公共 <code>DNS</code> 服务器</li>
<li>在本机直接绑定 <code>hosts</code>，绕过 <code>DNS</code> 解析过程（但由于 <code>IP</code> 地址会变更，故本机的 <code>hosts</code> 也需要不断更新）</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c1abb7f641d">DNS污染和DNS劫持 - 简书</a></p>
<hr>
<h3 id="简述-DDOS-攻击原理，如何防范它？"><a class="headerlink" href="#简述-DDOS-攻击原理，如何防范它？"></a>简述 DDOS 攻击原理，如何防范它？</h3>
<p>答：</p>
<ul>
<li><code>DDOS</code> 攻击就是用大量的僵尸计算机对服务器发送大量的请求，让服务器的带宽、CPU和内存耗尽，让服务器超载后，无法再对外提供正常的服务</li>
<li><code>DDOS</code> 攻击大体分为网络层攻击和应用层攻击，攻击应用层的方式比如有：<code>DNS</code> 洪水攻击，攻击传输层的方式比如有：<code>SYN</code> 洪水攻击、<code>UDP</code> 洪水攻击。</li>
<li>我觉得可以通过这几个方面防御 <code>DDOS</code> 攻击：
<ol>
<li>限制单个 <code>IP</code> 地址的请求频率，并且对异常流量的 <code>IP</code> 地址，拉黑名单，配置防火墙规则，阻止恶意流量请求</li>
<li>增加用户验证机制，使用验证码、人脸识别等方式，增加用户验证的难度，减少恶意请求的影响</li>
<li>花钱买可靠的 <code>DDoS</code> 防护服务提供商，他们具备强大的网络基础设施和专业的防护技术，能够识别和过滤掉恶意流量，确保正常的服务运行</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KQ4y117nq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0">DDoS技术鉴赏_哔哩哔哩_bilibili</a></p>
<hr>
<h3 id="什么是-XSS-攻击？如何防止？"><a class="headerlink" href="#什么是-XSS-攻击？如何防止？"></a>什么是 XSS 攻击？如何防止？</h3>
<p>答：</p>
<ul>
<li><code>XSS</code> 攻击叫 跨站点脚本攻击， 攻击方式是攻击者在一些可以评论或者发帖的网站，发布一些恶意脚本代码，然后被服务端保存了，后面访问的网站的时候，浏览器会执行了该恶意脚本，这样攻击者就可以窃取用户的敏感信息了</li>
<li>要防止 <code>XSS</code> 攻击的话，可以通过这些方式：
<ol>
<li>输入验证和过滤：过滤一些特殊的字符，比如：<code>javascript</code> 脚本中的 <code>&lt;&gt;</code> 进行转移 <code>&lt;&gt;</code> 再进行存储，这样就能有效的进行 <code>xss</code> 攻击的预防</li>
<li>使用 <code>HTTP-only Cookie</code>：将敏感信息存储在 <code>HTTP-only Cookie</code> 中，限制 <code>JavaScript</code> 的访问权限，防止恶意脚本窃取用户的 <code>Cookie</code> 信息</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>存储型 <code>XSS</code> 攻击又称为持久性跨站点脚本攻击，通常攻击者将代码存储到漏洞服务器中，用户浏览相关页面发起攻击</li>
<li>攻击步骤：
<ol>
<li>攻击者将恶意脚本代码上传或存储到漏洞服务器</li>
<li>服务器把恶意脚本保存到服务器</li>
<li>当正常客户访问服务器时，服务器会读取恶意数据并且直接使用</li>
<li>服务器会返回含有恶意脚本的页面</li>
</ol>
</li>
<li>实际案例:
<ul>
<li>譬如发帖中发出包含恶意代码的内容，其他内容访问到该内容后，满足特定条件后条件即触发</li>
<li>需要后台不过滤信息，并且前端展示时也不过滤信息</li>
</ul>
</li>
<li>注意：这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://tsejx.github.io/javascript-guidebook/computer-networks/web-security/xss/">XSS 跨站脚本攻击 - JavaScript Guidebook</a></p>
<hr>
<h3 id="什么是-CSRF-攻击？如何防止？"><a class="headerlink" href="#什么是-CSRF-攻击？如何防止？"></a>什么是 CSRF 攻击？如何防止？</h3>
<p>答：</p>
<ul>
<li><code>CSRF</code> 叫 跨站点请求伪造攻击，攻击形式是：用户先登录银行 <code>A</code> 网站，这时候就获得了 <code>A</code> 网站的<code>Cookie</code>，然后不小心访问了一个恶意 <code>B</code> 网站，<code>B</code> 网站会让用户向银行 <code>A</code> 网站发起一个转账请求，由于用户端有了银行 <code>A</code> 网站的 <code>Cookie</code>，这时候有可能就会转账成功，造成并非本人意愿的操作结果</li>
<li>防御 <code>CSRF</code> 攻击的话，可以有这些方式：
<ol>
<li>同源检测：在服务器端对请求进行同源检测，只接受来自同一域名下的请求。这可以通过检查请求头中的 <code>Referer</code> 字段或者 <code>Origin</code> 字段来实现</li>
<li>使用验证码：对于敏感操作，要求用户输入验证码进行验证，以防止自动化脚本发起的恶意请求</li>
<li>使用 <code>CSRF</code> 令牌：在用户执行敏感操作时，要求用户提交一个 <code>CSRF</code> 令牌。该令牌是一个随机生成的字符串，存储在用户的会话中，并且在每个请求中都要验证该令牌的有效性。攻击者无法伪造正确的 <code>CSRF</code> 令牌，从而防止 <code>CSRF</code> 攻击</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>CSRF</code> 叫 跨站点请求伪造攻击，攻击者通过跨站请求，以合法的用户身份进行非法操作如转账交易、发表评论等。其核心是利用了浏览器 <code>Cookie</code> 或服务器的 <code>Session</code> 策略，盗取用户的身份信息</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104150958442.png" alt="CSRF攻击" loading="lazy"></p>
</li>
<li>
<p>在打开 <code>A</code> 网站 的情况下，另开 <code>Tab</code> 页面打开恶意网站 <code>B</code>，此时在 <code>B</code> 页面的恶意意图下，浏览器发起一个对网站 <code>A</code> 的 <code>HTTP</code> 请求，因为之前 <code>A</code> 网站 已经打开了，浏览器存有 <code>A</code> 网站中的 <code>Cookie</code> 或其他用于身份认证的信息，这一次被 恶意意图的请求，将会自动带上这些信息，这将会导致身份劫持，造成并非本人意愿的操作结果</p>
</li>
<li>
<p>而对应 <code>CSRF</code> 攻击的防御策略有：表单<code>token</code>、验证码、<code>Referer</code> 检测等</p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://tsejx.github.io/javascript-guidebook/computer-networks/web-security/csrf/">CSRF 跨站请求伪造攻击 - JavaScript Guidebook</a></p>
<hr>
<h3 id="什么是-SQL-注入攻击？如何防止？"><a class="headerlink" href="#什么是-SQL-注入攻击？如何防止？"></a>什么是 SQL 注入攻击？如何防止？</h3>
<p>答：</p>
<ul>
<li><code>SQL</code> 注入攻击是攻击者在 <code>HTTP</code> 请求中注入恶意 <code>SQL</code> 语句，让服务端构造执行 <code>SQL</code> 语句时，恶意的<code>SQL</code> 被一起构造了，然后在数据库中执行，这样就可能对数据库造成全量数据拉取、删除、更新等敏感的操作</li>
<li>预防 <code>SQL</code> 注入攻击，可以通过这几个方式：
<ol>
<li><strong>使用参数化查询或预编译语句</strong>：使用参数化查询或预编译语句来构建和执行 <code>SQL</code> 查询。这样可以将用户输入的数据作为参数传递给查询，而不是将其直接拼接到 <code>SQL</code> 语句中，参数化查询可以防止恶意代码的注入</li>
<li><strong>输入验证和过滤</strong>：对用户输入的数据进行验证和过滤，确保只接受合法的输入，可以使用白名单过滤、正则表达式验证或者编码转义等技术来防止恶意代码的注入</li>
<li><strong>最小权限原则</strong>：在数据库中为应用程序使用最小权限的数据库账户，这样即使发生SOL注入攻击，攻击者也只能在该账户的权限范围内进行操作，减少损失</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>SQL</code> 注入攻击指的是攻击者在 <code>HTTP</code> 请求中注入恶意 <code>SQL</code> 命令，服务器用请求参数构造数据库 <code>SQL</code> 命令时，恶意 <code>SQL</code> 被一起构造，并在数据库中执行，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等敏感的操作，从而导致数据被随意篡改</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104151920664.png" alt="SQL注入攻击" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cloudflare-cn.com/learning/security/threats/sql-injection/">什么是 SQL 注入？ | Cloudflare</a>、<a target="_blank" rel="noopener" href="https://m.imooc.com/wiki/sqlbase-sqlpractice1">实战1：如何用 PREPARE 防止 SQL 注入_SQL 入门教程-慕课网</a></p>
<hr>
<h2 id="网络编程"><a class="headerlink" href="#网络编程"></a>网络编程</h2>
<hr>
<h3 id="Socket-网络编程对应-TCP-三次握手的环节？"><a class="headerlink" href="#Socket-网络编程对应-TCP-三次握手的环节？"></a>Socket 网络编程对应 TCP 三次握手的环节？</h3>
<p>答：</p>
<ol>
<li>服务端首先会通过 <code>bind</code> 函数给 <code>socket</code> 绑定 端口 和 <code>IP</code> 地址，然后调用 <code>listen</code> 函数，进行监听，然后调用 <code>accpet</code> 函数等待客户端建立连接</li>
<li>当客户端调用 <code>connect</code> 函数的时候，内核会随机生成初始化序号，放到 <code>TCP</code> 报文头部的序号字段中，同时把 SYN 标志设置为 <code>1</code>，这样就表示 <code>SYN</code> 报文。接着把这个 <code>SYN</code> 报文发送给服务端，之后客户端处于 <code>SYN_SENT</code> 状态</li>
<li>服务端收到 <code>SYN</code> 报文后，首先服务端也会随机生成初始化序号，放到 <code>TCP</code> 报文头部的序号字段中，然后对客户端的 <strong>初始化序号+1 作为 确认号</strong>，放到 <code>TCP</code> 报文头部的确认应答字段中，并将 <code>SYN</code> 和 <code>ACK</code> 标志设置为 1，这样就表示 <code>SYN_ACK</code> 报文，然后把该报文发给客户端，之后服务端处于 <code>SYN_RCVD</code> 状态</li>
<li>客户端收到服务端 <code>SYN_ACK</code> 报文后，客户端会回一个 <code>ACK</code> 确认报文，该报文的确认号是 <strong>服务端的初始化序号+1</strong>，并且 <code>ACK</code> 标志会设置为 1，之后客户端处于 <code>ESTABLISHED</code> 状态，这时候 <code>connect</code> 函数就返回了</li>
<li>服务端收到 <code>ACK</code> 确认报文后，服务端也进入处于 <code>ESTABLISHED</code> 状态，这时候 <code>accpet</code> 函数就返回已建立连接的 <code>socket</code>，后续与客户端进行通信，就是对这个 <code>socket</code> 进行读写操作</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104193109983.png" alt="TCP三次握手" loading="lazy"></p>
<hr>
<h3 id="建立TCP连接，Socket-在-TCP-握手哪个阶段可以拿到连接？"><a class="headerlink" href="#建立TCP连接，Socket-在-TCP-握手哪个阶段可以拿到连接？"></a>建立TCP连接，Socket 在 TCP 握手哪个阶段可以拿到连接？</h3>
<p>答：</p>
<p>需要完成三次握手后，服务端才能通过 <code>accpet</code> 函数得到已经建立 <code>TCP</code> 连接的 <code>socket</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104193240591.png" alt="TCP三次握手" loading="lazy"></p>
<hr>
<h3 id="listen-的参数-backlog-意义是什么？"><a class="headerlink" href="#listen-的参数-backlog-意义是什么？"></a>listen 的参数 backlog 意义是什么？</h3>
<p>答：</p>
<p><code>backlog</code> 参数的大小，是<strong>指定 <code>TCP</code> 全连接队列大小的参数之一</strong>。内核会从内核参数 <code>somaxconn</code> 大小和<code>backlog</code> 参数大小之间取一个最小值作为 <code>TCP</code> 全连接队列大小</p>
<p><strong>补充</strong>：</p>
<p>Linux内核中会维护两个队列：</p>
<ul>
<li>半连接队列（<code>SYN</code> 队列）：接收到一个 <code>SYN</code> 建立连接请求，处于 <code>SYN_RCVD</code> 状态</li>
<li>全连接队列（<code>Accpet</code> 队列）：已完成 <code>TCP</code> 三次握手过程，处于 <code>ESTABLISHED</code> 状态</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104194132864.png" alt="TCP三次握手" loading="lazy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span> <span class="params">(<span class="type">int</span> socketfd, <span class="type">int</span> backlog)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数一 <code>socketfd</code>：为 <code>socketfd</code> 文件描述符</li>
<li>参数二 <code>backlog</code>：这参数在历史版本有一定的变化在
<ul>
<li>早期 <code>Linux</code> 内核 <code>backlog</code> 是 <code>SYN</code> 队列大小，也就是未完成的队列大小。在 <code>Linux</code> 内核 <code>2.2</code> 之后，<code>backlog</code> 变成 <code>accept</code> 队列，也就是已完成连接建立的队列长度，所以现在通常认为 <code>backlog</code> 是 <code>accept</code> 队列</li>
<li>但是上限值是内核参数 <code>somaxconn</code> 的大小，也就说 <code>accpet</code> 队列长度= <code>min(backlog, somaxconn)</code></li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">4.4 TCP 半连接队列和全连接队列 | 小林coding</a></p>
<hr>
<h3 id="当客户端多次发送连接，服务器没有accept，客户端会出现什么现象？"><a class="headerlink" href="#当客户端多次发送连接，服务器没有accept，客户端会出现什么现象？"></a>当客户端多次发送连接，服务器没有accept，客户端会出现什么现象？</h3>
<p>答：</p>
<p>我觉得会导致客户端无法和服务端建立 <code>TCP</code> 连接，因为如果服务端没有执行 <code>accpet</code> 的话，那么已经建立连接的 <code>socket</code> 会堆积到 TCP 全连接队列，如果 <code>TCP</code> 全连接队列占满了，服务端收到新的客户端 <code>SYN</code> 报文的时候，内核就会丢弃 <code>SYN</code> 报文</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104194815855.png" alt="全连接队列" loading="lazy"></p>
<hr>
<h3 id="四次挥手对应-socket-中通信的部分，其中哪些是用户调用，哪些是内核完成的？"><a class="headerlink" href="#四次挥手对应-socket-中通信的部分，其中哪些是用户调用，哪些是内核完成的？"></a>四次挥手对应 socket 中通信的部分，其中哪些是用户调用，哪些是内核完成的？</h3>
<p>答：</p>
<p>第一次挥手和第三次挥手的 <code>FIN</code> 报文，都需要客户端或者服务端调用 <code>close</code> 函数触发的，第二次和四次挥手的 <code>ACK</code> 就是 <strong>内核</strong> 来完成</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104194942946.png" alt="TCP四次挥手" loading="lazy"></p>
<hr>
<h3 id="如果客户端和服务端同时调用了-close-会发生什么？"><a class="headerlink" href="#如果客户端和服务端同时调用了-close-会发生什么？"></a>如果客户端和服务端同时调用了 close() 会发生什么？</h3>
<p>答：</p>
<p>双方会同时发送 <code>FIN</code> 报文，由于双方在等待 <code>ACK</code> 报文的过程中，都等来了 <code>FIN</code> 报文，这是一种新情况，所以连接会进入一种叫做 <code>CLOSING</code> 的新状态，它替代了 <code>FIN_WAIT_2</code> 状态。接着，双方内核回复 <code>ACK</code> 确认对方发送通道的关闭后，进入 <code>TIME_WAIT</code> 状态，等待 <code>2MSL</code> 的时间后，连接自动关闭</p>
<p><strong>补充</strong>：</p>
<p>由于 <code>TCP</code> 是双全工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 <code>FIN</code> 报文</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250104195341628.png" alt="TCP四次挥手" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aea9ae5c8a3c">计算机网络：TCP同时打开和同时关闭 - 简书</a></p>
<hr>
<h3 id="怎么知道客户端关闭连接？"><a class="headerlink" href="#怎么知道客户端关闭连接？"></a>怎么知道客户端关闭连接？</h3>
<p>答：</p>
<ul>
<li>（<strong>正常断开情况</strong>）如果客户端正常断开连接的情况下，会发起了第一次挥手 <code>FIN</code> 报文，服务端收到后，内核会插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 <code>FIN</code> 报文，如果 <code>read</code> 返回 0 了，就代表客户端关闭连接了</li>
<li>（<strong>异常断开情况</strong>）如果客户端突然宕机了，服务端无感知客户端已经不存在了，如果接下来服务端不会在发送任何数据的话超过一段时间后，<code>TCP</code> 就会开启保活机制，来探测客户端是否还存活，如果最终判断到客户端不存在了，服务端这边也会自动释放连接</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youxin/p/4056041.html">tcp 服务端如何判断客户端断开连接 - youxin - 博客园</a></p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"></a><div class="post-copyright__author_name">coo1heisenberg's Blog</div><div class="post-copyright__author_desc">Diligence can make up for clumsiness!</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">coo1heisenberg's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tags-punctuation"></span>计算机网络<span class="tagsPageCount">1</span></a></div></div><div class="social-share"></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">00 操作系统知识点归纳 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">06 Redis知识点归纳 笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">菜鸡的自我救赎...</div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Coo1heisenberg’s BLOG</div><div class="author-info__desc">Diligence can make up for clumsiness!</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/coo1heisenbergProject" title="Github"><i class="solitude  st-github-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">计算机网络知识点归纳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-OSI-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">介绍一下 OSI 七层协议，各层协议都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82%EF%BC%9F"><span class="toc-text">TCP&#x2F;IP 网络模型有哪几层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%8D%8F%E8%AE%AE%E5%92%8C-TCP-%E5%8D%8F%E8%AE%AE%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">IP 协议和 TCP 协议属于哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">网络为什么要分层？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-text">键入网址场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">输入网址后，期间发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%9A%84%EF%BC%9F%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">DNS 是如何解析的？属于哪一层的协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">DNS域名解析使用的什么协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%AB%AF%E5%8F%A3%E7%9A%84%EF%BC%9F"><span class="toc-text">输入域名如何知道端口的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%BA%94%E8%AF%A5%E6%8A%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E8%B0%81%EF%BC%9F"><span class="toc-text">客户端向服务端的 IP 地址发送数据，服务端如何确定应该把数据传递给谁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E5%BE%88%E5%A4%9A%E7%BD%91%E7%AB%99%E9%83%BD%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8-https%EF%BC%8C%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-http-%E7%BD%91%E5%9D%80%EF%BC%8C%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%94%B1-http-%E8%B7%B3%E8%BD%AC%E5%88%B0-https-%E7%9A%84%EF%BC%9F"><span class="toc-text">现在很多网站都要求使用 https，假设我们输入一个 http 网址，网站是如何实现由 http 跳转到 https 的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-text">网络传输场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">如果浏览器没有显示页面有哪些原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8ping%E4%B8%8D%E9%80%9A%E4%BD%86%E6%98%AFhttp%E8%83%BD%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%90%97%EF%BC%9F"><span class="toc-text">服务器ping不通但是http能请求成功，会出现这种情况吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 TCP 连接一个不存在的 IP 地址的服务端会发生什么？（cold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 TCP 连接一个 IP 地址存在但是端口不存在的服务端会发生什么？（cold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-UDP-%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 UDP 发送一个 IP 地址存在但是端口不存在报文会发生什么？（cold）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">HTTP 协议的特点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%86%E5%89%B2%E7%9A%84%EF%BC%9F"><span class="toc-text">HTTP 报文格式？怎么分割的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%BB%98%E8%AE%A4%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">HTTP 默认的端口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">HTTP 有什么方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E5%93%AA%E4%BA%9B-HTTP-%E6%96%B9%E6%B3%95%E6%98%AF%E5%AE%89%E5%85%A8%E6%88%96%E8%80%85%E5%B9%82%E7%AD%89%E7%9A%84%EF%BC%9F"><span class="toc-text">分析一下哪些 HTTP 方法是安全或者幂等的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">GET 和 POST 请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E8%AF%B7%E6%B1%82%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AE%89%E5%85%A8%E4%B8%94%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">GET 请求一定是安全且幂等的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-text">HTTP 有什么状态码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0502%E9%94%99%E8%AF%AF%E7%A0%81%E5%91%A2%EF%BC%9F"><span class="toc-text">什么情况下会出现502错误码呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E4%BA%86504%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%87%BA%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">有个服务出现了504，你觉得这个服务是出了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E5%93%AA%E4%B8%80%E7%B1%BB%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">重定向是哪一类状态码？临时重定向和永久重定向有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">HTTP 是长连接还是短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP 长连接和短连接的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">HTTP 长连接有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0-%E5%92%8C-HTTP-3-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">HTTP 是无状态的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%94%A8%E6%88%B7%E5%90%8E%E7%BB%AD%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%EF%BC%9F"><span class="toc-text">HTTP 用户后续的操作，服务端如何知道属于同一个用户？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%99%A8%EF%BC%9F"><span class="toc-text">如果服务端是一个集群机器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A6%81%E7%94%A8-Cookie%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-Session%EF%BC%9F"><span class="toc-text">如果禁用 Cookie，怎么实现 Session？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">cookie 和 session 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E3%80%81session-%E5%92%8C-Token-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Cookie、session 和 Token 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-JWT-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">简述 JWT 的原理和校验机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E4%BB%A4%E7%89%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-text">JWT 令牌为什么能解决集群部署？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">JWT 有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">什么是跨域？什么情况下会发生跨域请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RestFul-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FRestFul-%E8%AF%B7%E6%B1%82%E7%9A%84-URL-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">RestFul 是什么？RestFul 请求的 URL 有什么特点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP 和 HTTPS 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">了解过哪些加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">对称加密和非对称加密是什么？各自有哪些算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">对称和非对称的加密算法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A4%A7%E5%B0%8F%E6%9C%AA%E7%9F%A5%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%A6%81%E6%8A%8A%E5%AE%83%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E7%AB%AF%EF%BC%8C%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%BF%98%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">HTTPS 建立的过程是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9F"><span class="toc-text">为什么需要三个随机数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1HTTPS%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1RTT%EF%BC%88%E5%B0%B1%E6%98%AF%E5%87%A0%E4%B8%AA%E6%9D%A5%E5%9B%9E%EF%BC%89%EF%BC%9F"><span class="toc-text">一次HTTPS需要几次RTT（就是几个来回）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%B8%9A%E7%95%8C%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AARTT%E5%BB%BA%E7%AB%8BHTTPS%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-text">你了解业界现在有一个RTT建立HTTPS连接的方案吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%A4%9A%E5%B0%91%E6%AC%A1%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F%E5%A4%9A%E5%B0%91%E6%AC%A1%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">HTTPS 过程进行了多少次非对称加密？多少次对称加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">SSL 握手流程为什么要使用非对称加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-HTTPS-%E4%B8%8D%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86-HTTP-%E6%8A%A5%E6%96%87%EF%BC%9F"><span class="toc-text">为什么 HTTPS 不用非对称加密算法加密 HTTP 报文？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E4%BC%9A%E5%AF%B9-URL-%E5%8A%A0%E5%AF%86%E5%90%97%EF%BC%9F"><span class="toc-text">HTTPS 会对 URL 加密吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CA-%E6%9C%BA%E6%9E%84%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81server%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-text">CA 机构如何验证server身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E6%98%AF%E7%BB%BF%E8%89%B2%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">证书是绿色的是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E9%9A%8F%E4%BE%BF%E7%BC%96%E4%B8%80%E4%B8%AA%E8%AF%81%E4%B9%A6%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E9%9C%80%E8%A6%81%E5%8E%BB%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E6%B3%A8%E5%86%8C%EF%BC%9F"><span class="toc-text">自己随便编一个证书可以吗？需要去什么地方注册？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">RPC 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%E4%BA%86%EF%BC%9F%E8%BF%98%E8%A6%81%E7%94%A8RPC%EF%BC%9F"><span class="toc-text">为什么有HTTP协议了？还要用RPC？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx"><span class="toc-text">Nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E4%BD%8D%E4%BA%8E%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">Nginx 位于七层网络结构的哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">Nginx 有哪些负载均衡算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">什么是反向代理？什么是正向代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP 三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A4%B4%E9%83%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-text">TCP头部有哪些字段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">说一下TCP三次握手的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">为什么需要三次握手？两次不行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%8C%85%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果第一次握手丢包，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%8C%85%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果第二次握手丢包，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%8C%85%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果第三次握手丢包，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">TCP的半连接队列和全连接队列了解过吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP 四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">TCP 四次挥手的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">为什么 TCP 需要四次挥手？三次挥手不行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">TIME_WAIT 是如何产生的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%8A%B6%E6%80%81%E8%A6%81%E7%AD%89%E5%BE%85-2MSL%EF%BC%9F"><span class="toc-text">为什么 TIME_WAIT 状态要等待 2MSL？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3"><span class="toc-text">TIME_WAIT 过多有什么危害?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-TIME-WAIT-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">怎么解决 TIME_WAIT 状态过多的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">服务端产生大量 TIME_WAIT 状态的原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">服务端产生大量 CLOSE_WAIT 状态的原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9Cserver%E5%8F%91%E9%80%81FIN%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%9B%A0%E4%B8%BAclient%E6%8C%82%E6%8E%89%E4%BA%86%EF%BC%8C%E6%94%B6%E4%B8%8D%E5%88%B0%E5%9B%9E%E5%BA%94%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果server发送FIN之后，因为client挂掉了，收不到回应，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%95%E6%9C%BA%E9%87%8D%E5%90%AF%EF%BC%8C%E6%94%B6%E5%88%B0%E4%BA%86server-%E7%9A%84-FIN%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果客户端宕机重启，收到了server 的 FIN，会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%8E-UDP"><span class="toc-text">TCP 与 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP 和 UDP 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-TCP%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-UDP%EF%BC%9F"><span class="toc-text">什么时候用 TCP？什么时候用 UDP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E6%AD%A4%E5%88%BB%E7%9A%84%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%E7%94%A8%E7%9A%84-UDP-%E8%BF%98%E6%98%AF-TCP%EF%BC%9FUDP%E4%B8%A2%E5%8C%85%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">此时此刻的视频面试用的 UDP 还是 TCP？UDP丢包会有什么现象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E6%80%8E%E4%B9%88%E6%94%B9%E9%80%A0%E5%8F%98%E4%B8%BA%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-text">UDP 怎么改造变为可靠传输？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-text">TCP 和 UDP 可以共用一个端口吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">TCP 可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP 是如何保证可靠性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP 流量控制和拥塞控制的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">滑动窗口怎么设计的？解决什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP 协议拥塞控制怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94%E5%92%8C%E7%B4%AF%E8%AE%A1%E5%BA%94%E7%AD%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">TCP 的延迟应答和累计应答是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-text">TCP 场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%86%E5%8C%85%E6%B2%BE%E5%8C%85%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">TCP 拆包沾包原因是什么？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84-keepalive-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%AE%83%E5%92%8C-HTTP-%E7%9A%84-keepalive-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MTU%E6%98%AF%E5%95%A5%EF%BC%9FMSS%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-text">MTU是啥？MSS是啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81MSS%E5%91%A2%EF%BC%9F"><span class="toc-text">IP层会分片，为什么TCP层还需要MSS呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B0%91%E6%9D%A1-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">一个服务端进程最多可以建立多少条 TCP 连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B0%91%E6%9D%A1-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">一个机器最多可以建立多少条 TCP 连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%96%AD%E7%94%B5%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果已经建立了连接，但是服务端突然出现断电了会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%AD-SYN-%E6%B4%AA%E6%B0%B4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="toc-text">TCP 中 SYN 洪水是什么？如何防止？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ping-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">ping 的工作原理说一下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">交换机和路由器有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IP-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">什么是 IP 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mac-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">什么是 mac 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%92%8CMAC%E5%9C%B0%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">IP地址和MAC地址有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81MAC%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">为什么有了IP地址，还需要MAC地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT%E6%98%AF%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">NAT是什么协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#192-168-1-100-24-%E4%B8%AD%E7%9A%84%E6%96%9C%E6%9D%A0%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">192.168.1.100&#x2F;24 中的斜杠代表什么意思？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98"><span class="toc-text">网络攻击问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">DNS 劫持是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E6%B1%A1%E6%9F%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">DNS 污染是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-DDOS-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E5%AE%83%EF%BC%9F"><span class="toc-text">简述 DDOS 攻击原理，如何防范它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="toc-text">什么是 XSS 攻击？如何防止？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="toc-text">什么是 CSRF 攻击？如何防止？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="toc-text">什么是 SQL 注入攻击？如何防止？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AF%B9%E5%BA%94-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E7%8E%AF%E8%8A%82%EF%BC%9F"><span class="toc-text">Socket 网络编程对应 TCP 三次握手的环节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%EF%BC%8CSocket-%E5%9C%A8-TCP-%E6%8F%A1%E6%89%8B%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%AF%E4%BB%A5%E6%8B%BF%E5%88%B0%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">建立TCP连接，Socket 在 TCP 握手哪个阶段可以拿到连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen-%E7%9A%84%E5%8F%82%E6%95%B0-backlog-%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">listen 的参数 backlog 意义是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E6%AC%A1%E5%8F%91%E9%80%81%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E6%9C%89accept%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">当客户端多次发送连接，服务器没有accept，客户端会出现什么现象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AF%B9%E5%BA%94-socket-%E4%B8%AD%E9%80%9A%E4%BF%A1%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%98%AF%E7%94%A8%E6%88%B7%E8%B0%83%E7%94%A8%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%86%85%E6%A0%B8%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-text">四次挥手对应 socket 中通信的部分，其中哪些是用户调用，哪些是内核完成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8C%E6%97%B6%E8%B0%83%E7%94%A8%E4%BA%86-close-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果客户端和服务端同时调用了 close() 会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">怎么知道客户端关闭连接？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记"><img alt="00 Kafka 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/kafka_log.png"></a><div class="content"><a class="title" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记">00 Kafka 笔记</a><a class="article-recent_post_categories" href="/2025/01/10/00-Kafka/">MQ</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记"><img alt="00 操作系统知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/caozuoxitong.png"></a><div class="content"><a class="title" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记">00 操作系统知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记"><img alt="00 计算机网络知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/computer_network.png"></a><div class="content"><a class="title" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记">00 计算机网络知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记"><img alt="06 Redis知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/redis_conclude.png"></a><div class="content"><a class="title" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记">06 Redis知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记"><img alt="05 MySQL知识点总结 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MySQl_ALL.png"></a><div class="content"><a class="title" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记">05 MySQL知识点总结 笔记</a><a class="article-recent_post_categories" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Solitude</span></div><div class="footer-bar-description">来自 Heisenberg 的原创文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 - 2025 By&nbsp;<a class="footer-bar-link" href="/">Coo1heisenberg’s BLOG</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.10.6"></script><script src="/js/main.js?v=1.10.6"></script><script src="/js/third_party/waterfall.min.js?v=1.10.6"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.10.6"></script><script>dark()
</script><script src="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="//open.lightxi.com/cdnjs/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script defer pjax src="//open.lightxi.com/cdnjs/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.10.6"></script><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["2025/01/10/00-Kafka/","2025/01/04/操作系统知识点归纳/","2024/12/24/计算机网络知识点归纳/","2024/12/21/01-redis知识点归纳/","2024/12/16/01-MySQL知识点归纳/","2024/12/04/Spring框架/","2024/12/02/Java-JVM虚拟机/","2024/11/04/Java-并发编程/","2024/11/01/Java-集合框架/","2024/09/28/00-前端开发入门教程/","2024/09/26/01-空间转录组/","2024/09/13/00-单细胞多组学分析/","2024/07/22/00-MongoDB/","2024/07/17/00-elasticsearch/","2024/07/15/01-黑马redis/","2024/07/13/00-黑马redis/","2024/07/08/00-黑马SSM/","2024/07/08/01-头条点评项目/","2024/07/06/00-Mybatis-Plus/","2024/06/29/00-黑马MySQL/","2024/06/25/00-头条点评项目/","2024/06/21/02-Python/","2024/06/11/01-Python/","2024/05/25/00-Python/","2024/05/13/DesignPattern/","2024/05/13/Docker/","2024/05/13/Nginx/","2024/05/13/Linux/","2024/05/07/00-spike-program/","2024/01/09/00-Asynchronous-framework/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>