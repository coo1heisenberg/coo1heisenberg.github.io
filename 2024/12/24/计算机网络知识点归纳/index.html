<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>00 计算机网络知识点归纳 笔记 | coo1heisenberg's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.10.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="计算机网络知识点归纳 网络分层模型 介绍一下 OSI 七层协议，各层协议都有哪些？ 答： OSI 参考模型共有 7 层，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层的协议有： HTTP、HTTPS 传输层的协议有：TCP 和 UDP 网络层的协议有：IP"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="coo1heisenberg's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.10.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;border-radius:0 5px 5px 0",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-05-12 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.webp'
    },
    copyright: {"limit":50,"author":"作者: Coo1heisenberg’s BLOG","link":"链接: ","source":"来源: coo1heisenberg's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Project/">Project<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">2024/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">2024/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">2024/06</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">2024/05</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Project/">Project<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon solitude st-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">00 计算机网络知识点归纳 笔记</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" href="/" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/computer_network.png" alt="00 计算机网络知识点归纳 笔记"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Others/">Others</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tags-name tags-punctuation">计算机网络</span></a></div></div></div></div><h1 class="post-title">00 计算机网络知识点归纳 笔记</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-12-24 16:45:51"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-12-24T08:45:51.000Z">2024-12-24T08:45:51.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-12-28 14:57:24"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-12-28T06:57:24.818Z">2024-12-28T06:57:24.818Z</time></span><span class="post-meta-wordcount"><span class="post-meta-separator"></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>计算机网络知识点归纳</h1>
<hr>
<h2 id="网络分层模型"><a class="headerlink" href="#网络分层模型"></a>网络分层模型</h2>
<hr>
<h3 id="介绍一下-OSI-七层协议，各层协议都有哪些？"><a class="headerlink" href="#介绍一下-OSI-七层协议，各层协议都有哪些？"></a>介绍一下 OSI 七层协议，各层协议都有哪些？</h3>
<p>答：</p>
<ul>
<li><code>OSI</code> 参考模型共有 <code>7</code> 层，从上到下分别是：<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>、<strong>物理层</strong>
<ul>
<li>应用层的协议有： <code>HTTP</code>、<code>HTTPS</code></li>
<li>传输层的协议有：<code>TCP</code> 和 <code>UDP</code></li>
<li>网络层的协议有：<code>IP</code>、<code>ICMP</code>、<code>ARP</code></li>
</ul>
</li>
<li>我认为，网络分层的好处是：<strong>对各个层之间进行了解耦，层一层之间不会产生关联性</strong>，比如：我们应用层的 <code>HTTP</code> 协议，从 <code>HTTP1.1</code> 升级到 <code>HTTP2.0</code> 的时候，并不会对传输层、网络层等有影响，或者网络层的 <code>IPv4</code> 协议升级为 <code>IPv6</code> 协议的时候，也不会影响应用层、传输层</li>
<li>不过，<code>OSI</code> 参考模型只是理论模型，实际上因特网中的网络模型是使用了 <code>TCP/IP</code> 网络模型，它对 <code>OSI</code> 参考模型做了简化，<strong>把 应用层、表示层、会话层 统一成了 应用层</strong>，<strong>数据链路层 和 物理层 统一成了 网络接口层</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241224183155709.png" alt="OSI模型 TCP/IP模型" loading="lazy"></p>
<ul>
<li><code>OSI</code> 的 7 层模型从上到下依次为：<strong>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</strong></li>
<li><strong>应用层</strong>：<strong>负责直接与 软件应用程序 交互以提供所需的通信功能</strong>，并且它 <strong>与最终用户最接近</strong>
<ul>
<li><strong>应用层的功能</strong>：通常包括 <strong>验证通信伙伴</strong> 和 <strong>资源的可用性</strong> 以支持任何数据传输。该层还定义了用于最终应用程序的协议，例如：域名系统（<code>DNS</code>）、文件传输协议（<code>FTP</code>）、超文本传输协议（<code>HTTP</code>）、<code>Internet</code> 消息访问协议（<code>IMAP</code>）、邮局协议（<code>POP</code>）、简单邮件传输协议（<code>SMTP</code>）、简单网络管理协议（<code>SNMP</code>）和 <code>Telnet</code>（终端仿真)</li>
</ul>
</li>
<li><strong>表示层</strong>：<strong>表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另个系统的应用层识别</strong>，如：<strong>数据转换，压缩和加密，解密</strong>
<ul>
<li>表示层可以 <strong>处理任何所需的数据格式或代码转换</strong></li>
<li>例如：将扩展 二进制编码 的 十进制交换码（<code>EBCDIC</code>）编码的文本文件 转换为 美国信息交换标准码（<code>ASCII</code>）编码的文本文件</li>
<li>表示层也 可<strong>用于数据压缩和加密</strong></li>
<li>例如：视频呼叫将在传输过程中被压缩。以便可以更快地传输，并且数据将在接收方恢复。对于具有较高安全性要求的数据（例如：包含你的密码的短信），将在此层进行加密</li>
</ul>
</li>
<li><strong>会话层</strong>：<strong>会话层控制计算机之间的对话（连接）它建立，管理，维护并最终终止本地和远程应用程序之间的连接</strong>
<ul>
<li>会话层软件 还 <strong>处理 身份验证 和 授权功能</strong>。会话层通常在使用远程过程调用的应用程序环境中明确实现</li>
</ul>
</li>
<li><strong>传输层</strong>：<strong>负责两个设备间的 端 到 端 通信</strong>
<ul>
<li>包括：从会话层提取数据，将数据分解为多个数据，然后再发送到网络层</li>
<li>传输层还负责进行 <strong>流量控制</strong> 和 <strong>错误控制</strong>。<strong>流量控制 用于 确定最佳传输速度</strong>，避免发送方发送速率过快导致接收方接收不过来的情况。传输层还会确保接收数据的完整性（如果不完整，则请求重新传输）来对接收端进行错误控制。传输层包含 <code>TCP</code> 和 <code>UDP</code> 协议</li>
</ul>
</li>
<li><strong>网络层</strong>：网络层通过 <strong>逻辑寻址</strong> 和 <strong>交换功能</strong> 处理 <strong>数据包路由</strong>
<ul>
<li>这一层：实现 <strong>不同网络</strong> 之间的 <strong>数据传输</strong>。它进一步将网段或数据报分解成更小的数据包，并使用 <code>IP</code> 地址找到通往最终目的地的最佳路由。这一过程被称为 <strong>路由选择</strong></li>
<li>网络是可以连接许多 节点 的介质。每个节点都有一个地址。当一个节点需要将消息传输到其他节点时，它仅能提供 <strong>消息的内容</strong> 和 <strong>目标节点的地址</strong>，则网络将找到将消息传递到目标节点的方法，并可能通过其他节点进行路由。如果消息太长，网络可能会在一个节点上将其拆分为多个段，分别发送它们，然后在另一节点上重新组合片段</li>
</ul>
</li>
<li><strong>数据链路层</strong>：数据链路层提供 <strong>节点</strong> 到 <strong>节点</strong> 的传输，即：<strong>两个直接连接的节点之间的链接</strong>
<ul>
<li>这一层允许在 <strong>同一网络</strong> 的 <strong>设备</strong> 之间传输数据。<strong>数据包 被分解成 帧</strong>，这些帧被限制在 局域网 内</li>
<li>它以 <strong>帧</strong> 的形式处理 <strong>数据的打包</strong> 和 <strong>拆包</strong>。它定义了在两个物理连接的设备之间建立和终止连接的协议，例如：点对点协议（<code>PPP</code>）</li>
<li>数据链路层通常分为两个子层：<strong>媒体访问控制（<code>MAC</code>）层</strong>和 <strong>逻辑链路控制（<code>LLC</code>）层</strong>。<code>MAC</code> 层负责控制网络中的设备如何访问媒体以及允许传输数据。<code>LLC</code> 层负责标识和封装网络层协议，并控制错误检查和帧同步</li>
</ul>
</li>
<li><strong>物理层</strong>：<strong>物理层定义了数据连接的物理规格</strong>
<ul>
<li>例如：连接器的插针布局，电缆的工作电压，光纤电缆规格以及无线设备的频率。它负责物理介质中非结构化原始数据的发送和接收</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247531667&amp;idx=2&amp;sn=f420c02c4512d410f2b864f367498adb&amp;chksm=f98d3839cefab12fcd60009fddb1463946cf4a7c22371067103dc891bcceea5946a563b183d6&amp;token=1859366457&amp;lang=zh_CN#rd">面试官：我们为什么需要 7 层 OSI 网络模型？</a>、<a target="_blank" rel="noopener" href="https://www.cloudflare-cn.com/learning/ddos/glossary/open-systems-interconnection-model-osi/">什么是 OSI 模型？ | Cloudflare</a></p>
<hr>
<h3 id="TCP-IP-网络模型有哪几层？"><a class="headerlink" href="#TCP-IP-网络模型有哪几层？"></a>TCP/IP 网络模型有哪几层？</h3>
<p>答：</p>
<ul>
<li><code>TCP/IP</code> 网络模型主要有 四 层，从上到下分别是：<strong>应用层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>网络接口层</strong></li>
<li><strong>应用层</strong>：<strong>负责为 应用软件 提供 网络服务</strong>
<ul>
<li>例如：<code>HTTP</code>、<code>HTTPS</code>、<code>DNS</code>等协议</li>
</ul>
</li>
<li><strong>传输层</strong>：<strong>负责为 应用程序层 提供 数据传输服务</strong>
<ul>
<li>传输层协议 主要有 <code>TCP</code> 和 <code>UDP</code>
<ul>
<li><code>TCP</code>是 可靠 传输协议</li>
<li><code>UDP</code> 是 不可靠 的传输协议</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络层</strong>：<strong>负责主机 寻址，打包 和 路由 功能</strong>
<ul>
<li>网络层的核心协议是：<code>IP</code>、<code>ARP</code>、<code>ICMP</code> 等协议
<ul>
<li><code>IP</code> 协议负责寻址和路由</li>
<li><code>ARP</code> 协议负责获取 <code>MAC</code> 地址</li>
<li><code>ICMP</code> 负责提供诊断功能并报告错误</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络接口层</strong>：负责为 <strong>网络层提供「链路级别」传输的服务</strong>，负责 <strong>在 以太网、<code>WiFi</code> 这样的底层网络上发送原始数据包</strong>
<ul>
<li>工作在 网卡 这个层次，使用 <code>MAC</code> 地址来标识网络上的设备</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241224194836687.png" alt="TCP/IP网络模型" loading="lazy"></p>
<ul>
<li>
<p><code>TCP/IP</code> 网络模型有两种说法， 有的说 五 层 <code>TCP/IP</code> 网络模型，有的说 四 层 <code>TCP/IP</code> 网络模型</p>
<ul>
<li>四层 <code>TCP/IP</code> 网络模型是：应用层、传输层、网络层、网络接口层</li>
<li>五层 <code>TCP/IP</code> 网络模型是：应用层、传输层、网络层、数据链路层、物理层</li>
</ul>
</li>
<li>
<p><code>TCP/IP</code> 网络通常是由上到下分成 4 层，分别是：<strong>应用层，传输层，网络层 和 网络接口层</strong></p>
</li>
<li>
<p><strong>应用层</strong>：<code>TCP/IP</code> 模型的应用程序层使应用程序能够访问其他层的服务，并定义了应用程序用来交换数据的协议</p>
<ul>
<li>最熟悉的应用层协议包括：<code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SNMP</code> 和 路由信息协议（<code>RIP</code>）</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：传输层负责 <strong>为 应用程序层 提供 会话 和 数据通信服务</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225111207457.png" alt="传输层" loading="lazy"></p>
<ul>
<li>该层的核心协议是 <code>TCP</code> 和 <code>UDP</code>
<ul>
<li><code>TCP</code> 提供 <strong>一对一</strong>，<strong>面向连接</strong> 的 可靠通信服务。它负责对发送的数据包进行排序和确认，并恢复传输中丢失的数据包</li>
<li><code>UDP</code> 提供 <strong>一对一</strong> 或 <strong>一对多</strong> 的 <strong>无连接，不可靠</strong> 的通信服务。当要传输的数据量较小时（例如，该数据可以放入单个数据包中），通常使用 <code>UDP</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>：网络层 <strong>负责 主机寻址，打包 和 路由功能</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225111602000.png" alt="网络层" loading="lazy"></p>
<ul>
<li>网络层负责 <strong>将 数据 从 一个设备 传输到 另一个设备</strong></li>
<li><strong>网络层的核心协议</strong>：<code>IP</code>、地址解析协议（<code>ARP</code>）、<code>Internet</code> 控制消息协议（<code>ICMP</code>）和 <code>Internet</code> 组管理协议（<code>IGMP</code>）
<ul>
<li><code>IP</code> 是可路由协议，负责 <code>IP</code> 寻址，路由以及数据包的分段和重组
<ul>
<li>将 <code>IP</code> 地址分成两种意义：
<ul>
<li>一个是 <strong>网络号</strong>，负责标识该 <code>IP</code> 地址是<strong>属于哪个「子网」的</strong>
<ul>
<li><code>IP</code> 地址与 子网掩码 按位 与 运算</li>
</ul>
</li>
<li>一个是 <strong>主机号</strong>，<strong>负责标识同一「子网」下的不同主机</strong>
<ul>
<li><code>IP</code> 地址与 子网掩码取反后 按位 与 运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ARP</code> 负责发现网络访问层地址，例如：与给定 <code>Internet</code> 层访问关联的硬件地址</li>
<li>由于 <code>IP</code> 数据包传递失败，<code>ICMP</code> 负责提供诊断功能并报告错误</li>
<li><code>IGMP</code> 负责 <code>IP</code> 多播组的管理。<code>IP</code> 在此层中将标头添加到数据包中，称为 <code>IP</code> 地址。现在既有 <code>IPv4</code> （32位）地址又有 <code>IPv6</code> （128位）地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络接口层</strong>：网络接口层 <strong>负责将 <code>TCP/IP</code> 数据包放在网络介质上，并从网络介质上接收 <code>TCP/IP</code> 数据包</strong></p>
<ul>
<li><code>TCP/IP</code> 被设计为 独立于网络访问方法，帧格式 和 介质。换句话说，它独立于任何特定的网络技术。这样，<code>TCP/IP</code> 可以用于连接不同的网络类型，例如：以太网，令牌环，<code>X.25</code>，帧中继和异步传输模式（<code>ATM</code>）</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225104421093.png" alt="TCP/IP的封装格式" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E4%BC%A0%E8%BE%93%E5%B1%82">2.1 TCP/IP 网络模型有哪几层？ | 小林coding</a></p>
<hr>
<h3 id="IP-协议和-TCP-协议属于哪一层？"><a class="headerlink" href="#IP-协议和-TCP-协议属于哪一层？"></a>IP 协议和 TCP 协议属于哪一层？</h3>
<p>答：</p>
<p><code>IP</code> 协议属于 网络层，<code>TCP</code> 协议属于 传输层</p>
<hr>
<h3 id="网络为什么要分层？"><a class="headerlink" href="#网络为什么要分层？"></a>网络为什么要分层？</h3>
<p>答：</p>
<ul>
<li>分层的目的是 <strong>为了降低耦合，各层相互独立之后，上层可以不关心下层的实现，只关心下层提供的接口服务，有利于排查网络问题，能更精细定位问题所在哪一层</strong></li>
<li>分层之后层与层之间不会产生关联性，不会因为某个层的改动，影响了其他层
<ul>
<li>比如：应用层的 <code>HTTP</code> 协议，从 <code>HTTP1.1</code> 升级到 <code>HTTP2.0</code> 的时候，并不会对 传输层、网络层 等有影响，或者网络层的 <code>IPv4</code> 协议升级为 <code>IPv6</code> 协议的时候，也不会影响 应用层、传输层</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>分层的好处</strong>：
<ol>
<li><strong>各层之间是 独立的</strong>
<ul>
<li>某一层 并不需要知道它 下一层 是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个较容易处理的更小问题，这样，整个问题的复杂度就下降了</li>
</ul>
</li>
<li><strong>灵活性好</strong>
<ul>
<li>当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响此外，对某一层提供的服务还可以进行修改。当某层提供的服务不再需要时，甚至可以将这层取消</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="键入网址场景问题"><a class="headerlink" href="#键入网址场景问题"></a>键入网址场景问题</h2>
<hr>
<h3 id="输入网址后，期间发生了什么？"><a class="headerlink" href="#输入网址后，期间发生了什么？"></a>输入网址后，期间发生了什么？</h3>
<p>答：</p>
<p>在浏览器输入网址后：</p>
<ol>
<li>
<p><strong>浏览器会先解析 <code>URL</code>，解析出 域名、资源路径、端口 等信息，然后构造 <code>HTTP</code> 请求报文</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121808120.png" alt="URL组成" loading="lazy"></p>
</li>
<li>
<p><strong>接着进行 域名 解析，将 域名解析 为 <code>IP</code> 地址</strong>，会先查 系统缓存 是否 域名信息，如果有就返回 <code>IP</code> 地址，没有就会查看本地系统 <code>host</code> 文件有没有域名信息，如果有就返回 <code>IP</code> 地址，如果没有就去查本地 <code>DNS</code> 服务器，如果本地 <code>DNS</code> 服务器缓存中有域名信息，就返回 <code>IP</code> 地址，否则本地 <code>DNS</code> 服务器分别去 根域名服务器 → 顶级域名服务器 → 权威域名服务器询问，最后拿着返回的 <code>IP</code> 交给浏览器</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121950471.png" alt="DNS域名解析器关系图" loading="lazy"></p>
</li>
<li>
<p>由于 <code>HTTP</code> 是基于 <code>TCP</code> 传输的，所以 <strong>在发送 <code>HTTP</code> 请求前，要进行 三次握手</strong>，在客户端发送第一次握手的时候，<code>TCP</code> 头部会填上 <code>SYN</code> 标记位，同时填上 目标端口 和 源端口 的信息。源端口 是 浏览器随机生成的，目标端口要看是 <code>HTTP</code> 还是 <code>HTTPS</code>，如果是 <code>HTTP</code> 默认目标端口是 80，如果是 <code>HTTPS</code> 默认是 443</p>
</li>
<li>
<p>然后到 <strong>网络层</strong>，会加上 <code>IP</code> 头，同时填上 目标 <code>IP</code> 地址 和 源 <code>IP</code> 地址</p>
</li>
<li>
<p>然后到 <strong>数据链路层</strong>，会通过 <code>ARP</code> 协议，获取路由器的 <code>MAC</code> 地址，然后会加上 <code>MAC</code> 头，填上 目标<code>MAC</code>地址 和 源 <code>MAC</code> 地址</p>
</li>
<li>
<p>然后到 <strong>物理层</strong> 之后，直接把 数据包，转发给 路由器，路由器再通过下一跳，最终找到 目标服务器，然后目标服务器收到客户的 <code>SYN</code> 报文后，会响应第二次握手</p>
</li>
<li>
<p>当双方都 <strong>完成 三次握手 后</strong>，如果是 <code>HTTP</code> 协议，客户端就会将 <code>HTTP</code> 请求就会发送给目标服务器；如果是 <code>HTTPS</code> 协议，客户端 还要和 服务端 进行 <code>TLS</code> 四次握手之后，客户端才会将 <code>HTTP</code> 报文发送给目标服务器</p>
</li>
<li>
<p>目标服务器收到 <code>HTTP</code> 请求消息后，就返回 <code>HTTP</code> 响应消息，浏览器会对响应消息进行解析渲染，呈现给用户</p>
</li>
</ol>
<p><strong>补充</strong>：</p>
<p>关键要讲出输入网址后涉及的每一个网络协议的工作原理和作用：</p>
<ul>
<li><code>HTTP/HTTPS</code> 协议 → <code>DNS</code> 协议 → <code>TCP</code> 协议 → <code>IP</code>协议 → <code>ARP</code> 协议</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225121624353.png" alt="输入网址后的流程图" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-tcp">2.2 键入网址到网页显示，期间发生了什么？ | 小林coding</a></p>
<hr>
<h3 id="DNS-是如何解析的？属于哪一层的协议？"><a class="headerlink" href="#DNS-是如何解析的？属于哪一层的协议？"></a>DNS 是如何解析的？属于哪一层的协议？</h3>
<p>答：</p>
<ul>
<li><code>DNS</code> 属于 <strong>应用层</strong> 的协议
<ul>
<li>客户端在进行 <code>DNS</code> 解析之前，会先查看 浏览器 和 操作系统 是否有缓存域名对应的 <code>IP</code> 地址，没有就会查看本地系统 <code>host</code> 文件有没有域名信息，如果有就返回 <code>IP</code> 地址</li>
<li>如果没有就会向本地 <code>DNS</code> 服务器发出查询请求，如果没有接着本地 <code>DNS</code> 向 根 <code>DNS</code> 发送查询请求，根 <code>DNS</code> 服务器收到请求后会返回顶级域名服务器的 <code>IP</code> 地址，然后本地 <code>DNS</code> 服务器再向顶级域名服务器发出查询请求，顶级 <code>DNS</code> 服务器收到请求后会返回权威域名服务器的 <code>IP</code> 地址，然后本地 <code>DNS</code> 服务器再向 权威域名服务器 发出查询请求，权威域名服务器 收到请求后，就会返回域名对应的 <code>IP</code> 地址了，最后本地 <code>DNS</code> 服务器返回查询结果给客户端，同时本地域名服务器把返回的结果保存到缓存，以备下一次使用。客户端通过这个 <code>IP</code> 地址就可以访问目标 <code>Web</code> 服务器了。到这里，<code>DNS</code> 查询的整个过程就结束了</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225123358734.png" alt="具体流程" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://support.huaweicloud.com/productdesc-dns/zh-cn_topic_0035920135.html?utm_source=dns_Growth_map&amp;utm_medium=display&amp;utm_campaign=help_center&amp;utm_content=Growth_map">公网域名解析_云解析服务 DNS_华为云</a></p>
<hr>
<h3 id="DNS域名解析使用的什么协议？"><a class="headerlink" href="#DNS域名解析使用的什么协议？"></a>DNS域名解析使用的什么协议？</h3>
<p>答：</p>
<ul>
<li>在 <code>DNS</code> 中，域名解析 请求 和 响应 都是基于 <code>UDP</code> 进行传输的</li>
<li><code>UDP</code> 是一种 无连接 的 传输层协议，它提供了一种简单的传输机制，适用于对 实时性要求较高 的应用场景。<code>DNS</code> 使用 <code>UDP</code> 协议进行域名解析是因为 域名解析 通常是 短小而频繁 的请求，<code>UDP</code> 的无连接特性可以减少建立和断开连接的开销，并提高解析的效率（<code>UDP</code> 协议以及 <code>UDP</code>相较于 <code>TCP</code>的优点）</li>
<li><code>UDP</code> 对于 <code>TCP</code> 的缺点是没办法保证数据的可靠传输，针对这个缺陷，<strong>可以在应用层实现一个超时重传机制，如果域名解析请求在一定时间内没收到响应，那么就重发域名解析请求</strong>（<code>UDP</code> 不保证可靠性的缺点）</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6991611868867461157">DNS 协议是什么？完整查询过程？为什么选择使用 UDP 协议发起 DNS 查询？&gt; 你可能了解 DNS 协议是什么？那 - 掘金</a></p>
<hr>
<h3 id="输入域名如何知道端口的？"><a class="headerlink" href="#输入域名如何知道端口的？"></a>输入域名如何知道端口的？</h3>
<p>答：</p>
<p><code>HTTP</code> 默认端口是 80，<code>HTTPS</code> 默认端口是 443，如果用户指定了端口，比如：<code>域名:8080</code>，这时候就会使用<code>8080</code> 作为目标端口</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>http://baidu.com/</code>，默认端口是 <strong>80</strong></li>
<li><code>https://baidu.com/</code>，默认端口是 <strong>443</strong></li>
<li><code>http://baidu.com:8080/</code>，指定的端口是 <strong>8080</strong></li>
</ul>
<p><strong>详细链接</strong>：[11 你能写出正确的网址吗？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/11">https://learn.lianglianglee.com/专栏/透视HTTP协议/11</a>  你能写出正确的网址吗？.md)</p>
<hr>
<h3 id="客户端向服务端的-IP-地址发送数据，服务端如何确定应该把数据传递给谁？"><a class="headerlink" href="#客户端向服务端的-IP-地址发送数据，服务端如何确定应该把数据传递给谁？"></a>客户端向服务端的 IP 地址发送数据，服务端如何确定应该把数据传递给谁？</h3>
<p>答：</p>
<p>服务端的应用会监听端口，协议栈会通过端口来区分不同应用的数据</p>
<p><strong>补充</strong>：</p>
<p>每个传输层协议（如：<code>TCP</code> 和 <code>UDP</code>）都使用 端口号 来标识不同的应用程序或服务，服务端 通过 监听 特定的端口号来接收来自客户端的数据</p>
<hr>
<h3 id="现在很多网站都要求使用-https，假设我们输入一个-http-网址，网站是如何实现由-http-跳转到-https-的？"><a class="headerlink" href="#现在很多网站都要求使用-https，假设我们输入一个-http-网址，网站是如何实现由-http-跳转到-https-的？"></a>现在很多网站都要求使用 https，假设我们输入一个 http 网址，网站是如何实现由 http 跳转到 https 的？</h3>
<p>答：</p>
<ul>
<li>服务器网关收到 <code>http</code> 请求后，给客户端一个 <code>http</code> 响应，状态码为 <code>301</code>（永久重定向）</li>
<li>浏览器收到 重定向 响应后，自动向服务器发起一个新的 <code>HTTPS</code> 请求（默认端口 <code>443</code>）</li>
</ul>
<p><strong>补充</strong>：</p>
<p>网站实现由 <code>HTTP</code> 跳转到 <code>HTTPS</code> 的过程通常涉及 服务器端的配置，以确保用户访问的是 加密 的连接。以下是 <code>nginx</code> 服务器端配置方法，可以在虚拟主机的配置文件中添加以下代码来实现重定向：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name example.com;</span><br><span class="line">	return 301 https://$host$request uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="网络传输场景问题"><a class="headerlink" href="#网络传输场景问题"></a>网络传输场景问题</h2>
<hr>
<h3 id="如果浏览器没有显示页面有哪些原因？"><a class="headerlink" href="#如果浏览器没有显示页面有哪些原因？"></a>如果浏览器没有显示页面有哪些原因？</h3>
<p>答：</p>
<p>最直接的办法就是 <strong>抓包</strong>，排查的思路大概有：</p>
<ol>
<li><strong>先确定是 服务端 的问题，还是 客户端 的问题</strong>
<ul>
<li>先在 客户端 确认浏览器是否可以访问其他网站，如果不可以，说明客户端网络自身的问题，然后检查 客户端 网络配置（连接 <code>wifi</code> 正不正常，有没有插网线）</li>
<li>如果可以正常其他网页，说明 客户端 网络是可以正常上网的</li>
</ul>
</li>
<li><strong>如果 客户端 网络没问题，就抓包确认 <code>DNS</code> 是否解析出了 <code>IP</code> 地址，如果没有解析出来，说明域名写错了，如果解析出了 <code>IP</code> 地址，抓包确认有没有和服务端建立三次握手</strong>：
<ul>
<li>如果没有成功建立三次握手，需要在服务端通过 <code>ps</code> 确认 <code>server</code> 进程是否启动了，以及通过  <code>netstate</code> 命令确认是否监听了端口</li>
<li>如果能成功建立三次握手，并且发出了 <code>HTTP</code> 请求，但是就是没有显示页面，可以查看服务端返回的响应码：
<ul>
<li>如果是 <code>404</code> 错误码，检查输入的 <code>url</code> 是否正确</li>
<li>如果是 <code>500</code>，说明服务器此时有问题，这时候就需要去服务器排查日志了</li>
<li>如果是 <code>200</code>，可以在浏览器按 <code>F12</code> 输出前端控制台，看看前端代码有问题导致浏览器没有渲染出页面</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果 客户端 网络是正常的，但是访问速度很慢，导致很久才显示出来</strong>。可以通过 <code>ping</code> 去确认网络延迟是否正常，如果耗时很严重，可以排查服务器的流量是不是很大，导致超过了带宽上限，产生了丢包的问题。如果网络是正常的，可能要排查接口为什么处理这么久，这里有可能是慢 <code>sql</code> 导致的</li>
</ol>
<p>总之就 是一层一层有没有插网线，网络配置是否正确、<code>DNS</code> 有没有解析出 <code>IP</code> 地址、<code>TCP</code> 有没有三次握手、<code>HTTP</code> 返回的响应码是什么</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2dT9SlEhimW1conTVbZ8ZQ">字节一面：网站显示不出来，怎么排查？</a></p>
<hr>
<h3 id="服务器ping不通但是http能请求成功，会出现这种情况吗？"><a class="headerlink" href="#服务器ping不通但是http能请求成功，会出现这种情况吗？"></a>服务器ping不通但是http能请求成功，会出现这种情况吗？</h3>
<p>答：</p>
<ul>
<li>会的</li>
<li>因为 <code>ping</code> 和 <code>http</code> 使用的协议是不一样的，<code>ping</code> 是基于网络层的 <code>ICMP</code> 协议，而 <code>http</code> 是基于传输层的 <code>TCP</code> 协议的，有可能服务器的防火墙禁止 <code>ICMP</code> 协议，但是 <code>TCP</code> 协议没有禁止，就会出现服务器 <code>ping</code> 不通，但是 <code>http</code> 能请求现象</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>主要是 <code>ping</code> 和 <code>http</code> 底层的协议区别</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/4_ip/ping.html#%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B">5.2 ping 的工作原理 | 小林coding</a></p>
<hr>
<h3 id="客户端-TCP-连接一个不存在的-IP-地址的服务端会发生什么？（cold）"><a class="headerlink" href="#客户端-TCP-连接一个不存在的-IP-地址的服务端会发生什么？（cold）"></a>客户端 TCP 连接一个不存在的 IP 地址的服务端会发生什么？（cold）</h3>
<p>答：</p>
<ul>
<li>分情况讨论：
<ol>
<li>如果访问的 <code>IP</code> 地址是局域网内的，客户端的内核在发 <code>ARP</code> 请求的时候，广播询问这个目标 <code>IP</code> 地址是谁的，由于网络中不存在该目标 <code>IP</code> 地址，所以没有设备应答客户端的 <code>ARP</code> 请求，这时候就会卡在 <code>ARP</code> 协议，客户端的 <code>SYN</code> 报文是发送不出去的</li>
<li>如果访问的 <code>IP</code> 地址不是局域网的，客户端会先将 <code>SYN</code> 报文发给路由器，然后路由器会继续转发，由于目标 <code>IP</code> 地址是不存在的，该 <code>SYN</code> 报文会在网络中消亡，因此客户端是不会收到对 <code>SYN</code> 报文的确认报文的，接着客户端会触发超时重传，重传 <code>SYN</code> 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yLp6Z_00TsAwagbx_lEPXA">字节面试：连接一个不存在的 IP 地址，会发生什么？</a></p>
<hr>
<h3 id="客户端-TCP-连接一个-IP-地址存在但是端口不存在的服务端会发生什么？（cold）"><a class="headerlink" href="#客户端-TCP-连接一个-IP-地址存在但是端口不存在的服务端会发生什么？（cold）"></a>客户端 TCP 连接一个 IP 地址存在但是端口不存在的服务端会发生什么？（cold）</h3>
<p>答：</p>
<p>端口不存在的话，代表服务端没有监听这个端口，服务端在收到客户端的 <code>SYN</code> 报文后，服务端会回 <code>RST</code> 报文，客户端收到 <code>RST</code> 报文后，会断开连接</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225131324285.png" alt="举例" loading="lazy"></p>
<ul>
<li>如果客户端访问了没有被服务端监听的端口的话，服务端会回 <code>RST</code> 报文</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_no_listen.html">4.19 服务端没有 listen，客户端发起连接建立，会发生什么？ | 小林coding</a></p>
<hr>
<h3 id="客户端-UDP-发送一个-IP-地址存在但是端口不存在报文会发生什么？（cold）"><a class="headerlink" href="#客户端-UDP-发送一个-IP-地址存在但是端口不存在报文会发生什么？（cold）"></a>客户端 UDP 发送一个 IP 地址存在但是端口不存在报文会发生什么？（cold）</h3>
<p>答：</p>
<p>服务端会回 <code>ICMP</code> 报文，报告端口不可达</p>
<p><strong>补充</strong>：</p>
<p><code>UDP</code> 没有 <code>RST</code> 报文，所以如果端口不存在，这时候会在网络层通过 <code>ICMP</code> 协议，报告端口不可达的消息给客户端</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225131717841.png" alt="举例" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mrpre/article/details/43451775">关于UDP接收icmp端口不可达(port unreachable)_icmp port unreachable-CSDN博客</a></p>
<hr>
<h2 id="HTTP"><a class="headerlink" href="#HTTP"></a>HTTP</h2>
<hr>
<h3 id="HTTP-协议的特点是什么？"><a class="headerlink" href="#HTTP-协议的特点是什么？"></a>HTTP 协议的特点是什么？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 具有简单、灵活可扩展、无状态等特点，是一种广泛应用于 <code>Web</code> 通信的协议
<ol>
<li><strong>基于文本</strong>：<code>HTTP</code> 的消息是以 <strong>文本形式</strong> 传输，易于阅读和调试</li>
<li><strong>可扩展性</strong>：<code>HTTP</code> 协议本身不限制数据的内容和格式，可以通过 <strong>扩展头部、方法</strong> 等来支持新的功能</li>
<li><strong>灵活性</strong>：<code>HTTP</code> <strong>支持不同的数据格式</strong>（如：<code>HTML</code>、<code>JSON</code>、<code>XML</code> 等），适用于多种应用场景</li>
<li><strong>请求应答模式</strong>：<code>HTTP</code> 协议使用的是 <strong>请求 - 应答</strong> 通信模式，请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作</li>
<li><strong>无状态</strong>：<code>HTTP</code> <strong>每个请求之间相互独立</strong>，服务器不会保留之前请求的状态信息，需要通过其他手段（如：<code>Cookies</code>、<code>Session</code>）来维护状态</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 是 灵活可扩展 的，可以任意添加头字段实现任意功能</li>
<li><code>HTTP</code> 是可靠传输协议，基于 <code>TCP/IP</code> 协议 “尽量” 保证数据的送达</li>
<li><code>HTTP</code> 是应用层协议，比 <code>FTP</code>、<code>SSH</code> 等更通用功能更多，能够传输任意数据</li>
<li><code>HTTP</code> 使用了 请求 - 应答 模式，客户端主动发起请求，服务器被动回复请求</li>
<li><code>HTTP</code> 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<p><strong>详细链接</strong>：[13 HTTP有哪些特点？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/13">https://learn.lianglianglee.com/专栏/透视HTTP协议/13</a>  HTTP有哪些特点？.md)</p>
<hr>
<h3 id="HTTP-报文格式？怎么分割的？"><a class="headerlink" href="#HTTP-报文格式？怎么分割的？"></a>HTTP 报文格式？怎么分割的？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 报文格式分为 <strong>请求行</strong>、<strong>请求头</strong>、<strong>请求体</strong> 三个部分：
<ul>
<li><strong>请求行</strong> 是 <strong>请求或响应的基本信息</strong>，比如：请求方法、<code>URL</code>、<code>HTTP</code> 版本信息</li>
<li><strong>请求头</strong> 是 <strong>用 <code>key-value</code> 形式更详细地说明报文</strong>，比如：<code>Host</code> 字段、<code>Connection</code> 字段、<code>Content-Length</code>  字段</li>
<li><strong>请求体</strong> 是 <strong>实际传输的数据</strong>，比如：文本数据、图片数据</li>
</ul>
</li>
<li><strong>请求行</strong> 和 <strong>请求头</strong> 是<strong>通过 <code>\r\n</code> 分割</strong>的，<strong>请求头</strong> 和 <strong>请求体</strong> 之间是通过 空白行 分割的，也就是 <strong>两个连续的<code>\r\n</code></strong></li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 报文格式分为 请求行、请求头、请求体 三个部分
<ul>
<li>请求行的内容是 <code>HTTP</code> 方法、<code>URL</code>、<code>HTTP</code> 版本号，请求行里的字段之间是通过 空格 分割，请求行 和 请求头 是通过 <code>\r\n</code> 分割的</li>
<li>请求头 的 内容 是 多个键值对字段的集合，键 和 值 通过 冒号 分割，每个字段之间通过 <code>\r\n</code> 分割</li>
<li>请求体 的内容是 实体数据，请求头 和 请求体 之间是通过 空白行 分割的，即：两个连续的<code>\r\n</code>（回车符 + 换行符）</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225133744351.png" alt="HTTP报文格式" loading="lazy"></p>
<p><strong>详细链接</strong>：[09 HTTP报文是什么样子的？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/09">https://learn.lianglianglee.com/专栏/透视HTTP协议/09</a>  HTTP报文是什么样子的？.md)</p>
<hr>
<h3 id="HTTP-默认的端口是什么？"><a class="headerlink" href="#HTTP-默认的端口是什么？"></a>HTTP 默认的端口是什么？</h3>
<p>答：</p>
<p><code>80</code> 端口</p>
<p><strong>补充</strong>：</p>
<p>端口 是 <code>TCP</code> 的概念，针对 <code>HTTP</code> 协议，服务端默认是监听 <code>80</code> 端口，针对 <code>HTTPS</code> 协议，服务端默认是监听  <code>443</code> 端口</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wsg25/articles/9703730.html">HTTP、HTTPS常用的默认端口号 - 景寓6号 - 博客园</a></p>
<hr>
<h3 id="HTTP-有什么方法？"><a class="headerlink" href="#HTTP-有什么方法？"></a>HTTP 有什么方法？</h3>
<p>答：</p>
<ul>
<li>我了解到 <code>HTTP</code> 方法的有 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>HEAD</code>、<code>DELETE</code> 这些方法，其中：
<ul>
<li><code>GET</code> 方法是用来 <strong>请求从服务器获取资源的</strong></li>
<li><code>HEAD</code> 方法和 <code>GET</code> 方法类似，也是请求从服务器获取资源，但与 <code>GET</code> 请求不同的是，服务器不会返回请求的实体数据，<strong>只会传回响应头，也就是获取的是资源的 “元信息”</strong></li>
<li><code>POST</code> 方法是 <strong>用来向服务端提交数据，数据就放在报文的 <code>body</code> 里</strong></li>
<li><code>PUT</code> 方法和 <code>POST</code> 类似，也可以向服务器提交数据，<strong>区别在于 <code>POST</code> 是 “新增数据”，<code>PUT</code> 是 “更新数据”</strong></li>
<li><code>DELETE</code> 方法是用来 <strong>删除资源</strong></li>
</ul>
</li>
<li>在项目开发中，用的比较多是 <code>GET</code> 和 <code>POST</code> 请求</li>
</ul>
<p><strong>补充</strong>：</p>
<p>目前 <code>HTTP/1.1</code>规定的八种方法，单词必须是 大写 的形式</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225134528641.png" alt="HTTP/1.1 规定的八种方法" loading="lazy"></p>
<p><strong>详细链接</strong>：[10 应该如何理解请求方法？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/10">https://learn.lianglianglee.com/专栏/透视HTTP协议/10</a>  应该如何理解请求方法？.md)</p>
<hr>
<h3 id="分析一下哪些-HTTP-方法是安全或者幂等的？"><a class="headerlink" href="#分析一下哪些-HTTP-方法是安全或者幂等的？"></a>分析一下哪些 HTTP 方法是安全或者幂等的？</h3>
<p>答：</p>
<ul>
<li><code>GET</code> 和 <code>HEAD</code> 方法是 安全且幂等 的，因为它们是 只读 操作，只要开发者遵循规范要求的去处理请求，无论 <code>GET</code> 和 <code>HEAD</code> 操作多少次，服务器上的数据都是安全的</li>
<li><code>POST</code> / <code>PUT</code> / <code>DELETE</code> 这些方法都会 增上改服务器上的资源，所以是 不安全 的</li>
<li><code>DELETE</code> 和 <code>PUT</code> 方法是 幂等 的，因为 <code>DELETE</code> 是 删除资源，多次删除，效果都是资源不存在，所以也是 幂等 的，另一个 <code>PUT</code> 是 更新数据，多次更新数据，结果都一样，所以是 幂等 的</li>
<li>但是 <code>POST</code> 是不幂等的，因为多次 <code>POST</code> 请求，会创建多个资源，所以 不是幂等 的</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>在 <code>HTTP</code> 协议里：
<ul>
<li>所谓的 “<strong>安全</strong>” 是指：请求方法不会 “破坏” 服务器上的资源，即：<strong>不会对服务器上的资源造成实质的修改</strong></li>
<li>所谓的 “<strong>幂等</strong>” 实际上是一个数学用语，被借用到了 <code>HTTP</code> 协议里，意思是：<strong>多次执行相同的操作，结果也都是相同的，即：多次 “幂” 后结果 “相等”</strong></li>
</ul>
</li>
<li>分类：
<ul>
<li>安全的方法：<code>GET</code> / <code>HEAD</code></li>
<li>不安全的方法：<code>POST</code> / <code>DELETE</code> / <code>PUT</code></li>
<li>幂等的方法：<code>GET</code> / <code>HEAD</code> / <code>DELETE</code> / <code>PUT</code></li>
<li>不幂等的方法：<code>POST</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="GET-和-POST-请求的区别？"><a class="headerlink" href="#GET-和-POST-请求的区别？"></a>GET 和 POST 请求的区别？</h3>
<p>答：</p>
<ul>
<li><code>GET</code> 请求是 从服务器获取资源，<code>POST</code> 请求是 向服务器提交数据</li>
<li><code>GET</code> 方法是 只读 操作，所以是 安全且幂等 的，而 <code>POST</code> 方法会修改服务器上的资源，并且多次 <code>POST</code> 请求，会创建多个资源，所以 不是安全，也不是幂等 的</li>
<li><code>GET</code> 请求的请求参数放在 <code>URL</code> 中的查询字符串中，浏览器对 <code>URL</code> 长度限制，所以 <code>GET</code> 请求的请求参数会有长度限制，而 <code>POST</code> 请求的请求参数是放在请求体中，<code>POST</code> 请求的请求参数长度没有限制</li>
</ul>
<p><strong>补充</strong>：</p>
<p>从几个角度分析：</p>
<ol>
<li>两个请求的语义上的区别</li>
<li>两个请求的是否是安全且幂等的？</li>
<li>请求参数的区别</li>
</ol>
<h3 id="GET-请求一定是安全且幂等的吗？"><a class="headerlink" href="#GET-请求一定是安全且幂等的吗？"></a>GET 请求一定是安全且幂等的吗？</h3>
<p>答：</p>
<p><strong>不一定</strong>，要看实际的 <code>GET</code> 请求，如果 <strong>开发者遵循了规范去处理请求</strong>，也就是 <code>GET</code> 请求的实现是获取资源，那么就是安全且幂等的，但是 <strong>如果开发者处理 <code>GET</code> 请求的方式是 新增数据</strong>，这时候 <code>GET</code> 请求就 不是安全且幂等的</p>
<hr>
<h3 id="HTTP-有什么状态码？"><a class="headerlink" href="#HTTP-有什么状态码？"></a>HTTP 有什么状态码？</h3>
<p>答：</p>
<p><code>HTTP</code> 状态共有 <code>5</code> 类：</p>
<ul>
<li><strong>数字 <code>1</code> 开头的状态码</strong>：表示目前是 <strong>协议处理的中间状态</strong>，还需要后续操作，比如：客户端请求服务端从  <code>HTTP</code> 切换为 <code>WebSocket</code> 通信的时候，服务端如果同意切换，就会回 <code>101</code> 状态码</li>
<li><strong>数字 <code>2</code> 开头的状态码</strong>：表示 <strong>服务器收到并成功处理了客户端的请求</strong>，比如：<code>200</code> 状态码是代表 服务端 成功响应了 客户端 的请求</li>
<li><strong>数字 <code>3</code> 开头的状态码</strong>：表示 <strong>服务端的资源发生了变动</strong>，<strong>需要进行 重定向 了</strong>，比如：<code>301</code> 是代表永久重定向、<code>302</code> 代表临时重定向</li>
<li><strong>数字 <code>4</code> 开头的状态码</strong>：<strong>是 客户端错误，表示客户端发送的请求报文有误，服务器无法处理</strong>，比如：<code>404</code>  状态码表示资源在本服务器上未找到</li>
<li><strong>数字 <code>5</code> 开头的状态码</strong>：<strong>是 服务端错误，服务器在处理时内部发生了错误</strong>，比如：<code>502</code> 状态码是 <code>nginx</code> 服务器作为代理时返回的错误码，表示 <code>nginx</code> 服务器自身工作正常，但是访问后端服务器时发生了错误，具体的错误需要去排查后端服务器</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>100</code> 类状态码属于 <strong>提示信息，是协议处理中的一种中间状态，实际用到的比较少</strong>
<ul>
<li>“<code>101 Switching Protocols</code>”：<strong>请求者已要求服务器切换协议，服务器已确认并准备切换</strong>
<ul>
<li>它的意思是客户端使用 <code>Upgrade</code> 头字段，要求在 <code>HTTP</code> 协议的基础上改成其他的协议继续通信，比如：<code>WebSocket</code>。而如果服务器也同意变更协议，就会发送状态码 <code>101</code>，但这之后的数据传输就不会再使用 <code>HTTP</code> 了</li>
</ul>
</li>
</ul>
</li>
<li><code>200</code> 类状态码表示 <strong>服务器成功处理了客户端的请求</strong>
<ul>
<li>“<code>200 OK</code>”是 <strong>最常见的成功状态码</strong>：表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 <code>HEAD</code> 请求，通常在响应头后都会有 <code>body</code> 数据</li>
<li>“<code>204 No Content</code>” 是 <strong>另一个很常见的成功状态码</strong>，它的含义与 “<code>200 OK</code>” 基本相同，但响应头后没有 <code>body</code> 数据。所以对于 <code>Web</code> 服务器来说，正确地区分 <code>200</code> 和 <code>204</code> 是很必要的</li>
<li>“<code>206 Partial Content</code>” 是 <strong><code>HTTP</code> 分块下载或断点续传的基础</strong>，在客户端发送 “ 范围请求 ”、要求获取资源的部分数据时出现，它与 <code>200</code> 一样，也是服务器成功处理了请求，但 <code>body</code> 里的数据不是资源的全部，而是其中的一部分</li>
</ul>
</li>
<li><code>300</code> 类状态码表示 <strong>客户端请求的资源发生了变动，需要客户端用新的 <code>URL</code> 重新发送请求获取资源，也就是重定向</strong>
<ul>
<li>“ <code>301 Moved Permanently</code> ”：<strong>代表 永久性的重定向</strong>，值得注意的是，这种重定向跳转，从严格意义来讲不是服务器跳转，而是客户端跳转的。这个 “ 跳 ” 的动作是服务器是通过回传状态码 <code>301</code> 来下达给客户端的，让客户端完成跳转</li>
<li>“ <code>302 Found</code> ”：<strong>代表 临时跳转</strong>。例如：<code>URL</code> 地址 A 可以向 <code>URL</code> 地址 B 上跳转，但这并不是永久性的，在经过一段时间后，<code>URL</code> 地址 A 还可能向 <code>URL</code> 地址 C 上跳转</li>
<li>“ <code>304 Not Modified</code> ”：<strong>服务器通过返回状态码 <code>304</code> 可以告诉客户端请求资源成功</strong>，但是这个资源不是由服务器提供返回给客户端的，而是客户端本地浏览器缓存中就有的这个资源，因为可以从缓存中获取这个资源，从而节省传输的开销</li>
</ul>
</li>
<li><code>400</code> 类状态码表示 <strong>客户端发送的报文有误，服务器无法处理</strong>
<ul>
<li>“ <code>400 Bad Request</code> ”：表示 <strong>请求报文有错误</strong>，但具体是数据格式错误、缺少请求头还是 <code>URI</code> 超长它没有明确说，只是一个笼统的错误，客户端看到 <code>400</code> 只会是 “ 一头雾水 ”、“不知所措”</li>
<li>“ <code>403 Forbidden</code> ”：代表 <strong>请求的服务器资源权限不够</strong>，也就是没有权限去访问服务器的资源，或者请求的 <code>IP</code> 地址被封掉了</li>
<li>“ <code>404 Not Found</code> ”：代表 <strong>服务器上没有该资源</strong>，或者说服务器找不到客户端请求的资源，是最常见的请求错误码</li>
</ul>
</li>
<li><code>500</code> 类状态码表示 <strong>客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码</strong>
<ul>
<li>“ <code>500 Internal Server Error</code> ”：代表 <strong>服务器程序错误，也就是说请求的网页程序本身报错了</strong>。在服务器端的网页程序出错。由于现在的浏览器都会对状态码 <code>500</code> 做一定的处理，所以在一般情况下会返回一个定制的错误页面</li>
<li>“ <code>501 Not Implemented</code> ”：<strong>服务器不具备完成请求的功能</strong>。 例如：服务器无法识别请求方法时可能会返回此代码。</li>
<li>“ <code>502 Bad Gateway</code> ”：<strong>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</strong></li>
<li>“ <code>503 Service Unavailable</code> ”：<strong>表示服务器当前很忙，暂时无法响应客户端</strong>。我们上网时有时候遇到的 “网络服务正忙，请稍后重试” 的提示信息就是状态码 <code>503</code></li>
<li>“ <code>504 Gateway Timeout</code> ”：<strong>服务器作为网关或代理，但是没有及时从上游服务器收到请求</strong></li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225150709886.png" alt="HTTP状态码五大类" loading="lazy"></p>
<p><strong>详细链接</strong>：[12 响应状态码该怎么用？](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/12">https://learn.lianglianglee.com/专栏/透视HTTP协议/12</a>  响应状态码该怎么用？.md)</p>
<hr>
<h3 id="什么情况下会出现502错误码呢？"><a class="headerlink" href="#什么情况下会出现502错误码呢？"></a>什么情况下会出现502错误码呢？</h3>
<p>答：</p>
<p>如果客户端访问服务器是通过 <code>Nginx</code> 来反向代理到应用服务器，那么如果应用服务器出现了故障，导致<code>Nginx</code> 无法从应用服务器获取到响应，这时候 <code>Nginx</code> 就会返回 <code>502</code> 错误码给客户端</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>502</code> （Bad Gateway）状态代码表示服务器在充当网关或代理时，在尝试满足请求时从它访问的入站服务器接收到无效响应</li>
<li>简单理解就是，<code>502</code> 其实是由 <strong>网关代理</strong>（<code>Nginx</code>）发出的，是因为 <strong>网关代理把客户端的请求转发给了服务端，但服务端却发出了无效响应，而这里的无效响应</strong>，一般是指 <code>TCP</code> 的 <code>RST</code> 报文或四次挥手的 <code>FIN</code> 报文
<ul>
<li><strong>屏蔽掉具体有哪些服务器的代理方式</strong> 就是所谓的 <strong>反向代理</strong></li>
<li>异常情况下，收发双方都不一定正常，连四次挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接：<code>RST</code> 一般用来异常地关闭一个连接，它是TCP包头中的一个标志位，在收到置这个标志位的数据包后，连接就会被关闭，此时接收到 <code>RST</code> 的一方，在应用层会看到一个 <code>connection reset</code> 或 <code>connection refused</code> 的报错</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225163323375.png" alt="FIN与Errors502" loading="lazy"></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225163442521.png" alt="RST与Errors502" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/722318.html">502问题怎么排查？你学会了吗？-502问题怎么解决</a></p>
<hr>
<h3 id="有个服务出现了504，你觉得这个服务是出了什么问题？"><a class="headerlink" href="#有个服务出现了504，你觉得这个服务是出了什么问题？"></a>有个服务出现了504，你觉得这个服务是出了什么问题？</h3>
<p>答：</p>
<p><code>504</code>是 <strong>网关超时错误</strong>，通常是 <strong><code>Nginx</code> 将请求代理到后端应用时，后端应用没有在规定的时间返回数据</strong>，需要开发检查下应用那块有什么耗时的操作，比如：<strong>是否出现了 <code>sql</code> 慢查询，接口是否发生死循环、死锁</strong> 等问题，然后后端服务器系统负载高不高</p>
<p><strong>链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9xSkSpQs-hzHJx7MumSEEg">面试又跪了，504 错误码是什么问题？</a></p>
<hr>
<h3 id="重定向是哪一类状态码？临时重定向和永久重定向有什么区别？"><a class="headerlink" href="#重定向是哪一类状态码？临时重定向和永久重定向有什么区别？"></a>重定向是哪一类状态码？临时重定向和永久重定向有什么区别？</h3>
<p>答：</p>
<ul>
<li>重定向 是数字 <code>3</code> 开头的状态码
<ul>
<li>客户端收到 <code>301</code> 状态码后，会记忆重定向后的 <code>URL</code> 地址，这样下一次访 <code>301</code> 状态码是代表<strong>永久重定向</strong>，问的时候，不需要访问旧 <code>URL</code>，直接跳转到新 <code>URL</code> 访问</li>
<li><code>302</code> 状态码代表 <strong>临时重定向</strong>，客户端收到 <code>302</code> 状态码后，不会记忆重定向后的 <code>URL</code> 地址，下一次访问的时候，还需要访问旧的 <code>URL</code>，再跳转访问新的 <code>URL</code></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>301</code> 永久重定向，浏览器会记住
<ul>
<li>假如：当你访问 <code>a.com</code> 时，永久重定向到了 <code>b.com</code>；那么下一次访问  <code>a.com</code> 时浏览器会直接跳转到 <code>b.com</code> 不会再请求 <code>a.com</code></li>
</ul>
</li>
<li><code>302</code> 临时重定向，浏览器不会记忆
<ul>
<li>假如：加入当你访问 <code>a.com</code> 时 临时重定向到了 <code>b.com</code>；那么下一次当你请求 <code>a.com</code> 时，浏览器还会先请求 <code>a.com</code> ，然后再重定向到 <code>b.com</code></li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110941264">重定向的理解301，302 - 知乎</a></p>
<hr>
<h3 id="HTTP-是长连接还是短连接？"><a class="headerlink" href="#HTTP-是长连接还是短连接？"></a>HTTP 是长连接还是短连接？</h3>
<p>答：</p>
<p><code>HTTP 1.0</code> 虽然支持长连接，但是 <strong>默认的连接行为是 短链接</strong>，从 <code>HTTP1.1</code> 版本之后，都是 <strong>默认长连接了</strong></p>
<p><strong>补充</strong>：</p>
<p>在 <code>HTTP 1.0</code> 中默认是关闭的，如果浏览器要开启 <code>Keep-Alive</code>，它必须在请求的包头中添加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接<br>
从 <code>HTTP 1.1</code> 开始， 就默认是开启了 <code>Keep-Alive</code>，如果要关闭 <code>Keep-Alive</code>，需要在 <code>HTTP</code> 请求的包头里添<br>
加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:close</span><br></pre></td></tr></table></figure>
<p>现在大多数浏览器都默认是使用 <code>HTTP/1.1</code>，所以 <code>Keep-Alive</code> 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了，<strong><code>HTTP</code> 长连接的优势是可以减少了 <code>TCP</code> 连接资源的开销</strong></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html#http-%E7%9A%84-keep-alive">4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding</a></p>
<hr>
<h3 id="HTTP-长连接和短连接的区别？"><a class="headerlink" href="#HTTP-长连接和短连接的区别？"></a>HTTP 长连接和短连接的区别？</h3>
<p>答：</p>
<ul>
<li><strong>短连接</strong>：每次通信请求都需要建立新的连接，请求完成后立即关闭连接。这样每次请求都需要建立连接和释放连接，会增加通信开销和延迟</li>
<li><strong>长连接</strong>：在通信过程中保持连接的持续性，多次请求可以共享同一个连接。在长连接中，客户端和服务器建立连接后可以进行多次请求和响应，减少了连接建立和释放的开销，提高了通信效率</li>
</ul>
<p><strong>补充</strong>：</p>
<p><strong>短连接</strong>：每次通信请求都需要建立新的连接，请求完成后立即关闭连接，下次请求还需要重新建立 <code>TCP</code> 连<br>
接</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225170142392.png" alt="短链接" loading="lazy"></p>
<p><strong>长连接</strong>：在通信过程中保持连接的持续性，多次请求可以共享同一个 <code>TCP</code> 连接</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225170330269.png" alt="长连接" loading="lazy"></p>
<hr>
<h3 id="HTTP-长连接有什么好处？"><a class="headerlink" href="#HTTP-长连接有什么好处？"></a>HTTP 长连接有什么好处？</h3>
<p>答：</p>
<p><strong>长连接 可以在一次 <code>TCP</code> 连接中可以发送和响应多个 <code>HTTP</code> 请求，可以减少了 <code>TCP</code> 连接资源创建和断开的开销</strong></p>
<p><strong>补充</strong>：</p>
<ul>
<li>短连接：在一次 <code>TCP</code> 连接中只能发送和响应一个 <code>HTTP</code> 请求，即：建立<code>TCP</code> → 请求资源 → 响应资源 → 释放连接</li>
<li>长连接：在一次 <code>TCP</code> 连接中可以发送和响应多个 <code>HTTP</code> 请求，即：建立TCP → 请求资源 → 响应资源 → 请求资源 → 响应资源 → 请求资源 → 响应资源 → 请求资源 → 响应资源 → …  → 释放连接</li>
</ul>
<hr>
<h3 id="HTTP-1-0-和-HTTP-1-1-的区别？"><a class="headerlink" href="#HTTP-1-0-和-HTTP-1-1-的区别？"></a>HTTP/1.0 和 HTTP/1.1 的区别？</h3>
<p>答：</p>
<ul>
<li><strong>长连接</strong>：<code>HTTP/1.1</code> 默认的连接行为是 <strong>长连接</strong>，而 <code>HTTP/1.0</code> 虽然也支持 长连接，但是默认是使用 <strong>短连接</strong></li>
<li><strong>请求管道化</strong>：<code>HTTP/1.1</code> 支持 <strong>请求管道传输</strong>（<code>pipline</code>）的方式，<code>HTTP/1.0</code> 不支持这个模式，<code>HTTP/1.0</code> <strong>请求和响应必须是串行的</strong>，当一个请求和它响应完成之后，才能发送下一个请求，而 <code>HTTP/1.1</code> 由于支持管道传输方式，因此可以并发发送 <code>HTTP</code> 请求，能够提高 <code>HTTP</code> 请求的效率，但是 <code>HTTP</code> 响应还是得按顺序响应，只有 <code>HTTP/2.0</code> 实现了 <code>HTTP</code> 请求和响应的并发传输的能力</li>
<li><strong><code>host</code> 字段</strong>：<strong>通过 <code>host</code> 头部字段，一个物理服务器可以承载多个域名或站点</strong>
<ul>
<li><code>HTTP/1.0</code> 没有 <code>host</code> 字段，<code>HTTP/1.1</code> 新增了 <code>host</code> 字段</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP/1.0</code> 和 <code>HTTP/1.1</code> 两者的主要区别体现在：</p>
<ul>
<li>
<p><strong>长连接</strong>：在 <code>HTTP/1.0</code> 中，默认使用的是短连接，也就是每次请求都要重新建立一次连接。<code>HTTP</code> 是基于<code>TCP/IP</code> 协议的，每一次建立或者断开连接，都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大，因此最好能维持一个长连接，可以用长连接来发多个请求。<code>HTTP 1.1</code> 起，默认使用长连接 <code>connection:keep-alive</code></p>
</li>
<li>
<p><strong>请求管道化</strong>：<code>HTTP 1.1</code> 支持<strong>请求管道化，即：在一个持久连接上可以同时发送多个请求</strong>，而 <code>HTTP 1.0</code> 不支持请求管道化，<code>HTTP/1.0</code> 请求和响应必须是串行的，当一个请求和它响应完成之后，才能发送下一个请求，而 <code>HTTP/1.1</code> 由于支持管道传输方式，因此可以并发发送 <code>HTTP</code> 请求，能够提高 <code>HTTP</code> 请求的效率</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225171615799.png" alt="请求管道化" loading="lazy"></p>
</li>
<li>
<p><strong><code>Host</code>头字段</strong>：<code>HTTP/1.0</code> 没有 <code>host</code> 字段，<code>HTTP/1.1</code> 新增了 <code>host</code> 字段，通过 <code>Host</code> 头部字段，一个物理服务器可以承载多个域名或站点</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241225171807127.png" alt="Host头字段" loading="lazy"></p>
</li>
<li>
<p><strong>错误响应码</strong>：在 <code>HTTP 1.1</code> 中，新增了 <code>24</code> 个错误状态响应码</p>
<ul>
<li>例如： <code>409</code>（Conflict）：表示请求的资源与资源的当前状态发生冲突</li>
<li><code>410</code>（Gone）：表示服务器上的某个资源被永久性的删除</li>
</ul>
</li>
<li>
<p><strong>缓存处理</strong>：<code>HTTP 1.0</code> 中，主要使用 <code>header</code> 头里的 <code>If-Modified-since</code>、<code>Expires</code> 来做为缓存判断<br>
的标准；<code>HTTP 1.1</code>，则引入了更多的缓存控制策略，如：<code>Entity tag</code>、<code>If-Unmodified-since</code>、<code>If-Match</code>、<code>If-None-Match</code>等</p>
</li>
<li>
<p><strong>带宽优化及网络连接的使用</strong>：<code>HTTP 1.0</code> 中，存在一些浪费带宽的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象传送了过来，并且不支持断点续传功能；<code>HTTP 1.1</code> 中，则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206</code>（Partial Content），这样方便开发者自由的选择，以便于充分利用带宽和连接</p>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/717215.html">阿里一面：HTTP 1.0 和 HTTP 1.1 有什么区别？-51CTO.COM</a></p>
<hr>
<h3 id="HTTP-1-1-和-HTTP-2-0-的区别？"><a class="headerlink" href="#HTTP-1-1-和-HTTP-2-0-的区别？"></a>HTTP/1.1 和 HTTP/2.0 的区别？</h3>
<p>答：</p>
<ul>
<li>我认为 <code>HTTP/1.1</code> 和 <code>HTTP/2.0</code> 最大的区别在于：
<ul>
<li><strong><code>HTTP/1.1</code> 无法实现请求和响应的并发传输，而<code>HTTP/2.0</code>  能够实现请求和响应的并发传输</strong>
<ul>
<li><strong>原因</strong>：<code>HTTP/1.1</code> 虽然支持了管道化请求模式，能够并发传输 <code>HTTP</code> 请求，但是 <code>HTTP</code> 响应还是需要按顺序返回，无法做到 <code>HTTP</code> 响应并发传输。<code>HTTP/2.0</code> 引入了 <code>stream</code> 的概念，不同的 <code>HTTP</code> 请求和响用不同的 <code>stream</code> 来区分，多个 <code>stream</code> 复用一条 <code>TCP</code> 连接，只需要一条连接就可以达到了并发传输的效果</li>
</ul>
</li>
<li><strong><code>HTTP2.0</code> 在 <code>HTTP</code> 报文格式上也做了改进，<code>HTTP2.0</code> 用了 <code>HPACK</code> 算法压缩了 <code>HTTP</code> 头部，同时将<code>HTTP/1.1</code> 纯文本的格式改进成了二进制格式，提高了数据传输的效率。<code>HTTP2.0</code> 还支持服务器主动推送资源</strong>，比如：客户端在从服务器获取 <code>HTML</code> 文件时，可能这个页面渲染还需要其他 <code>CSS</code>，这时候服务器可以接主动推送 <code>CSS</code> 文件，可以减少了消息传递的次数</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP/2.0</code> 相比 <code>HTTP/1.1</code> 性能上的改进：</p>
<ol>
<li><strong>并发传输</strong>（最重要的区别）</li>
<li><strong>头部压缩 + 二进制格式</strong></li>
<li><strong>服务器主动推送资源</strong></li>
</ol>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http2.html">3.6 HTTP/2 牛逼在哪？ | 小林coding</a></p>
<hr>
<h3 id="HTTP-2-0-和-HTTP-3-0-的区别？"><a class="headerlink" href="#HTTP-2-0-和-HTTP-3-0-的区别？"></a>HTTP/2.0 和 HTTP/3.0 的区别？</h3>
<p>答：</p>
<ul>
<li><strong><code>HTTP 2.0</code> 和 <code>3.0</code> 最大区别</strong>：<strong>传输层使用的协议不同</strong>。<strong>以往 <code>HTTP</code> 都是基于 <code>TCP</code> 协议进行传输，这次<code>HTTP3.0</code> 改用 <code>UDP</code> 协议</strong>
<ul>
<li><code>HTTP/2.0</code> 并发传输的特性，是在一条 <code>TCP</code> 连接上实现的这里会有 <code>TCP</code> 队头阻塞的问题，在传输过程中，假设：某个 <code>stream</code> 发生了丢包，服务端不仅不能处理这个<code>stream</code>，也不能处理其他 <code>stream</code>，必须等这个包重传了，才能继续处理其他 <code>stream</code></li>
<li>为了解决这个问题 <code>HTTP/3.0</code> 将传输层改用 <code>UDP</code> 协议，并在 <code>UDP</code> 基础上实现了一个可靠传输的 <code>QUIC</code> 协议，当某个流发生丢包时，只会阻塞这个 <code>stream</code> ，其他 <code>stream</code> 不会受到影响，因此不存在队头阻塞问题</li>
</ul>
</li>
<li>除此之外：
<ul>
<li><code>HTTP/3.0</code> 连接建立方面比 <code>HTTP/2.0</code> 更高效，<code>HTTP/2.0</code> 建立连接的时候需要 <code>3</code> 次 <code>TCP</code> 握手 + <code>TLS</code> 四次握手，而 <code>HTTP3.0</code> 的 <code>QUIC</code> 协议只需要 <code>3</code> 次握手就能完成连接建立（包括 <code>TLS</code> 握手建立）</li>
<li>最后还有一点，<strong><code>HTTP/3.0</code> 在网络环境切换的过程，可以不需要重新建立连接</strong>。以往 <code>HTTP</code> 都是基于 <code>TCP</code> 协议进行传输，<code>TCP</code> 是根据 四元组信息 唯一确认一条连接，如果 四元组信息 某一个信息发生变化了，这时候就需要断开连接，重新建立连接，比如：<code>4G</code> 网络切换到 <code>WIFI</code> 网络的时候，所有的 <code>TCP</code> 连接都需要重新建立，<strong>而 <code>HTTP/3.0</code> 是在应用层通过连接 <code>ID</code> 来唯一确认连接的，即使网络发生切换，也不会影响原本的连接，消除重连的成本</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>先提出 <code>HTTP 2.0</code> 的缺陷，存在 <code>TCP</code> 队头阻塞问题,，然后再提 <code>HTTP/3.0</code> 是怎么解决的，最后再提 <code>HTTP3.0</code> 还有什么新特性</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http3.html#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">3.7 HTTP/3 强势来袭 | 小林coding</a></p>
<hr>
<h3 id="HTTP-是无状态的吗？"><a class="headerlink" href="#HTTP-是无状态的吗？"></a>HTTP 是无状态的吗？</h3>
<p>答：</p>
<p>是的，<code>HTTP</code> 是无状态的，一般我们会通过 <code>Cookie</code>、<code>Session</code>、<code>Token</code> 这些机制来维护用户的状态</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>HTTP</code> 是 <strong>无状态</strong> 的，这意味着 <strong>每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息，在每个 <code>HTTP</code> 请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的</strong></li>
<li>因此 <strong>服务器不知道请求两次之间是否是同一个用户</strong>。这会带来一个问题，用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的，每次进行页面跳转的时候，得重新登录</li>
<li>虽然 <code>HTTP</code> 本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是：使用 <code>Cookie</code>、<code>Session</code>、<code>Token</code> 来跟踪用户状态。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能</li>
</ul>
<hr>
<h3 id="HTTP-用户后续的操作，服务端如何知道属于同一个用户？"><a class="headerlink" href="#HTTP-用户后续的操作，服务端如何知道属于同一个用户？"></a>HTTP 用户后续的操作，服务端如何知道属于同一个用户？</h3>
<h3 id="如果服务端是一个集群机器？"><a class="headerlink" href="#如果服务端是一个集群机器？"></a>如果服务端是一个集群机器？</h3>
<p>答：</p>
<p><strong>问题1</strong>：</p>
<ul>
<li>可以使用 <code>Session</code> <code>Cookie</code> 的机制 ，达到身份识别的效果</li>
<li>比如：我用 账号 和 密码 登录某电商，登录成功后，网站服务器会校验 用户 和 密码，如果没问题，网站服务器就会生成一个唯一 <code>session id</code> 来标识我，然后将该 <code>session id</code> 设置到 <code>Cookie</code> 中发送给客户端，客户端再次访问网站时，会将该 <code>Cookie</code> 发送给服务器，服务器通过 <code>Cookie</code> 中的 <code>Session ID</code> 可以获取用户之前的状态信息，免去了重复登录的麻烦，实现了状态保持</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>HTTP</code> 是 无状态 的，可以通过 <code>Session</code> <code>Cookie</code> 机制保持用户登陆的状态</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226140419599.png" alt="image-20241226140419599" loading="lazy"></p>
<ol>
<li>用户 向 服务器 发送 用户名 和 密码</li>
<li>服务器验证通过后，在当前对话（<code>session</code>）里面保存相关数据，比如：用户角色、登录时间等等</li>
<li>服务器向用户返回一个 <code>session id</code>，写入用户的 <code>Cookie</code>（响应头字段 <code>Set-Cookie=session id</code>）</li>
<li>用户随后的每一次请求，都会通过 <code>Cookie</code>（请求头字段 <code>Cookie</code>），将 <code>session id</code> 传回服务器</li>
<li>服务器收到 <code>session id</code>，找到前期保存的数据，由此得知用户的身份</li>
</ol>
<p><strong>问题2</strong>：</p>
<ul>
<li>如果服务端是一个 <strong>集群机器</strong> 的话， 可以用一台 <code>Redis</code> 来保存 <code>session</code> 数据，达到共享 <code>session</code> 的效果，不过这种方案存在 <strong>单点 的问题</strong>，如果 <code>Redis</code> 挂了，可能所有用户登陆状态都会消失了，虽然可以通过搭建 <code>Redis</code> 集群来保证避免 单点 问题，但是我觉得这个方案成本太高了</li>
<li>一种比较低的解决成本方案是，不用 <code>session</code>，而是改用 <code>JWT</code> 来实现用户凭证会比较好，<strong>因为 <code>JWT</code> 的状态信息是保存在客户端的，服务端不再保存状态信息，天然适合分布式系统</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>seesion</code> 这种方式扩展性不好，因为 <code>session</code> 状态信息是保存在服务器内存的，如果服务器是 集群，就要求 <code>session</code> 数据共享到每一台服务器，否则会出问题，比如：客户端登陆后，如果有一台服务器的内存没有 <code>session id</code> 的状态信息，当客户端请求到这台服务器后，服务器发现 <code>session id</code> 的状态信息不存在，就会让客户端重新进行用户登陆</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226140944417.png" alt="Session集群复制" loading="lazy"></p>
</li>
<li>
<p><strong>解决方案</strong>：</p>
<ul>
<li>
<p><strong>第一种方案</strong>：<strong>将 <code>session id</code> 集中保存在 <code>redis</code> 或者 <code>MySQL</code></strong>，服务器集群通过判断 <code>session id</code> 的状态信息在不在 <code>redis</code> 或者 <code>MySQL</code>，来确定用户是否已经登陆</p>
</li>
<li>
<p>这种方案的缺陷是 单点故障 的问题（虽然也可以对 <code>redis</code> 搭建集群，但是架构的成本太高了）</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226141154038.png" alt="解决方案一" loading="lazy"></p>
</li>
<li>
<p><strong>第二种方案</strong>：服务器索性不保存 <code>session</code> 数据了，把状态信息保存在客户端，每次请求都发回服务器，这个就是 <strong><code>token</code> 机制</strong>，为了保证 <code>token</code> 不被中间人篡改，可以 <strong>使用 <code>JWT</code> 的方式来进行身份识别</strong>，通常分布式系统都是采用 <code>JWT</code> 来进行身份状态识别</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226141418256.png" alt="JWT认证" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html#cookie-session">凭证 | 凤凰架构</a></p>
<hr>
<h3 id="如果禁用-Cookie，怎么实现-Session？"><a class="headerlink" href="#如果禁用-Cookie，怎么实现-Session？"></a>如果禁用 Cookie，怎么实现 Session？</h3>
<p>答：</p>
<p>可以通过重写 <code>URL</code> 来实现 <code>Session</code> 机制，就是在 <code>URL</code> 中增加 <code>session id</code> 请求参数</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>禁用 <code>Cookie</code> 代表无法使用响应头无法使用 <code>Set-Cookie</code> 字段，以及请求头无法使用 <code>Cookie</code> 字段，这时候就没办法通过 <code>HTTP</code> <code>Cookie</code> 传输 <code>Session id</code> 了</p>
</li>
<li>
<p>这时候可以重写 <code>URL</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始的URL: http://taobao.com/getitem?name=baymax&amp;action=buy</span><br><span class="line">重写后的uRL:http://taobao.com/getitem?sessionid=1wui87htentg&amp;name=baymax&amp;action=buy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="cookie-和-session-的区别？"><a class="headerlink" href="#cookie-和-session-的区别？"></a>cookie 和 session 的区别？</h3>
<p>答：</p>
<ul>
<li><strong>存储位置</strong>：<code>Cookie</code> 存储在<strong>浏览器</strong>，<code>Session</code> 存储在<strong>服务端</strong></li>
<li><strong>存储大小</strong>：<code>Cookie</code> 是存储在浏览器的，浏览器对单个 <code>Cookie</code> 存储大小有限制的，限制保存的数据不能超过 <code>4K</code>，而 <code>Session</code> 是存储在服务端的，所以没有这个限制</li>
<li><strong>安全性</strong>：<code>Cookie</code> 存储在客户端，比较容易遭到不法获取，会容易遭到 <code>XSS</code> 和 <code>CSRF</code> 的攻击，而 <code>Session</code>  存储在服务端，安全性相对 <code>Cookie</code> 要好一些</li>
<li><strong>有效期</strong>：<code>Cookie</code> 可设置为长时间保持，比如：经常使用的默认登录功能，<code>Session</code> 一般失效时间较短，客户端关闭或者 <code>Session</code> 超时都会失效</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>Cookie</code> 是 <strong>服务器 发送到 用户浏览器 并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>
<ul>
<li>通常，它用于 <strong>告知服务器两个请求是否来自同一浏览器</strong>。如：保持用户的登录状态，<code>Cookie</code> 使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能</li>
</ul>
</li>
<li><code>Session</code> 代表着 <strong>服务器 和 客户端 一次会话的过程</strong>。<code>Session</code> 对象存储 特定用户会话 所需的属性及配置信息。这样，当用户在应用程序的 <code>Web</code> 页之间跳转时，存储在 <code>Session</code> 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 <code>Session</code> 超时失效时会话结束</li>
<li><code>Cookie</code> 和 <code>Session</code> 都是 <code>Web</code> 开发中用于跟踪用户状态的技术，但它们在 <strong>存储位置、存储大小、安全性、生命周期</strong> 等方面存在显著差异：</li>
<li><strong>存储位置</strong>：
<ul>
<li><code>Cookie</code> 的数据存储在客户端（通常是浏览器）。当 浏览器 向 服务器 发送请求时，会自动附带 <code>Cookie</code> 中的数据</li>
<li><code>Session</code> 的数据存储在服务器端。服务器为每个用户分配一个唯一的 <code>Session ID</code>，这个 <code>ID</code> 通常通过 <code>Cookie</code> 或 <code>URL</code> 重写的方式发送给客户端，客户端后续的请求会带上这个 <code>Session ID</code>，服务器根据 <code>ID</code> 查找对应的 <code>Session</code> 数据</li>
</ul>
</li>
<li><strong>存储大小</strong>：
<ul>
<li>单个 <code>Cookie</code> 的大小限制通常在 <code>4KB</code> 左右，而且大多数浏览器对每个域名的总 <code>Cookie</code> 数量也有限制</li>
<li>由于 <code>Session</code> 存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小</li>
</ul>
</li>
<li><strong>安全性</strong>：
<ul>
<li><code>Cookie</code> 相对不安全，因为数据存储在客户端，容易受到 <code>XSS</code>（跨站脚本攻击）的威胁。不过，可以通过设置 <code>HttpOnly</code> 属性来防止 <code>JavaScript</code> 访问，减少 <code>XSS</code> 攻击的风险，但仍然可能受到<code>CSRF</code>（跨站请求伪造）的攻击</li>
<li><code>Session</code> 通常认为比 <code>Cookie</code> 更安全，因为敏感数据存储在服务器端。但仍然需要防范 <code>Session</code> 劫持（通过获取他人的<code>Session ID</code>）和会话固定攻击。</li>
</ul>
</li>
<li><strong>生命周期</strong>：
<ul>
<li><code>Cookie</code> 可以设置过期时间，过期后自动删除。也可以设置为会话 <code>Cookie</code>，即：浏览器关闭时自动删除</li>
<li><code>Session</code> 在默认情况下，当用户关闭浏览器时，<code>Session</code> 结束。但服务器也可以设置 <code>Session</code> 的超时时间，超过这个时间未活动，<code>Session</code>也会失效</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Cookie、session-和-Token-有什么区别？"><a class="headerlink" href="#Cookie、session-和-Token-有什么区别？"></a>Cookie、session 和 Token 有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>存储位置不同</strong>：
<ul>
<li><code>Cookie</code> <strong>存储在 客户端</strong>，即：浏览器中的文本文件，通过在 <code>HTTP</code> 头中传递给服务器来进行通信</li>
<li><code>Session</code> 是 <strong>服务器端 的存储方式</strong>，通常存储在服务器的内存或数据库中</li>
<li><code>Token</code> 也是<strong>存储在 客户端</strong>，但是通常以加密的方式存储在客户端的 <code>localStorage</code> 或 <code>sessionStorage</code> 中</li>
</ul>
</li>
<li><strong>数据安全性不同</strong>：
<ul>
<li><code>Cookie</code> <strong>存储在 客户端</strong>，可能会被窃取或篡改，因此对敏感信息的存储需要进行加密处理</li>
<li><code>Session</code> <strong>存储在 服务器端</strong>，通过一个 <code>Session ID</code> 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露</li>
<li><code>Token</code> 通常<strong>使用 加密算法 生成</strong>，有效期较短且单向不可逆，可以提供较高的安全性</li>
</ul>
</li>
<li><strong>跨域支持不同</strong>：
<ul>
<li>为了防止安全事故，因此 <code>Cookie</code> 是不支持跨域传输的，也就是<strong>不同域名下的 <code>Cookie</code> 是不能相互访问</strong></li>
<li><code>Session</code> 机制通常是通过 <code>Cookie</code> 来保存 <code>Session ID</code> 的，<strong>因此 <code>Session ID</code> 默认情况下也是不支持跨域的</strong></li>
<li>但 <code>Token</code> 可以轻松实现跨域，因为 <code>Token</code> 是存储在客户端的 <code>localStorage</code> 或者作为请求头的一部分发送到服务器的，所以<strong>不同的域名 <code>Token</code> 信息传输通常是不受影响的</strong></li>
</ul>
</li>
<li><strong>状态管理不同：</strong>
<ul>
<li><code>Cookie</code> 是应用程序通过在客户端存储临时数据，用于实现状态管理的一种机制</li>
<li><code>Session</code> 是服务器端记录用户状态的方式，服务器会为每个会话分配一个唯一的 <code>Session ID</code>，并将其与用户状态相关联</li>
<li><code>Token</code> 是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>Cookie</code>、<code>Session</code> 和 <code>Token</code> 通常都是用来保存用户登录信息的技术，但三者有很大的区别，简单来说：<code>Cookie</code> 适用于 简单的状态 管理，<code>Session</code> 适用于 需要保护用户敏感信息的场景，而 <code>Token</code> 适用于 状态无关的身份验证和授权</p>
<hr>
<h3 id="简述-JWT-的原理和校验机制？"><a class="headerlink" href="#简述-JWT-的原理和校验机制？"></a>简述 JWT 的原理和校验机制？</h3>
<p>答：</p>
<ul>
<li><code>JWT</code> 令牌是由 3 个部分组成，分别是：<strong>头部、负载、签名</strong>
<ul>
<li><strong>头部：描述令牌使用的签名算法，负载：描述的是用户信息</strong>，比如：用户名称、过期时间等等</li>
<li><strong>头部</strong> 和 <strong>负载</strong> 都是 <strong>不会被加密</strong> 的，只是会用 <code>base64</code> 编码</li>
<li><strong>最后一部分是 签名</strong>，<strong>是对 头部 和 负载 两部分数据的签名</strong>，<strong>签名的过程是，使用 头部 的签名算法，通过 服务器的密钥 对 前面两部分 内容进行 加密 计算</strong></li>
</ul>
</li>
<li><strong>校验 <code>JWT</code> 令牌的过程</strong>：
<ul>
<li>服务端 收到 客户端 发过来的 <code>JWT</code> 令牌后，服务端 会取出 头部 和 负载 数据，然后用自己的 密钥 对 这两部分数据 进行 加密 计算，将得到的 加密结果 和 客户端 发过来 <code>JWT</code> 的签名进行对比</li>
<li>如果相同，就表示前面两部分没有被中间人篡改，这时候服务器就可以进行其他验证，比如：检查 <code>JWT</code> 是否过期，如果也没问题，就会正常执行业务逻辑</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226152441440.png" alt="JWT令牌" loading="lazy"></p>
<ul>
<li>左边的字符串呈现了 <code>JWT</code> 令牌的本体，右边的 <code>JSON</code> 结构是 <code>JWT</code> 令牌中携带的信息</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226152604782.png" alt="JWT格式" loading="lazy"></p>
<ul>
<li>
<p><code>JWT</code> 格式是 <code>header.payload.signature</code></p>
</li>
<li>
<p><code>JWT</code> 共由 3 个部分信息组成：</p>
<ul>
<li>
<p><code>Header</code>（头部）：描述了 <strong>令牌的类型</strong>（统一为 <code>type:JWT</code>）以及 <strong>令牌签名的算法</strong>（默认 <code>HMACSHA256</code> 算法），<code>header</code> 信息不做加密，只做一般的 <code>base64</code> 编码，目的是替换 <code>URL</code> 里面有特殊含义</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153256258.png" alt="Header头部" loading="lazy"></p>
</li>
<li>
<p><code>Payload</code>（负载）：这是 <strong>令牌真正需要向服务端传递的信息</strong>。针对 认证 问题，负载至少应该包含能够告知服务端 “这个用户是谁” 的信息，<code>JWT</code> 的负载部分是可以完全自定义的，根据具体要解决的问题不同，设计自己所需要的信息。<code>Payload</code> 信息不做加密，只做一般的 <code>base64</code> 编码，目的是替换 <code>URL</code> 里面有特殊含义</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153314524.png" alt="Payload负载" loading="lazy"></p>
</li>
<li>
<p><code>Signature</code>（签名）：<strong>是对前两部分的签名，防止数据篡改</strong>。签名的意思是：使用在 <code>Header</code> 中公开的特定签名算法，通过特定的密钥（<code>Secret</code>，由服务器进行保密，不能公开）对前面两部分内容进行加密计算</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226153615889.png" alt="Signature签名" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p><strong>验证 <code>JWT</code> 令牌的流程</strong>：</p>
<ol>
<li>服务端 收到 客户端 发过来 <code>JWT</code> 令牌之后，取出 <code>header + payload</code>，然后 服务端 根据自己的加密密钥进行加密计算</li>
<li>然后把 加密 的结果和 客户端 发过来 <code>JWT</code> 的 <code>signature</code> 进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了</li>
<li>当令牌验证为没有被篡改后，服务器可以进行其他验证，比如：是否过期、用户是否有权限访问 等等</li>
</ol>
</li>
</ul>
<hr>
<h3 id="JWT-令牌为什么能解决集群部署？"><a class="headerlink" href="#JWT-令牌为什么能解决集群部署？"></a>JWT 令牌为什么能解决集群部署？</h3>
<p>答：</p>
<p><code>JWT</code> 包含 身份验证 和 会话信息，可以让服务器无需存储会话信息，就让服务器成为无状态的了，从而比较容易实现扩展</p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>JWT</code> 令牌通过在令牌中包含所有必要的 身份验证 和 会话信息，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。<strong>当用户进行登录认证后，服务器将生成一个 <code>JWT</code> 令牌并返回给客户端。客户端在后续的请求中携带该令牌，服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息，而无需访问共享的会话存储</strong></li>
<li>由于 <code>JWT</code> 令牌是自包含的，服务器可以独立地对令牌进行验证，而不需要依赖其他服务器或共享存储</li>
<li>这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和容错性</li>
</ul>
<hr>
<h3 id="JWT-有什么缺点？"><a class="headerlink" href="#JWT-有什么缺点？"></a>JWT 有什么缺点？</h3>
<p>答：</p>
<ul>
<li><code>JWT</code> 的最大缺点是 <strong>令牌难以主动失效，一旦 <code>JWT</code> 签发了，在到期之前就会始终有效，除非服务器搞了额外的逻辑</strong>，比如：设计一个 “黑名单” 的额外的逻辑，用来把要主动失效的令牌集中存储起来，然后，每次使用 <code>JWT</code> 进行请求的话都会先判断这个 <code>JWT</code> 是否存在于黑名单中</li>
<li><strong><code>JWT</code> 要防止盗用的问题</strong>，因为 <code>JWT</code> 包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限，<strong>为了减少盗用，<code>JWT</code> 的有效期应该设置得比较短，而且不应该使用 <code>HTTP</code> 协议明码传输，要使用 <code>HTTPS</code>  协议传输</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p><strong><code>JWT</code> 的缺点</strong>：</p>
<ul>
<li><strong>令牌难以主动失效</strong>：<code>JWT</code> 令牌一旦签发，理论上就和认证服务器再没有什么瓜葛了，在到期之前就会始终有效，除非服务器部署额外的逻辑去处理失效问题，这对某些管理功能的实现是很不利的
<ul>
<li>譬如一种颇为常见的需求是：要求一个用户只能在一台设备上登录，在 B 设备登录后，之前已经登录过的 A 设备就应该自动退出。如果采用 <code>JWT</code>，就必须设计一个 “黑名单” 的额外的逻辑，用来把要主动失效的令牌集中存储起来，而无论这个黑名单是实现在 <code>Session</code>、<code>Redis</code> 或者 数据库 中，都会让服务退化成有状态服务，降低了 <code>JWT</code> 本身的价值，但黑名单在使用 <code>JWT</code> 时依然是很常见的做法，需要维护的黑名单一般是很小的状态量，许多场景中还是有存在价值的</li>
</ul>
</li>
<li><strong>必须考虑令牌在客户端如何存储</strong>：严谨地说，这个并不是 <code>JWT</code> 的问题而是系统设计的问题。如果授权之后，操作完关掉浏览器就结束了，那把令牌放到内存里面，压根不考虑持久化才是最理想的方案。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的。这样的话，想想客户端该把令牌存放到哪里 是 <code>Cookie</code>？、<code>localStorage</code>？、<code>Indexed DB</code>？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充用户的身份做任何事情。为了减少盗用，<code>JWT</code> 的有效期应该设置得比较短，而且 <code>JWT</code> 不应该使用 <code>HTTP</code> 协议明码传输，要使用 <code>HTTPS</code> 协议传输</li>
</ul>
<hr>
<h3 id="什么是跨域？什么情况下会发生跨域请求？"><a class="headerlink" href="#什么是跨域？什么情况下会发生跨域请求？"></a>什么是跨域？什么情况下会发生跨域请求？</h3>
<p>答：</p>
<ul>
<li><strong>当一个网页去尝试访问不同源的资源的时候，就意味着发生了 跨域请求</strong>，只要 <strong>域名、协议、端口</strong> 这三个信息任意一个不同，都认为是不同源的 <code>URL</code></li>
<li><strong>跨域请求 在 浏览器 上是 不被允许的</strong>，只要在浏览器上发生跨域请求操作时，浏览器就会自动抛出的错误。如果想绕过这个限制，可以用 跨域资源共享（<code>CORS</code>）技术
<ul>
<li><strong>实现的方式</strong>：服务器需要在 <strong>响应头</strong> 上添加 <code>Access-Control-Allow-Origin</code> 的字段，这个字段是设置为需要放行的域名，浏览器识别到了，才能放行该请界</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>在浏览器环境下，当一个网页的脚本尝试去访问不同源（域名、协议、端口）的资源时，就会发生跨域请求。<strong>同源策略 是 浏览器 的一种安全机制，它限制了一个网页中的脚本只能访问同源下的资源，而不能直接访问其他域下的资源</strong></li>
<li>在以下情况下会发生跨域请求：
<ol>
<li><strong>域名不同</strong>：当浏览器中的网页从一个域名（例如：<code>www.example.com</code>）发起请求访问另一个域名(例如：<code>api.example.com</code>）的资源时，就会发生跨域请求</li>
<li><strong>协议不同</strong>：当浏览器中的网页从一个协议（例如：<code>http://</code>)发起请求访问另一个协议（例如：<code>https://</code>）的资源时，也会发生跨域请求</li>
<li><strong>端口不同</strong>：当浏览器中的网页从一个端口（例如：<a target="_blank" rel="noopener" href="http://example.com:8080">http://example.com:8080</a>）发起请求访问另一个端口（例如：<a target="_blank" rel="noopener" href="http://example.com:3000">http://example.com:3000</a>）的资源时，同样会发生跨域请求。</li>
</ol>
</li>
<li>跨域请求会受到 同源策略 的限制，可以通过下面这些方式绕过限制：
<ol>
<li><strong>使用反向代理</strong>：通过 <code>Nginx</code> 等工具设置反向代理，将跨域请求转发到目标服务器</li>
<li><strong><code>JSONP</code></strong>：网页通过添加一个 <code>script</code> 元素，向服务器请求 <code>JSON</code> 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。缺点是：只支持 <code>get</code> 请求，不支持 <code>post</code> 请求</li>
<li><strong><code>CORS</code></strong>：在服务端设置响应头部信息，允许特定源的请求访问</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/689093.html">跨域是个什么鬼，你搞明白了吗？-跨域是指什么</a></p>
<hr>
<h3 id="RestFul-是什么？RestFul-请求的-URL-有什么特点？"><a class="headerlink" href="#RestFul-是什么？RestFul-请求的-URL-有什么特点？"></a>RestFul 是什么？RestFul 请求的 URL 有什么特点？</h3>
<p>答：</p>
<ul>
<li><code>RestFul</code> 是一种 <code>API</code> 接口设计规范，<strong>用 <code>URL</code> 定位资源，用 <code>HTTP</code> 方法表示接口的动作，用 <code>HTTP</code> 状态码表示接口处理的情况</strong></li>
<li><code>RestFul</code> 风格的 <code>HTTP</code> 接口可以通过 <code>URL</code> 就能判定这个接口是做什么的
<ul>
<li><code>/articles POST</code> ：代表新增一个文章</li>
<li><code>/articles GET</code> ：代表获取全部文章</li>
<li>有可能后边带参数进行一些过滤查询或分页，<code>/articles/1 GET</code>：代表获取 <code>id</code> 为 <code>1</code> 这篇文章</li>
<li><code>/articles/1 PUT</code>：代表更新 <code>id</code> 为 <code>1</code> 的文章</li>
<li>请求体可能会带一些更新内容，<code>/articles/1 DELETE</code>：代表删除 <code>id</code> 为 <code>1</code> 的文章</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p><code>RestFul</code> 简单理解就是用 <code>URL</code> 定位资源，用 <code>HTTP</code> 动词（<code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>）描述操作</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南 - 阮一峰的网络日志</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28557115">(13 封私信 / 33 条消息) 怎样用通俗的语言解释REST，以及RESTful？ - 知乎</a></p>
<hr>
<h2 id="HTTPS"><a class="headerlink" href="#HTTPS"></a>HTTPS</h2>
<hr>
<h3 id="HTTP-和-HTTPS-有什么区别？"><a class="headerlink" href="#HTTP-和-HTTPS-有什么区别？"></a>HTTP 和 HTTPS 有什么区别？</h3>
<p>答：</p>
<p>我的理解主要有 4 个方面的区别：</p>
<ul>
<li><strong>安全性</strong>：<code>HTTP</code> 是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。而 <code>HTTPS</code> 通过使用 <code>SSL/TLS</code> 协议对数据进行加密，提供了更高的安全性和数据保护</li>
<li><strong>建立连接</strong>：<code>HTTP</code> 连接建立相对简单， <code>TCP</code> 三次握手之后便可进行 <code>HTTP</code> 的报文传输。而 <code>HTTPS</code> 在 <code>TCP</code>  三次握手之后，还需进行 <code>SSL/TLS</code> 的握手过程，才可进入加密报文传输</li>
<li><strong>端口号</strong>：<code>HTTP</code> 默认使用 端口号 <code>80</code> 进行通信，而 <code>HTTPS</code> 默认使用端口号 <code>443</code></li>
<li><strong>证书</strong>：<code>HTTPS</code> 需要使用数字证书来验证服务器的身份，并确保数据传输的安全性。证书由受信任的第三方机构颁发，用于证明服务器的身份和所有权。而 <code>HTTP</code> 没有使用证书进行身份验证和加密</li>
</ul>
<hr>
<h3 id="了解过哪些加密算法？"><a class="headerlink" href="#了解过哪些加密算法？"></a>了解过哪些加密算法？</h3>
<p>答：</p>
<ul>
<li>我主要了解 <strong>对称加密算法、非对称加密算法、哈希算法</strong> 这三种加密算法：</li>
<li>在 <code>HTTPS</code> 协议里，<strong>对称加密算法</strong> 和 <strong>非对称加密算法</strong> 这两种算法都会用到
<ul>
<li>对称加密算法就是用一个密钥进行加解密，比如：<code>AES</code> 算法；非对称加密则是有 2 个密钥，分别是 公钥和 私钥，比如：<code>RSA</code>算法。对称加密算法 适用于 大量数据 的 加密 和 解密，而 非对称加密算法 适用于 密钥交换 和 数字签名 等场景</li>
</ul>
</li>
<li><strong>哈希算法</strong> 主要用过 <code>MD5</code> 算法，<strong>哈希算法 是一种 单向算法</strong>，用户可以通过 哈希算法 对目标信息生成一段特定长度的唯一的哈希值，却不能通过这个哈希值重新获得目标信息，所以用于数据完整性校验方面</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://blog.51cto.com/zhangchiworkos/3226867">常用的加密算法_51CTO博客_常用的加密算法有哪些</a></p>
<hr>
<h3 id="对称加密和非对称加密是什么？各自有哪些算法？"><a class="headerlink" href="#对称加密和非对称加密是什么？各自有哪些算法？"></a>对称加密和非对称加密是什么？各自有哪些算法？</h3>
<p>答：</p>
<ul>
<li>对称加密 和 解密 都是用 <strong>同一个密钥</strong> 进行操作，加密 和 解密 过程速度较快，适合对大量数据进行加密，对称密钥必须保密，不能明文传输，常见的对称加密算法有 <code>AES</code>、<code>DES</code>等</li>
<li>非对称加密使用 <strong>两个密钥</strong>，分别是 公钥 和 私钥，加密 和 解密 过程相对较慢，适合对少量数据进行加密。公钥 可以 任意分发，而 私钥 必须 保密，可以通过 <strong>公钥加密对称密钥，私钥解密</strong> 的方式，保证对称密钥的安全传输，常见的非对称加密算法有 <code>RSA</code>、<code>ECC</code> 等</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><strong>密钥区别</strong>：</p>
<ol>
<li><strong>对称加密</strong>：使用同一个密钥进行加密和解密。这意味着加密方和解密方必须事先共享同一个密钥，并且保证这个密钥的安全</li>
<li><strong>非对称加密</strong>：使用一对密钥，一个公开密钥（公钥）用于加密，一个私有密钥（私钥）用于解密。公钥可以公开分享，而私钥必须保持私密</li>
</ol>
</li>
<li>
<p><strong>加密速度区别</strong>:</p>
<ol>
<li><strong>对称加密</strong>：通常更快，因为它使用较简单的算法来处理大量数据</li>
<li><strong>非对称加密</strong>：由于其复杂的数学运算，尤其是在处理大量数据时，比对称加密得多</li>
</ol>
</li>
<li>
<p><strong>使用场景区别</strong>：</p>
<ol>
<li><strong>对称加密</strong>：适用于需要快速处理大量数据的场景，如：文件加密、数据库加密、网络数据传输加密等</li>
<li><strong>非对称加密</strong>：由于其速度较慢，通常用于加密少量数据或用于加密对称加密中使用的密钥</li>
</ol>
</li>
<li>
<p><strong>典型的加密算法</strong>：</p>
<ul>
<li>
<p><strong>对称加密算法</strong>：<code>AES</code>（高级加密标准）、<code>DES</code>（数据加密标准）、<code>3DES</code>（三重数据加密算法）等</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226163425830.png" alt="对称加密算法" loading="lazy"></p>
</li>
<li>
<p><strong>非对称加密算法</strong>：<code>RSA</code>、<code>ECC</code>（椭圆曲线密码学）等</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226163448040.png" alt="非对称加密算法" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903638117122056">浅谈常见的七种加密算法及实现数字签名、信息加密 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通 - 掘金</a></p>
<hr>
<h3 id="对称和非对称的加密算法的区别？"><a class="headerlink" href="#对称和非对称的加密算法的区别？"></a>对称和非对称的加密算法的区别？</h3>
<p>答：</p>
<ul>
<li>我理解的区别：
<ol>
<li>对称 加密 和 解密 都是用 同一个密钥 进行操作，加密和解密过程速度较快，适合对大量数据进行加密，对称密钥必须保密，不能明文传输</li>
<li>非对称 加密使用 两个密钥，分别是 公钥 和 私钥，加密和解密过程相对较慢，适合对少量数据进行加密。公钥可以任意分发，而私钥必须保密，可以通过公钥加密对称密钥，私钥解密的方式，保证对称密钥的安全传输</li>
</ol>
</li>
<li><code>HTTPS</code> 采用的就是这样的混合加密方式
<ul>
<li>在 <strong>通信建立前</strong> 采用 <strong>非对称加密</strong> 的方式 <strong>交换「对称密钥」，后续就不再使用非对称加密</strong>。在 <strong>通信过程中</strong> 全部 <strong>使用「对称密钥」的方式加密明文数据</strong></li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>可以从 <strong>加解密速度 + 密钥传输安全性</strong> 两个方向来说明区别</p>
<hr>
<h3 id="假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？"><a class="headerlink" href="#假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？"></a>假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？</h3>
<p>答：</p>
<p><strong>使用对称加密算法比较好</strong>，因为对称加密算法运算速度是比非对称加密更快的，比较适合数据量大常见的加密</p>
<p><strong>补充</strong>：</p>
<ul>
<li>对称密钥加密速度会比非对称密钥快，针对数据量比较大的场景，要选择对称密钥来加密。对称加密比非对称加密快的原因：
<ul>
<li>对称加密 主要的运算是 <strong>位运算</strong>，速度非常快，如果使用硬件计算，速度会更快，但是非对称加密计算一般都比较复杂，比如：<code>RSA</code>，它里面涉及到 大数乘法、大数模 等等运算</li>
<li>除了慢，可能还有一个缺点就是需要更多的位数，相同强度的对称密钥要比非对称密钥短。对称密钥一般都 128 位、256 位，而 <code>RSA</code> 一般要 2048 位，不过圆曲线的会短一点</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1672173">为什么非对称加密比对称加密慢？-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="HTTPS-建立的过程是怎么样的？"><a class="headerlink" href="#HTTPS-建立的过程是怎么样的？"></a>HTTPS 建立的过程是怎么样的？</h3>
<p>答：</p>
<ul>
<li>首先 客户端 要和 服务端 先进行 <code>TCP</code> 三次握手建立 <code>TCP</code> 连接。接下来，会进行 <code>TLS</code> 四次握手：
<ol>
<li><strong>第一次 <code>TLS</code> 握手</strong>：客户端首先会发一个 <code>Client Hello</code> 消息，消息里面有 <strong>客户端使用的 <code>TLS</code> 版本号、支持的密码套件列表、客户端生成的随机数</strong>，这个随机数是用来后面生成对称密钥元素之一</li>
<li><strong>第二次 <code>TLS</code> 握手</strong>：当服务端收到客户端的消息后，会返回 <code>Server Hello</code> 消息给的客户端，消息里面有服务器确认的 <code>TLS</code> 版本号、密码套件、服务端生成的随机数。接着服务端为了证明自己的身份，会发送 <code>Server Certificate</code> 给客户端，这个消息里含有数字证书。随后，服务端发了 <code>Server Hello Done</code> 消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次握手完毕
<ul>
<li><strong>校验证书</strong>：客户端收到服务端的数字证书的时候，会对校验服务端的证书，如果证书是合法的，客户端会用 <code>CA</code> 机构的公钥解密数字证书拿到服务端的公钥</li>
</ul>
</li>
<li><strong>第三次 <code>TLS</code> 握手</strong>：客户端再次生成一个随机数，用服务端的公钥加密后，通过 <code>Client Key Exchange</code> 消息传给服务端。服务端收到后，用服务端的私钥解密得到客户端的第二个随机数。到这里，服务端和客户端双方都有 3 个随机数，双方根据已经得到的三个随机数，会根据算法生成对称密钥。生成完对称密钥后，客户端会发一个消息告诉服务端开始使用对称加密方式发送消息，并且还会对之前所有发送的数据做个摘要，再用对称加密加密一下，让服务器做个验证，验证对称密钥是否可用，以及之前握手信息是否有被中途篡改</li>
<li><strong>第四次 <code>TLS</code> 握手</strong>：服务器也是同样的操作，发送消息告诉客户端开始用对称加密方式发送消息，并且也会对数据做个摘要，并用对称密钥加密一下，让客户端做个校验，如果双方都验证加密和解密没问题，那么 <code>TLS</code> 四次握手正式完成了</li>
</ol>
</li>
<li>最后，就用对称密钥加解密 <code>HTTP</code> 请求和响应了</li>
</ul>
<p><strong>补充</strong>：</p>
<img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226181009225.png" alt="HTTPS建立过程" style="zoom:150%;">
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241226181118952.png" alt="HTTPS建立过程" loading="lazy"></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="为什么需要三个随机数？"><a class="headerlink" href="#为什么需要三个随机数？"></a>为什么需要三个随机数？</h3>
<p>答：</p>
<p>因为计算机生成的随机数其实是一个伪随机，那么只用一个随机数来生成的对称密钥很容易就被破解了，<strong>用三个伪随机数就十分接近随机了，这样称密钥破解的难度都变高了</strong></p>
<p><strong>补充</strong>：</p>
<ul>
<li>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 <code>SSL</code> 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性</li>
<li>对于 <code>RSA</code> 密钥交换算法来说，<code>pre-master-key</code>（第三个随机数）本身就是一个随机数，再加上 <code>hello</code> 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥</li>
<li><code>pre master</code>（第三个随机数）的存在在于 <code>SSL</code> 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<code>pre master secret</code>就有可能被猜出来，那么仅适用<code>pre master secret</code>（第三个随机数）作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 <code>pre master secret</code> 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志</a></p>
<hr>
<h3 id="一次HTTPS需要几次RTT（就是几个来回）？"><a class="headerlink" href="#一次HTTPS需要几次RTT（就是几个来回）？"></a>一次HTTPS需要几次RTT（就是几个来回）？</h3>
<p>答：</p>
<p><code>HTTPS</code> 是四次握手，那么就是 2 次 <code>RTT</code></p>
<p><strong>补充</strong>：</p>
<p><code>RTT</code> 是往返的延时，<code>HTTPS</code> 是四次握手，也就是代表 2 次往返，那么就是 2 次 <code>RTT</code></p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="你了解业界现在有一个RTT建立HTTPS连接的方案吗？"><a class="headerlink" href="#你了解业界现在有一个RTT建立HTTPS连接的方案吗？"></a>你了解业界现在有一个RTT建立HTTPS连接的方案吗？</h3>
<p>答：</p>
<p>基于 <code>ECDHE</code> 密钥交换的 <code>HTTPS</code> 连接方案，可以实现1 个 <code>RTT</code> 建立 <code>HTTPS</code> 连接</p>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p><code>TLS</code> 1.2 版本如果使用的是 <code>RSA</code> 密钥交换算法，那么需要 4 次握手，也就是要花费 2 <code>RTT</code>，才可以进行应用数据的传输</p>
</li>
<li>
<p>因此如果可以，尽量选用 <code>ECDHE</code> 密钥交换算法（<code>TLS</code> 1.3 版本使用）替换 <code>RSA</code> 算法，因为该算法由于支持<code>「TLS False start」</code>，客户端可以在 <code>TLS</code> 协议的第 3 次握手后，第 4 次握手之前，发送加密的应用数据，以此将 <code>TLS</code> 握手的消息往返由 2 <code>RTT</code> 减少到 1 <code>RTT</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228131547077.png" alt="TSL四次握手" loading="lazy"></p>
</li>
<li>
<p>下图左边是基于 <code>RSA</code> 算法的 <code>HTTPS</code> 建立流程，需要 2 个 <code>RTT</code>，右边是基于 <code>ECDHE</code> 算法的 <code>HTTPS</code> 建立流程，只需要 1 个 <code>RTT</code></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228131744258.png" alt="RSA算法与ECDHE算法的对比" loading="lazy"></p>
<ul>
<li>上图的右边部分就是 <code>TLS</code> 1.3（基于 <code>ECDHE</code> 算法）的握手过程，可以发现 <code>TLS</code> 1.3 <strong>把 <code>Hello</code> 和 公钥 交换这两个消息合并成了一个消息</strong>，于是这样就减少到只需 1 <code>RTT</code> 就能完成 <code>TLS</code> 握手</li>
<li>具体的做法是：客户端在 <code>Client Hello</code> 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥，服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 <code>RTT</code>，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了</li>
<li>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥</li>
<li>经过这 1 个 <code>RTT</code>，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_optimize.html">3.5 HTTPS 如何优化？ | 小林coding</a>、<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_ecdhe.html#ecdhe-%E7%AE%97%E6%B3%95">3.4 HTTPS ECDHE 握手解析 | 小林coding</a></p>
<hr>
<h3 id="HTTPS-过程进行了多少次非对称加密？多少次对称加密？"><a class="headerlink" href="#HTTPS-过程进行了多少次非对称加密？多少次对称加密？"></a>HTTPS 过程进行了多少次非对称加密？多少次对称加密？</h3>
<p>答：</p>
<ul>
<li><strong>还未 <code>HTTPS</code> 握手之前</strong>：
<ul>
<li>服务端在向 <code>CA</code> 机构注册证书的时候，<code>CA</code> 机构会用 <code>CA</code> 私钥会对服务端的公钥进行签名，形成数字证书，这里涉及了 1 次非对称加密</li>
</ul>
</li>
<li><strong><code>HTTPS</code> 握手期间</strong>：
<ul>
<li>客户端会用服务端的公钥加密随机数，服务端再用私钥解密，这里涉及了 1 次非对称加密</li>
<li>客户端和服务端生成对称密钥之后，都需要对之前握手的数据做个摘要，并用对称密钥加密一下，这个过程客户端和操作都会涉及到，所以 <code>HTTPS</code> 握手期间用了 2 次对称加密，客户端和服务端各做了一次</li>
</ul>
</li>
<li><strong><code>HTTPS</code> 握手完成之后</strong>：
<ul>
<li><code>HTTPS</code> 数据传输期间都是用对称密钥进行加密和解密</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li>可以分 <code>HTTPS</code> 握手之前、期间、之后三个时间段来回答</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="SSL-握手流程为什么要使用非对称加密？"><a class="headerlink" href="#SSL-握手流程为什么要使用非对称加密？"></a>SSL 握手流程为什么要使用非对称加密？</h3>
<p>答：</p>
<ul>
<li>我的理解主要是为了保护对称加密钥不被中间人窃取，如果对称加密钥被窃取了，使用这个对称加密钥加密的 <code>HTTP</code> 报文就很容易被破解了</li>
<li>在 <code>HTTPS</code> 协议进行 <code>TLS</code> 握手的时候，客户端生成随机数，这个是生成对称加密钥元素之一，它会被公钥加密后传输给服务端，由服务端用私钥解密，这里就保证了对称加密钥的安全
<ul>
<li>因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容</li>
</ul>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h3 id="为什么-HTTPS-不用非对称加密算法加密-HTTP-报文？"><a class="headerlink" href="#为什么-HTTPS-不用非对称加密算法加密-HTTP-报文？"></a>为什么 HTTPS 不用非对称加密算法加密 HTTP 报文？</h3>
<p>答：</p>
<p>非对称加密算法的加密和解密操作相对比对称加密算法更消耗 <code>CPU</code> 计算力，也更耗时，而 <code>HTTP</code> 报文通常包含大量的数据，如果直接使用非对称加密算法对整个报文进行加密和解密，会导致性能下降和延迟增加</p>
<p><strong>补充</strong>：</p>
<p>要重点说明非对称加密算法更消耗 <code>CPU</code> 计算力，不适合用来频繁的加解密</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6855129005688340494">为什么非对称加密比对称加密慢？这个问题是一个读者面试时遇到的一个问题，准备过面试的人应该都记得，非对称加密与对称加密的区 - 掘金</a></p>
<hr>
<h3 id="HTTPS-会对-URL-加密吗？"><a class="headerlink" href="#HTTPS-会对-URL-加密吗？"></a>HTTPS 会对 URL 加密吗？</h3>
<p>答：</p>
<p><code>URL</code> 是属于 <code>HTTP</code> 报文头部的信息，<code>HTTPS</code> 会对整个 <code>HTTP</code> 报文都会加密，所以 <code>HTTPS</code> 是会对 <code>URL</code> 加密的</p>
<p><strong>补充</strong>：</p>
<p>很多人看到浏览器的地址栏就以为 <code>HTTPS</code> 不会对 <code>URL</code> 进行加密，实际上 <code>URL</code> 是属于 <code>HTTP</code> 报文头部的信息，<code>HTTPS</code> 会对整个 <code>HTTP</code> 报文（<code>header + body</code>）都加密，所以 <code>HTTPS</code> 是会对 <code>URL</code> 加密，之所以浏览器能明文显示 <code>URL</code>，是因为浏览器已经帮我们解密好了</p>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247518634&amp;idx=1&amp;sn=b1d36ef60ed5c53d89b9b2f953d149f8&amp;chksm=f98dcd00cefa4416730ed8a9bb5684a9572bc68ab9b05cb72eef5020f97b917d59d02d867340&amp;scene=178&amp;cur_album_id=1337204681134751744#rd">字节一面：HTTPS 会加密 URL 吗？</a></p>
<hr>
<h3 id="CA-机构如何验证server身份？"><a class="headerlink" href="#CA-机构如何验证server身份？"></a>CA 机构如何验证server身份？</h3>
<p>答：</p>
<p>服务端在向 <code>CA</code> 机构申请证书的时候，<code>CA</code> 机构会通过自己的私钥对服务器的一些信息进行数字签名，然后在 <code>HTTPS</code> 握手阶段的时候，服务端会发送证书给客户端来验证，客户端实际上已经内置了 <code>CA</code> 机构的公钥，那么就用这个公钥来验证服务端的数字证书是否是可信的</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228140417498.png" alt="CA机构流程" loading="lazy"></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228140509980.png" alt="CA机构流程" loading="lazy"></p>
<hr>
<h3 id="证书是绿色的是什么意思？"><a class="headerlink" href="#证书是绿色的是什么意思？"></a>证书是绿色的是什么意思？</h3>
<p>答：</p>
<p><strong>代表网站是 可信的</strong>，浏览器在 <code>HTTPS</code> 握手阶段会对网站服务器下发的证书进行校验,，如果校验成功，代表网站的身份的可信的，是被 <code>CA</code> 机构认证过的</p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/zhishi/dyl10.html">SSL证书是什么-什么是SSL证书-华为云</a></p>
<hr>
<h3 id="自己随便编一个证书可以吗？需要去什么地方注册？"><a class="headerlink" href="#自己随便编一个证书可以吗？需要去什么地方注册？"></a>自己随便编一个证书可以吗？需要去什么地方注册？</h3>
<p>答：</p>
<ul>
<li><strong>不可以</strong>
<ul>
<li>浏览器在校验这个证书的时候，会认为是非法的证书，这时候浏览器会显示访问的网站是不可信</li>
<li>得去 <code>CA</code> 机构申请证书，浏览器才会认为是合法的证书，这样才能正常的访问网站的内容</li>
</ul>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>数字证书的作用</strong>：是用来认证 公钥持有者 的身份，以防止第三方进行冒充
<ul>
<li>说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。我们用证书来认证公钥持有者的身份（服务端的身份）</li>
</ul>
</li>
<li>那证书又是怎么来的？又该怎么认证证书呢？为了让服务端的公钥被大家信任，服务端的证书都是由 <code>CA</code> （<code>Certificate Authority</code>，证书认证机构）签名的，<code>CA</code> 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">3.3 HTTPS RSA 握手解析 | 小林coding</a></p>
<hr>
<h2 id="RPC"><a class="headerlink" href="#RPC"></a>RPC</h2>
<hr>
<h3 id="RPC-的作用是什么？"><a class="headerlink" href="#RPC-的作用是什么？"></a>RPC 的作用是什么？</h3>
<p>答：</p>
<ul>
<li><code>RPC</code> 是远程过程调用，主要运用于微服务之间的通信</li>
<li>它的作用是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，让我们更专注于业务逻辑，而无需关注底层网络通信的细节</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>RPC</code> 的全称是 <code>Remote Procedure Call</code>，即：远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 <code>RPC</code> 调用了？显然并不够</li>
<li>我理解的 <code>RPC</code> 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。这就好比建在小河上的桥一样连接着河的两岸，如果没有小桥，我们需要通过划船、绕道等其他方式才能到达对面，但是有了小桥之后，我们就能像在路面上一样行走到达对面，并且跟在路面上行走的体验没有区别</li>
<li>所以我认为，<strong><code>RPC</code>的作用就是体现在这样两个方面</strong>：
<ul>
<li><strong>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法</strong></li>
<li><strong>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么有HTTP协议了？还要用RPC？"><a class="headerlink" href="#为什么有HTTP协议了？还要用RPC？"></a>为什么有HTTP协议了？还要用RPC？</h3>
<p>答：</p>
<ul>
<li><code>HTTP</code> 和 <code>RPC</code> 其实是两个维度的东西， <code>HTTP</code> 指的是 通信协议。而 <code>RPC</code> 则是远程调用，其对应的是本地调用。<code>RPC</code> 的通信可以用 <code>HTTP</code> 协议，也可以自定义协议，是不做约束的</li>
<li>用 <code>HTTP</code> 传输数据会有比较多的信息，比如：头部有各种字段信息，数据载体则一般是用 <code>json</code> 格式，而 <code>RPC</code> 因为它定制化程度更高，可以采用体积更小的 <code>protobuf</code> 或 其他序列化协议 去保存结构体数据，同时也不需要像 <code>HTTP</code> 那样考虑各种浏览器行为，比如：<code>302</code> 重定向跳转啥的，因此性能也会更好一些，这也是在公司内部微服务中抛弃 <code>HTTP</code>，选择使用 <code>RPC</code> 的最主要原因</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>RPC</code> 本质上不算是协议，而是一种调用方式，而像 <code>gRPC</code> 和 <code>Thrift</code> 这样的具体实现，才是协议，它们是实现了 <code>RPC</code> 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 <code>RPC</code> 有很多种实现方式，不一定非得基于 <code>TCP</code> 协议</li>
<li>从发展历史来说，<code>HTTP</code> 主要用于 <code>B/S</code> 架构，而 <code>RPC</code> 更多用于 <code>C/S</code> 架构。但现在其实已经没分那么清了，<code>B/S</code> 和 <code>C/S</code> 在慢慢融合。很多软件同时支持多端，所以对外一般用 <code>HTTP</code> 协议，而内部集群的微服务之间则采用 <code>RPC</code> 协议进行通讯</li>
<li><code>RPC</code> 其实比 <code>HTTP</code> 出现的要早，且比目前主流的 <code>HTTP/1.1</code> 性能要更好，所以大部分公司内部都还在使用<code>RPC</code></li>
<li><code>HTTP/2.0</code> 在 <code>HTTP/1.1</code>的基础上做了优化，性能可能比很多 <code>RPC</code> 协议都要好，但由于是这几年才出来的</li>
<li>所以也不太可能取代掉 <code>RPC</code></li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_rpc.html">3.8 既然有 HTTP 协议，为什么还要有 RPC？ | 小林coding</a></p>
<hr>
<h2 id="Nginx"><a class="headerlink" href="#Nginx"></a>Nginx</h2>
<hr>
<h3 id="Nginx-位于七层网络结构的哪一层？"><a class="headerlink" href="#Nginx-位于七层网络结构的哪一层？"></a>Nginx 位于七层网络结构的哪一层？</h3>
<p>答：</p>
<p><strong>应用层</strong>，<code>nginx</code> 是七层负载均衡</p>
<p><strong>补充</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241228143328555.png" alt="OSI vs TCP/IP" loading="lazy"></p>
<ul>
<li>常说的七层和四层负载均衡，是用 <code>OSI</code> 网络模型来描述的，七层对应的是应用层，四层对应的是传输<br>
层</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1843920">讲讲亿级PV的负载均衡架构-腾讯云开发者社区-腾讯云</a></p>
<hr>
<h3 id="Nginx-有哪些负载均衡算法？"><a class="headerlink" href="#Nginx-有哪些负载均衡算法？"></a>Nginx 有哪些负载均衡算法？</h3>
<p>答：</p>
<ul>
<li>我了解到的主要有 <strong>普通轮询、加权轮询、<code>IP</code> 哈希、<code>URL</code> 哈希、最短响应时间、最短连接</strong> 这些负载均衡算法</li>
<li>大体上可以分为下面几类：
<ol>
<li><strong>任务平分类</strong>：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的 “平均” 可以是绝对数量的平均，也可以是比例或者权重上的平均，比如：轮询 和 加权轮询算法</li>
<li><strong>负载均衡类</strong>：负载均衡系统根据服务器的负载来进行分配，可以用 <code>CPU</code> 负载来衡量，也可以用连接数 <code>I/O</code> 使用率、网卡吞吐量等来衡量系统的压力。比如：最短连接数算法</li>
<li><strong>性能最优类</strong>：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器，比如：最短响应时间算法</li>
<li><strong><code>Hash</code>类</strong>：负载均衡系统根据任务中的某些关键信息进行<code>Hash</code>运算，将相同<code>Hash</code>值的请求分配到同一台服务器上，比如：<code>IP</code>哈希和<code>URL</code>算法</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><code>Nginx</code>支持的负载均衡算法包括：
<ol>
<li><strong>轮询</strong>：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况</li>
<li><strong>加权轮询</strong>：按照权重分配请求给后端服务器，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率</li>
<li><strong><code>IP</code>哈希</strong>：根据客户端<code>IP</code>地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如：会话保持</li>
<li><strong><code>URL</code>哈希</strong>：按访问的<code>URL</code>的哈希结果来分配请求，使每个<code>URL</code>定向到一台后端服务器，可以进一步提高后端缓存服务器的效率</li>
<li><strong>最短响应时间</strong>：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡</li>
<li><strong>最短连接</strong>：新请求会发送到并发连接最少的服务节点</li>
</ol>
</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247530864&amp;idx=2&amp;sn=6bd22fd310534b35eaee0683bf8b7ec1&amp;chksm=f98d3ddacefab4cc364ae0e2b78fa807262e1c3fafea79f882aa5c29f48d59a88e3fe1acfb53&amp;token=1615262746&amp;lang=zh_CN#rd">面试官：你背一下负载均衡算法？</a></p>
<hr>
<h3 id="什么是反向代理？什么是正向代理？"><a class="headerlink" href="#什么是反向代理？什么是正向代理？"></a>什么是反向代理？什么是正向代理？</h3>
<p>答：</p>
<p>正向代理 代理的 客户端 这一方，而 反向代理 是代理 服务器 这一方，可以通过负载均衡策略，将请求分发到不同服务器上</p>
<p><strong>补充</strong>：</p>
<ul>
<li>正向代理 是位于用户设备和互联网之间的服务器。它代理的是客户端，是站在用户一方的。其真实客户端对于服务器不可见
<ul>
<li><strong>正向代理通常用于</strong>：
<ol>
<li><strong>保护客户端，隐藏客户端真实 <code>IP</code>，免受攻击</strong></li>
<li><strong>避免网络浏览限制</strong>（科学上网）</li>
<li><strong>阻止访问某些内容</strong></li>
<li><strong>提高访问速度</strong>。通常代理服务器会有较大的硬盘缓冲区，将一些响应结果缓存在服务器端，以便后续用户取用</li>
</ol>
</li>
</ul>
</li>
<li>反向代理 是一种服务器，它接受客户端的请求，将请求转发给网络服务器，然后将结果返回给客户端，就像代理服务器处理了请求一样
<ul>
<li>反向代理代理的是服务器，是和网络服务器站在一方的。其真实服务器对于客户端不可见。这就是它叫 “反向” 的原因</li>
<li><strong>反向代理可用于</strong>：
<ol>
<li><strong>保护服务器，隐藏服务器真实 <code>IP</code></strong></li>
<li><strong>负载均衡，根据访问流量和服务器负载情况，将请求分发到不同服务器上</strong></li>
<li><strong>缓存静态内容以及部分短时间的大量动态请求</strong></li>
<li><strong>作为应用层防火墙提供防护，加密/解密 <code>SSL</code> 通信</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="TCP-三次握手"><a class="headerlink" href="#TCP-三次握手"></a>TCP 三次握手</h2>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"></a><div class="post-copyright__author_name">coo1heisenberg's Blog</div><div class="post-copyright__author_desc">Diligence can make up for clumsiness!</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">coo1heisenberg's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tags-punctuation"></span>计算机网络<span class="tagsPageCount">1</span></a></div></div><div class="social-share"></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">06 Redis知识点归纳 笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">菜鸡的自我救赎...</div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Coo1heisenberg’s BLOG</div><div class="author-info__desc">Diligence can make up for clumsiness!</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/coo1heisenbergProject" title="Github"><i class="solitude  st-github-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">计算机网络知识点归纳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-OSI-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">介绍一下 OSI 七层协议，各层协议都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82%EF%BC%9F"><span class="toc-text">TCP&#x2F;IP 网络模型有哪几层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%8D%8F%E8%AE%AE%E5%92%8C-TCP-%E5%8D%8F%E8%AE%AE%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">IP 协议和 TCP 协议属于哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">网络为什么要分层？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-text">键入网址场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">输入网址后，期间发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%9A%84%EF%BC%9F%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">DNS 是如何解析的？属于哪一层的协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">DNS域名解析使用的什么协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%AB%AF%E5%8F%A3%E7%9A%84%EF%BC%9F"><span class="toc-text">输入域名如何知道端口的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%BA%94%E8%AF%A5%E6%8A%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E8%B0%81%EF%BC%9F"><span class="toc-text">客户端向服务端的 IP 地址发送数据，服务端如何确定应该把数据传递给谁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E5%BE%88%E5%A4%9A%E7%BD%91%E7%AB%99%E9%83%BD%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8-https%EF%BC%8C%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-http-%E7%BD%91%E5%9D%80%EF%BC%8C%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%94%B1-http-%E8%B7%B3%E8%BD%AC%E5%88%B0-https-%E7%9A%84%EF%BC%9F"><span class="toc-text">现在很多网站都要求使用 https，假设我们输入一个 http 网址，网站是如何实现由 http 跳转到 https 的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-text">网络传输场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">如果浏览器没有显示页面有哪些原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8ping%E4%B8%8D%E9%80%9A%E4%BD%86%E6%98%AFhttp%E8%83%BD%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%90%97%EF%BC%9F"><span class="toc-text">服务器ping不通但是http能请求成功，会出现这种情况吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 TCP 连接一个不存在的 IP 地址的服务端会发生什么？（cold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 TCP 连接一个 IP 地址存在但是端口不存在的服务端会发生什么？（cold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-UDP-%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88cold%EF%BC%89"><span class="toc-text">客户端 UDP 发送一个 IP 地址存在但是端口不存在报文会发生什么？（cold）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">HTTP 协议的特点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%86%E5%89%B2%E7%9A%84%EF%BC%9F"><span class="toc-text">HTTP 报文格式？怎么分割的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%BB%98%E8%AE%A4%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">HTTP 默认的端口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">HTTP 有什么方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E5%93%AA%E4%BA%9B-HTTP-%E6%96%B9%E6%B3%95%E6%98%AF%E5%AE%89%E5%85%A8%E6%88%96%E8%80%85%E5%B9%82%E7%AD%89%E7%9A%84%EF%BC%9F"><span class="toc-text">分析一下哪些 HTTP 方法是安全或者幂等的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">GET 和 POST 请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E8%AF%B7%E6%B1%82%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AE%89%E5%85%A8%E4%B8%94%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">GET 请求一定是安全且幂等的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-text">HTTP 有什么状态码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0502%E9%94%99%E8%AF%AF%E7%A0%81%E5%91%A2%EF%BC%9F"><span class="toc-text">什么情况下会出现502错误码呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E4%BA%86504%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%87%BA%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">有个服务出现了504，你觉得这个服务是出了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E5%93%AA%E4%B8%80%E7%B1%BB%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">重定向是哪一类状态码？临时重定向和永久重定向有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">HTTP 是长连接还是短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP 长连接和短连接的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">HTTP 长连接有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0-%E5%92%8C-HTTP-3-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">HTTP 是无状态的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%94%A8%E6%88%B7%E5%90%8E%E7%BB%AD%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%EF%BC%9F"><span class="toc-text">HTTP 用户后续的操作，服务端如何知道属于同一个用户？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%99%A8%EF%BC%9F"><span class="toc-text">如果服务端是一个集群机器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A6%81%E7%94%A8-Cookie%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-Session%EF%BC%9F"><span class="toc-text">如果禁用 Cookie，怎么实现 Session？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">cookie 和 session 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E3%80%81session-%E5%92%8C-Token-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Cookie、session 和 Token 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-JWT-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">简述 JWT 的原理和校验机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E4%BB%A4%E7%89%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-text">JWT 令牌为什么能解决集群部署？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">JWT 有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">什么是跨域？什么情况下会发生跨域请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RestFul-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FRestFul-%E8%AF%B7%E6%B1%82%E7%9A%84-URL-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">RestFul 是什么？RestFul 请求的 URL 有什么特点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP 和 HTTPS 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">了解过哪些加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">对称加密和非对称加密是什么？各自有哪些算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">对称和非对称的加密算法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A4%A7%E5%B0%8F%E6%9C%AA%E7%9F%A5%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%A6%81%E6%8A%8A%E5%AE%83%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E7%AB%AF%EF%BC%8C%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%BF%98%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">假设有一个文件，大小未知，现在要把它上传到云端，该使用对称加密还是非对称加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">HTTPS 建立的过程是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9F"><span class="toc-text">为什么需要三个随机数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1HTTPS%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1RTT%EF%BC%88%E5%B0%B1%E6%98%AF%E5%87%A0%E4%B8%AA%E6%9D%A5%E5%9B%9E%EF%BC%89%EF%BC%9F"><span class="toc-text">一次HTTPS需要几次RTT（就是几个来回）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%B8%9A%E7%95%8C%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AARTT%E5%BB%BA%E7%AB%8BHTTPS%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-text">你了解业界现在有一个RTT建立HTTPS连接的方案吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%A4%9A%E5%B0%91%E6%AC%A1%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F%E5%A4%9A%E5%B0%91%E6%AC%A1%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">HTTPS 过程进行了多少次非对称加密？多少次对称加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">SSL 握手流程为什么要使用非对称加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-HTTPS-%E4%B8%8D%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86-HTTP-%E6%8A%A5%E6%96%87%EF%BC%9F"><span class="toc-text">为什么 HTTPS 不用非对称加密算法加密 HTTP 报文？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E4%BC%9A%E5%AF%B9-URL-%E5%8A%A0%E5%AF%86%E5%90%97%EF%BC%9F"><span class="toc-text">HTTPS 会对 URL 加密吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CA-%E6%9C%BA%E6%9E%84%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81server%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-text">CA 机构如何验证server身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E6%98%AF%E7%BB%BF%E8%89%B2%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">证书是绿色的是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E9%9A%8F%E4%BE%BF%E7%BC%96%E4%B8%80%E4%B8%AA%E8%AF%81%E4%B9%A6%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E9%9C%80%E8%A6%81%E5%8E%BB%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E6%B3%A8%E5%86%8C%EF%BC%9F"><span class="toc-text">自己随便编一个证书可以吗？需要去什么地方注册？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">RPC 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%E4%BA%86%EF%BC%9F%E8%BF%98%E8%A6%81%E7%94%A8RPC%EF%BC%9F"><span class="toc-text">为什么有HTTP协议了？还要用RPC？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx"><span class="toc-text">Nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E4%BD%8D%E4%BA%8E%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">Nginx 位于七层网络结构的哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">Nginx 有哪些负载均衡算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">什么是反向代理？什么是正向代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP 三次握手</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记"><img alt="00 计算机网络知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/computer_network.png"></a><div class="content"><a class="title" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记">00 计算机网络知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记"><img alt="06 Redis知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/redis_conclude.png"></a><div class="content"><a class="title" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记">06 Redis知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记"><img alt="05 MySQL知识点总结 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MySQl_ALL.png"></a><div class="content"><a class="title" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记">05 MySQL知识点总结 笔记</a><a class="article-recent_post_categories" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/" title="01 Spring全家桶 笔记"><img alt="01 Spring全家桶 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Spring1204.png"></a><div class="content"><a class="title" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/" title="01 Spring全家桶 笔记">01 Spring全家桶 笔记</a><a class="article-recent_post_categories" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/">Spring</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="02 JVM 笔记"><img alt="02 JVM 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png"></a><div class="content"><a class="title" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="02 JVM 笔记">02 JVM 笔记</a><a class="article-recent_post_categories" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Solitude</span></div><div class="footer-bar-description">来自 Heisenberg 的原创文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">Coo1heisenberg’s BLOG</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.10.6"></script><script src="/js/main.js?v=1.10.6"></script><script src="/js/third_party/waterfall.min.js?v=1.10.6"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.10.6"></script><script>dark()
</script><script src="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="//open.lightxi.com/cdnjs/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script defer pjax src="//open.lightxi.com/cdnjs/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.10.6"></script><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["2024/12/24/计算机网络知识点归纳/","2024/12/21/01-redis知识点归纳/","2024/12/16/01-MySQL知识点归纳/","2024/12/04/Spring框架/","2024/12/02/Java-JVM虚拟机/","2024/11/04/Java-并发编程/","2024/11/01/Java-集合框架/","2024/09/28/00-前端开发入门教程/","2024/09/26/01-空间转录组/","2024/09/13/00-单细胞多组学分析/","2024/07/22/00-MongoDB/","2024/07/17/00-elasticsearch/","2024/07/15/01-黑马redis/","2024/07/13/00-黑马redis/","2024/07/08/00-黑马SSM/","2024/07/08/01-头条点评项目/","2024/07/06/00-Mybatis-Plus/","2024/06/29/00-黑马MySQL/","2024/06/25/00-头条点评项目/","2024/06/21/02-Python/","2024/06/11/01-Python/","2024/05/25/00-Python/","2024/05/13/DesignPattern/","2024/05/13/Docker/","2024/05/13/Nginx/","2024/05/13/Linux/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>