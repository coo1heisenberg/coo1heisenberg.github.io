<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>01 Java并发编程 笔记 | coo1heisenberg's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.10.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="Java并发编程 并发编程基础 为什么要使用并发编程？ 答： 充分利用多核CPU的计算能力 方便进行业务的拆分，提升应用性能 并发编程有什么缺点？ 答： 并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度 但是并发编程不能总是提高程序运行速度（例如：如果是单核CPU，并且线程"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="coo1heisenberg's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.10.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;border-radius:0 5px 5px 0",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-05-12 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.webp'
    },
    copyright: {"limit":50,"author":"作者: Coo1heisenberg’s BLOG","link":"链接: ","source":"来源: coo1heisenberg's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>2</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Project/">Project<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">2024/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">2024/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">2024/06</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">2024/05</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>2</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Project/">Project<sup>2</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon solitude st-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">01 Java并发编程 笔记</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" href="/" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png" alt="01 Java并发编程 笔记"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java/">Java</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tags-name tags-punctuation">Java并发编程</span></a></div></div></div></div><h1 class="post-title">01 Java并发编程 笔记</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-11-04 14:54:08"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-11-04T06:54:08.000Z">2024-11-04T06:54:08.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-11-23 14:46:29"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-11-23T06:46:29.125Z">2024-11-23T06:46:29.125Z</time></span><span class="post-meta-wordcount"><span class="post-meta-separator"></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Java并发编程</h1>
<hr>
<h2 id="并发编程基础"><a class="headerlink" href="#并发编程基础"></a>并发编程基础</h2>
<hr>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241114155858663.png" alt="Java的并发类架构" loading="lazy"></p>
<h3 id="为什么要使用并发编程？"><a class="headerlink" href="#为什么要使用并发编程？"></a>为什么要使用并发编程？</h3>
<p>答：</p>
<ul>
<li>充分利用多核CPU的计算能力</li>
<li>方便进行业务的拆分，提升应用性能</li>
</ul>
<hr>
<h3 id="并发编程有什么缺点？"><a class="headerlink" href="#并发编程有什么缺点？"></a>并发编程有什么缺点？</h3>
<p>答：</p>
<ul>
<li>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度</li>
<li>但是并发编程不能总是提高程序运行速度（例如：如果是单核CPU，并且线程操作都是消耗CPU的，那太多的线程没有什么意义，并不会加快速度，并且线程的切换会带来开销，整体速度变慢）</li>
<li>同时并发编程会遇到很多问题，比如：内存泄漏（ThreadLocal没有remove清理相关对象）、上下文切换、线程安全、死锁等问题</li>
</ul>
<hr>
<h3 id="并发编程三个必要因素是什么？"><a class="headerlink" href="#并发编程三个必要因素是什么？"></a>并发编程三个必要因素是什么？</h3>
<p>答：</p>
<ol>
<li><strong>原子性</strong>：要么全部执行成功要么执行失败</li>
<li><strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能过立刻看的（synchronized、volatile）</li>
<li><strong>有序性</strong>：程序执行顺序按照代码的先后顺序执行（处理器可能会对指令重排序）</li>
</ol>
<hr>
<h3 id="并发出问题的根源是什么？"><a class="headerlink" href="#并发出问题的根源是什么？"></a>并发出问题的根源是什么？</h3>
<p>答：出现线程安全问题的原因一般就是三个原因：</p>
<ol>
<li><strong>线程切换 带来的 原子性 问题</strong>
<ul>
<li>解决办法：使用多线程之间的同步（<code>synchronized</code>）或者锁（<code>lock</code>）</li>
</ul>
</li>
<li><strong>缓存 导致的 可见性 问题</strong>（比如说：A线程对主线程的修改并未及时从本地缓存同步到主线程，这就导致B线程拿到的数据依旧是旧数据）
<ul>
<li>解决办法：使用 <code>synchronized</code>、<code>Lock</code>等同步机制，或者 <code>volatile</code>关键字、<code>final</code>关键字来保证修改对所有线程都是可见的</li>
</ul>
</li>
<li><strong>编程优化 带来的 有序性 问题</strong>（比如说：编译器重排会导致预期执行顺序被打破，导致不可预期的错误）
<ul>
<li>解决办法：使用 <code>synchronized</code>、<code>Lock</code>等同步机制，或者 <code>volatile</code>关键字来禁止重排，也可以使用 <code>Happens-Before</code>规则来解决有序性问题</li>
</ul>
</li>
</ol>
<hr>
<h3 id="并行和并发的区别？"><a class="headerlink" href="#并行和并发的区别？"></a>并行和并发的区别？</h3>
<p>答：</p>
<ul>
<li><strong>并发</strong>：多个任务在同一个CPU核上，按照细分的时间片轮流交替进行，从逻辑上看那些任务是同时执行</li>
<li><strong>并行</strong>：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的 “同时进行”</li>
<li><strong>串行</strong>：有n个任务，由一个线程按顺序执行，由于任务、方法都在一个线程执行，所以不会存在线程不安全的情况，也就输不存在临界区的问题</li>
</ul>
<hr>
<h3 id="Java怎么进行并发控制？"><a class="headerlink" href="#Java怎么进行并发控制？"></a>Java怎么进行并发控制？</h3>
<p>答：</p>
<p>并发控制中的锁一般有两种，<strong>悲观锁</strong> 和 <strong>乐观锁</strong>，一般来说悲观锁是基于 <code>Monitor</code> 实现的，这在Java中分别对应 <code>synchronized</code> 关键字和 <code>AQS</code>。乐观锁是基于 <code>CAS</code> + 自旋 来实现的，Java中用的比较多的是 并发原子类。</p>
<hr>
<h3 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a class="headerlink" href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3>
<p>答：</p>
<ul>
<li><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如：行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如：Java里面的同步原语 synchronized 关键字的实现也是悲观锁</li>
</ul>
</li>
<li><strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制
<ul>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write condition 机制，其实都是提供的乐观锁。在 Java中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的</li>
</ul>
</li>
</ul>
<hr>
<h3 id="死锁与活锁的区别，死锁与饥饿的区别？"><a class="headerlink" href="#死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h3>
<p>答：</p>
<ul>
<li><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</li>
<li><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</li>
<li><strong>活锁和死锁的区别在于</strong>：处于活锁的实体是在不断的改变状态，这就是所谓的 “活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能</li>
<li><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态
<ul>
<li><strong>Java 中导致饥饿的原因</strong>：
<ol>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</li>
<li>线程在等待一个本身也处于永久等待完成的对象（比如：调用这个对象的 wait 方法），因为其他线程总是被持续地获得唤醒</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="JMM"><a class="headerlink" href="#JMM"></a>JMM</h2>
<h3 id="什么是Java内存模型（JMM）？"><a class="headerlink" href="#什么是Java内存模型（JMM）？"></a>什么是Java内存模型（JMM）？</h3>
<p>答：JMM决定一个线程对共享变量的写入时，能对另一个线程可见</p>
<ul>
<li>从抽象角度来看，JMM定义了线程和主内存之间的抽象关系，即：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全的问题</li>
<li>本地内存是JMM的一个抽象概念，并不是真正存在的，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</li>
<li>从下图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量</li>
</ol>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241107161706352.png" alt="JMM原理" loading="lazy"></p>
<hr>
<h3 id="什么是-Happens-Before-原则？"><a class="headerlink" href="#什么是-Happens-Before-原则？"></a>什么是 Happens-Before 原则？</h3>
<p>答：</p>
<ul>
<li>happens-before 字面意思就是先行发生，可以理解为 A happens before B，就是 A 发生在 B 之后</li>
<li>happens-before（HB）是在 JMM 中的一个很重要的规则，即：一个操作的结果对于另一个操作是可见的，用来指定两个操作之间的执行顺序</li>
</ul>
<hr>
<h2 id="synchronized关键字"><a class="headerlink" href="#synchronized关键字"></a>synchronized关键字</h2>
<h3 id="说说自己是怎么使用synchronized关键字，synchronized关键字最主要的三个使用方式？"><a class="headerlink" href="#说说自己是怎么使用synchronized关键字，synchronized关键字最主要的三个使用方式？"></a>说说自己是怎么使用synchronized关键字，synchronized关键字最主要的三个使用方式？</h3>
<p>答：</p>
<ol>
<li><strong>修饰实例方法</strong>：调用某对象的该方法前 <strong>获取该对象实例的锁</strong></li>
<li><strong>修饰静态方法</strong>：调用某对象的该方法前 <strong>获取该类的锁</strong>
<ul>
<li>两个线程分别执行同一个对象synchronized修饰的实例方法和静态方法时不会发生互斥，因为锁的资源不同，一个锁了对象实例，一个锁了类</li>
</ul>
</li>
<li><strong>修饰代码块</strong>：对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象
<ul>
<li><code>synchronized(对象的引用)</code> 锁的是对象实例，<code>synchronized(类.class)</code> 锁的是类</li>
<li>尽量不要使用 <code>synchronized(String a)</code>，因为 JVM 中，字符串常量池具有缓存功能</li>
<li><code>synchronized</code> 不能修饰构造方法，也没必要修饰，构造方法本身就是线程安全的</li>
</ul>
</li>
</ol>
<hr>
<h3 id="说一下synchronized底层实现原理？"><a class="headerlink" href="#说一下synchronized底层实现原理？"></a>说一下synchronized底层实现原理？</h3>
<p>答：</p>
<p>首先，synchronized的底层语义是通过一个 <strong>monitor</strong>（监视器锁）的对象完成的，每个对象都有一个 <code>monitor</code>（监视器锁）。每个 <code>synchronized</code> 修饰过的代码当它的 <code>monitor</code> 被占用时就会处于锁定状态，当同步代码执行完成，释放 <code>monitor</code> 后，其他线程重新尝试获取 <code>monitor</code> 的所有权</p>
<p>具体过程：</p>
<ol>
<li>如果 <code>monitor</code> 的进入数为0，则该线程进入 <code>monitor</code>，然后将进入数设置为1，该线程即为 <code>monitor</code> 的所有者</li>
<li>如果线程已经占有该 <code>monitor</code>，只是重新进入，则进入 <code>monitor</code> 的进入数加1</li>
<li>如果其他线程已经占用了 <code>monitor</code>，则该线程进入阻塞状态，直到 <code>monitor</code> 的进入数为0，再重新尝试获取 <code>monitor</code> 的所有权</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241104165125565.png" alt="synchronized原理" loading="lazy"></p>
<hr>
<h3 id="synchronized可重入的原理？"><a class="headerlink" href="#synchronized可重入的原理？"></a>synchronized可重入的原理？</h3>
<p>答：</p>
<p><strong>重入锁</strong> 指：一个线程获取到该锁之后，该线程可以继续获得该锁</p>
<ul>
<li>底层原理维护一个计数器，当线程获取该锁时，计数器加1，再次获得该锁时继续加1，对同一个对象反复加锁只会导致monitor计数器加1，释放该锁时，计数器减1，当计数器值为0时，表明该锁未被任何线程所持有，其他线程可以竞争获取锁</li>
</ul>
<hr>
<h3 id="多线程中synchronized锁升级的原理是什么？"><a class="headerlink" href="#多线程中synchronized锁升级的原理是什么？"></a>多线程中synchronized锁升级的原理是什么？</h3>
<p>答：</p>
<p><strong>synchronized 锁升级的原理</strong>：在锁对象的对象头里面有一个 <code>threadid</code> 字段，在第一次访问的时候 <code>threadid</code>为空，jvm 让其持有偏向锁，并将 <code>threadid</code> 设置为其线程 id，再次进入时会先判断 <code>threadid</code> 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则 <strong>升级偏向锁为轻量级锁</strong>，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时会把锁 <strong>从轻量级升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级</p>
<ol>
<li>
<p><strong>无锁状态</strong>：对象刚创建时，没有任何线程来竞争锁，此时为无锁状态</p>
</li>
<li>
<p><strong>偏向锁</strong>：当第一个线程尝试获取锁时，JVM会将锁升级为偏向锁，并将该线程的 ID 记录到对象的 Mark Word 中（对象头通常由两部分组成：<strong>Mark Word</strong> 和 <strong>类型指针（Class Pointer）</strong>）。这样，只要该线程再次尝试获取锁，JVM就会检查 Mark Word 中的 线程 ID 是否与 当前线程 ID 相同，如果相同则可以直接获取锁，无需进行任何同步操作。这种策略对于只有一个线程频繁访问的场景非常高效</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241104171122075.png" alt="Java对象头结构" loading="lazy"></p>
</li>
<li>
<p><strong>轻量级锁</strong>：如果有多个线程交替访问同一个对象，偏向锁会失效。此时，JVM会将锁升级为轻量级锁，轻量级锁使用了一种称为 “自旋等待” 的策略，即：当线程尝试获取锁但失败时，就会进入一个循环，不断再次尝试获取锁，而不是立刻阻塞。这种策略对于短时间的锁竞争非常有效，可以避免线程频繁地阻塞和唤醒</p>
</li>
<li>
<p><strong>重量级锁</strong>：如果自旋等待持续较长时间仍未获取锁，JVM就会将锁升级为重量级锁。这时，线程的竞争就会更加激烈，JVM就会 <strong>使用操作系统的互斥量（如互斥锁或者条件变量）来实现同步</strong>。线程的阻塞和唤醒会涉及到操作系统的内核态和用户态切换，因此性能开销较大</p>
</li>
</ol>
<hr>
<h3 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B"><a class="headerlink" href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B?</h3>
<p>答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<hr>
<h2 id="volatile关键字"><a class="headerlink" href="#volatile关键字"></a>volatile关键字</h2>
<h3 id="volatile关键字的作用？"><a class="headerlink" href="#volatile关键字的作用？"></a>volatile关键字的作用？</h3>
<p>答：</p>
<ul>
<li>首先对于可见性，Java提供了 <code>volatile</code> 关键字来 <strong>保证可见性</strong> 和 <strong>禁止指令重排</strong>
<ul>
<li><code>volatile</code> 确保一个线程的修改能对其他线程是可见的。当一个共享变量被 <code>volatile</code> 修饰时，它会保证修改的值立刻被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值</li>
</ul>
</li>
<li>从实践角度而言，<code>volatile</code> 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见<code>java.util.concurrent.atomic</code>包下的类，比如：<code>AtomicInteger</code></li>
<li><code>volatile</code> 常用于 <strong>多线程环境下的单次操作（单次读或者单次写）</strong></li>
</ul>
<hr>
<h3 id="volatile变量和atomic原子类变量有什么不同？"><a class="headerlink" href="#volatile变量和atomic原子类变量有什么不同？"></a>volatile变量和atomic原子类变量有什么不同？</h3>
<p>答：</p>
<ul>
<li>
<p><code>volatile</code> 变量 <strong>可以确保可见性，但不能保证原子性</strong></p>
<ul>
<li>
<p>例如：用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取count -&gt; count++ -&gt; 赋值count，不能保证其原子性</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>而 <code>AtomicInteger</code> 类提供的 <code>atomic</code> 方法可以让这种操作具有原子性</p>
<ul>
<li>例如：<code>getAndIncrement()</code> 方法会原子性的进行增量操作把当前值加1，其他数据类型和引言变量也可以进行相似操作</li>
</ul>
</li>
</ul>
<hr>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗？"><a class="headerlink" href="#volatile-能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h3>
<p>答：</p>
<ul>
<li>关键字 volatile 的主要作用：是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步</li>
<li>虽然 volatile 只能保证可见性不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性
<ul>
<li>原因：double、long本身有64位宽，对于Java虚拟机，目前是将32位的读写作为原子操作，所以double和long的读写需要分为两次，每次读写32位。volatile对于double、long的读写原子性仅指单次读或单次写，如果一个操作同时具有读写，则不能保证整体的原子性，如i++；</li>
</ul>
</li>
</ul>
<hr>
<h3 id="synchronized-和-volatile-的区别是什么？"><a class="headerlink" href="#synchronized-和-volatile-的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3>
<p>答：</p>
<ul>
<li><code>synchronized</code> 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程</li>
<li><code>volatile</code> 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性，禁止指令重排序</li>
<li>区别：
<ol>
<li><code>volatile</code> 是变量修饰符；<code>synchronized</code> 可以修饰方法，代码块</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li>
<li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化</li>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code> 性能肯定比 <code>synchronized</code> 关键字要好。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块。<code>synchronized</code> 关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<code>synchronized</code> 关键字的场景还是更多一些</li>
</ol>
</li>
</ul>
<hr>
<h2 id="final关键字"><a class="headerlink" href="#final关键字"></a>final关键字</h2>
<h3 id="final关键字有哪些用法？"><a class="headerlink" href="#final关键字有哪些用法？"></a>final关键字有哪些用法？</h3>
<p>答：</p>
<ul>
<li><strong>修饰类</strong>：当某个类的整体定义为 final 时，就表明了你不打算继承该类，而且不允许别人也这么做。即这个类不能有子类的，不可以继承</li>
<li><strong>修饰方法</strong>：父类的 final 方法是不能被子类重写</li>
<li><strong>修饰参数</strong>：Java允许在参数列表中以声明的方式将参数指明为 final，这意味着无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据</li>
<li><strong>修饰变量</strong>：变量的值无法更改</li>
</ul>
<hr>
<h3 id="所有的final修饰的字段都是编译器常量吗？"><a class="headerlink" href="#所有的final修饰的字段都是编译器常量吗？"></a>所有的final修饰的字段都是编译器常量吗？</h3>
<p>答：</p>
<ul>
<li>不是</li>
<li>不是所有的final修饰的字段都是编译期常量，<strong>只有在被初始化后无法被更改</strong></li>
</ul>
<hr>
<h2 id="线程"><a class="headerlink" href="#线程"></a>线程</h2>
<h3 id="线程和进程的区别？"><a class="headerlink" href="#线程和进程的区别？"></a>线程和进程的区别？</h3>
<p>答：</p>
<ul>
<li>定义区别
<ul>
<li>线程：进程中的一个执行任务（控制单元），它负责在程序里独立执行</li>
<li>进程：一个在内存中运行的应用程序，每一个正在系统上运行的程序都是一个进程</li>
<li>一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享数据</li>
</ul>
</li>
<li>根本区别
<ul>
<li>进程是 <strong>操作系统资源分配</strong> 的基本单位</li>
<li>线程是 <strong>处理器任务调度和执行</strong> 的基本单位</li>
</ul>
</li>
<li>资源开销
<ul>
<li>每个进程都有独立的代码和数据空间（程序的上下文），程序之间的切换会有较大的开销</li>
<li>线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换开销小</li>
</ul>
</li>
<li>包含关系
<ul>
<li>如果一个进程内含有多个线程，则执行过程不是一条线，而是多条线（线程）共同完成</li>
<li>线程是进程的一部分，所以线程也可以被称为轻权进程或者轻量级进程</li>
</ul>
</li>
<li>内存分配
<ul>
<li>同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的</li>
</ul>
</li>
<li>影响关系
<ul>
<li>一个进程崩溃后，在保护模型下不会对其他进程产生影响</li>
<li>一个线程崩溃后有可能导致整个进程都死掉</li>
<li>因此，多进程要比多线程更健壮</li>
</ul>
</li>
<li>执行过程
<ul>
<li>每个独立的进程有程序的入口、顺序执行序列和程序出口</li>
<li>线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="什么是上下文切换？"><a class="headerlink" href="#什么是上下文切换？"></a>什么是上下文切换？</h3>
<p>答：</p>
<ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是 <strong>为每个线程分配时间片并轮转的形式</strong>。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换</li>
<li>简单来说，<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态</strong>。任务从保存到再加载的过程就是一次上下文切换。上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作</li>
<li><code>Linux</code> 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，<strong>其上下文切换和模式切换的时间消耗非常少</strong></li>
</ul>
<hr>
<h3 id="守护线程和用户线程有什么区别？"><a class="headerlink" href="#守护线程和用户线程有什么区别？"></a>守护线程和用户线程有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>用户（User）线程</strong>：运行在 <strong>前台</strong>，执行具体的任务，如：程序的主线程、连接网络的子线程等都是用户线程</li>
<li><strong>守护（Daemon）线程</strong>：运行在 <strong>后台</strong>，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的“佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>
</ul>
<hr>
<h3 id="什么是死锁？"><a class="headerlink" href="#什么是死锁？"></a>什么是死锁？</h3>
<p>答：</p>
<ul>
<li>死锁：是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）</li>
<li>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</li>
</ul>
<hr>
<h3 id="形成死锁的四个必要条件是什么？"><a class="headerlink" href="#形成死锁的四个必要条件是什么？"></a>形成死锁的四个必要条件是什么？</h3>
<p>答：</p>
<ul>
<li><strong>互斥条件</strong>：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等待，直至占有资源的进程用完释放</li>
<li><strong>请求并保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li>
<li><strong>不可抢占条件</strong>：别人已经占有了某项资源，不能因为自己也需要该资源，就去把别人的资源抢过来</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系（比如：一个进程集合，A在等B，B在等C，C在等A）</li>
</ul>
<hr>
<h3 id="如何避免线程死锁？"><a class="headerlink" href="#如何避免线程死锁？"></a>如何避免线程死锁？</h3>
<p>答：</p>
<ul>
<li>避免一个线程同时获得多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，<strong>尽量保证每个锁只占用一个资源</strong></li>
<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制</li>
</ul>
<hr>
<h3 id="Java线程有哪些状态？"><a class="headerlink" href="#Java线程有哪些状态？"></a>Java线程有哪些状态？</h3>
<p>答：</p>
<ol>
<li><code>NEW</code>：<strong>初始状态</strong>，线程被创建，但是还没有调用 <code>start()</code> 方法</li>
<li><code>RUNNABLE</code>：<strong>运行状态</strong>，Java线程将操作系统中的就绪和运行两种状态笼统地称为 “运行中”</li>
<li><code>BLOCKED</code>：<strong>阻塞状态</strong>，表示线程阻塞于锁</li>
<li><code>WAITING</code>：<strong>等待状态</strong>，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些等待动作（通知或中断）</li>
<li><code>TIME_WAITING</code>：<strong>超时等待状态</strong>，该状态不同于WAITING状态，它可以在指定的时间自行返回</li>
<li><code>TERMINATED</code>：<strong>终止状态</strong>，表示当前线程已经执行完毕</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241106142135876.png" alt="线程的流转过程" loading="lazy"></p>
<hr>
<h3 id="创建线程的几种方式？"><a class="headerlink" href="#创建线程的几种方式？"></a>创建线程的几种方式？</h3>
<p>答：</p>
<p>常用的三种方式：</p>
<ul>
<li>
<p>实现 <code>Runnable</code> 接口</p>
<ol>
<li>创建一个类并实现 Runnable 接口</li>
<li>在类中重写 run() 方法，定义线程执行的任务</li>
<li>创建这个类的实例，将该实例作为参数传递给 Thread 对象</li>
<li>使用 Thread 对象调用 start() 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现 <code>Callable</code> 接口，并结合Future实现</p>
<ol>
<li>实现 Callable 接口，并重写 call() 方法</li>
<li>使用 FutureTask 来封装 Callable 实例</li>
<li>创建一个 Thread，并传递 FutureTask 对象</li>
<li>启动线程，通过 FutureTask 的 get() 方法获取返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Thread executed and returned result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());  <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>继承 <code>Thread</code> 类</p>
<ul>
<li>继承 <code>Thread</code> 类并重写 <code>run</code> 方法，这是最直接的一种方式。创建的线程类可以通过调用 <code>start()</code> 方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一种是通过线程池的方式创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建3个核心线程数，并使用</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 执行具体的任务</span></span><br><span class="line">executorService.submit(() -&gt; &#123;方法执行体&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过shutdown等待所有任务完成后，关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>对比：</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>：简单直接，但不支持多继承</li>
<li><strong>实现 <code>Runnable</code> 接口</strong>：<strong>推荐使用的方式</strong>，<strong>支持多继承</strong></li>
<li><strong>使用 <code>Callable</code> 和 <code>Future</code></strong>：适用于需要返回值或处理异常的场景</li>
</ul>
<p><strong>实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，最后还是需要通过 Thread 来调用，可以说任务是通过线程驱动从而执行的</strong></p>
<hr>
<h3 id="说一下Runnable和Callable有什么区别？"><a class="headerlink" href="#说一下Runnable和Callable有什么区别？"></a>说一下Runnable和Callable有什么区别？</h3>
<p>答：</p>
<ul>
<li>
<p><strong>相同点</strong>：</p>
<ol>
<li>都是接口</li>
<li>都可以编写多线程程序</li>
<li>都采用<code>Thread.start()</code>启动线程</li>
</ol>
</li>
<li>
<p><strong>主要区别</strong>：</p>
<ol>
<li>
<p>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和 Future、FutureTask 配合可以用来获取 异步执行 的结果</p>
</li>
<li>
<p>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</p>
<p>注：Callable 接口支持返回执行结果，需要调用 <code>FutureTask.get()</code> 得到，此方法会阻塞主线程的继续往下执行，如果不调用不会阻塞</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="什么是Callable和Future？什么是FutureTask？"><a class="headerlink" href="#什么是Callable和Future？什么是FutureTask？"></a>什么是Callable和Future？什么是FutureTask？</h3>
<p>答：</p>
<ul>
<li>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 <strong>Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值</strong></li>
<li>Future 接口表示<strong>异步任务</strong>，是一个可能还没有完成的异步任务的结果。所以说 <strong>Callable 用于产生结果，Future 用于获取结果</strong>。</li>
<li>FutureTask 表示一个<strong>异步运算的任务</strong>。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。<strong>一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中</strong></li>
</ul>
<hr>
<h3 id="sleep-和-wait-有什么区别？"><a class="headerlink" href="#sleep-和-wait-有什么区别？"></a>sleep()和 wait()有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>相同点</strong>：两者都可以<strong>暂停线程的执行</strong></li>
<li><strong>类的不同</strong>：sleep() 是 Thread 线程类的静态方法，wait()是 Object 类的方法。</li>
<li><strong>是否释放锁</strong>：sleep() 不释放锁；wait() 释放锁。</li>
<li><strong>用途不同</strong>：wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行</li>
<li><strong>用法不同</strong>：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者  notifyAll() 方法；sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code>  超时后线程会自动苏醒</li>
</ul>
<hr>
<h3 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a class="headerlink" href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h3>
<p>答：</p>
<ul>
<li>因为Java所有类的都继承了Object，<strong>Java想让任何对象都可以作为锁</strong>，并且 wait()，notify() 等方法用于等待对象的锁或者唤醒线程，在 Java 的线程类中并没有可供所有对象使用的锁，所以任意对象都可调用的方法一定定义在Object类中</li>
<li>有的人会说，既然是线程放弃对象锁，那也可以把 wait() 定义在 Thread 类里面啊，新定义的线程继承于 Thread 类，也不需要重新定义 wait() 方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂</li>
</ul>
<hr>
<h3 id="线程的-sleep-方法和-yield-方法有什么区别？"><a class="headerlink" href="#线程的-sleep-方法和-yield-方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h3>
<p>答：</p>
<ol>
<li><code>sleep()</code> 方法给其他线程运行机会时<strong>不考虑线程的优先级</strong>，因此会给低优先级的线程以运行的机会；<code>yield()</code> 方法<strong>只会给相同优先级或更高优先级的线程以运行的机会</strong></li>
<li>线程执行 <code>sleep()</code> 方法后<strong>转入阻塞（超时等待状态）</strong>，而执行 <code>yield()</code> 方法后<strong>转入就绪（ready）状态</strong></li>
<li><code>sleep()</code> 方法声明<strong>抛出 InterruptedException</strong>，而 <code>yield()</code> 方法 <strong>没有声明任何异常</strong></li>
<li><code>sleep()</code> 方法比 <code>yield()</code> 方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常<strong>不建议使用 <code>yield()</code> 方法来控制并发线程的执行</strong></li>
</ol>
<hr>
<h3 id="如何停止一个正在运行的线程？"><a class="headerlink" href="#如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3>
<p>答：</p>
<p>在java中有以下3种方法可以终止正在运行的线程：</p>
<ol>
<li><strong>使用退出标志</strong>，使线程正常退出，也就是当 run 方法完成后线程终止</li>
<li><strong>使用 stop 方法强行终止</strong>，但是不推荐这个方法，因为 stop 和 suspend 及 resume 一样都是过期作废的方法</li>
<li><strong>使用 interrupt 方法中断线程</strong></li>
</ol>
<hr>
<h3 id="Java中interrupted和isInterrupted方法的区别？"><a class="headerlink" href="#Java中interrupted和isInterrupted方法的区别？"></a>Java中interrupted和isInterrupted方法的区别？</h3>
<p>答：</p>
<ul>
<li><code>interrupt</code>：用于中断线程，调用该方法的线程的状态位将被置为 “中断” 状态
<ul>
<li>注：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出<code>interruptedException</code>的方法）就是在监视线程的中断状态，一旦线程中断状态被置为 “中断状态”，就会抛出中断异常</li>
</ul>
</li>
<li><code>interrupted</code>：是静态方法，查看当前中断信号是true还是false并且<strong>清除中断信号</strong>
<ul>
<li>如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了</li>
</ul>
</li>
<li><code>isinterrupted</code>：可以返回当前中断信号是true还是false，与interrupted最大的区别是<strong>不会清除中断信号</strong></li>
</ul>
<hr>
<h3 id="什么是阻塞式方法？"><a class="headerlink" href="#什么是阻塞式方法？"></a>什么是阻塞式方法？</h3>
<p>答：<strong>阻塞式方法</strong>：是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept() 方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回</p>
<hr>
<h3 id="Java中怎样唤醒一个阻塞的线程？"><a class="headerlink" href="#Java中怎样唤醒一个阻塞的线程？"></a>Java中怎样唤醒一个阻塞的线程？</h3>
<p>答：</p>
<ul>
<li>首先，<code>wait()</code>、<code>notify()</code> 方法是针对对象的，调用任意对象的 <code>wait()</code> 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 <code>notify()</code> 方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行</li>
<li>其次，<strong>wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个</strong>，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放</li>
</ul>
<hr>
<h3 id="notify-和-notifyAll-有什么区别？"><a class="headerlink" href="#notify-和-notifyAll-有什么区别？"></a>notify()和 notifyAll()有什么区别？</h3>
<p>答：</p>
<ul>
<li>如果线程调用了对象的 <code>wait()</code> 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁</li>
<li><code>notifyAll()</code> 会唤醒所有的线程，<code>notify()</code> 只会唤醒一个线程</li>
<li><code>notifyAll()</code> 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行如果不成功则留在锁池等待锁被释放后再次参与竞争。而 <code>notify()</code> 只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制</li>
</ul>
<hr>
<h3 id="Java是如何实现多线程之间的通讯与协作？"><a class="headerlink" href="#Java是如何实现多线程之间的通讯与协作？"></a>Java是如何实现多线程之间的通讯与协作？</h3>
<p>答：</p>
<ul>
<li>可以通过 <strong>中断</strong> 和 <strong>共享变量</strong> 的方式实现线程间的通讯和协作
<ul>
<li>例如：最经典的 生产者-消费者 模型，这种互相通信的过程就是线程间的协作</li>
</ul>
</li>
<li>Java中线程通信协作的最常见方式：
<ol>
<li>synchronized加锁的线程的 Object 类的  <code>wait()</code>/<code>notify()</code>/<code>notifyAll()</code></li>
<li>ReentrantLock类加锁的线程的 Condition 类的 <code>await()</code>/<code>signal()</code>/<code>signalAll()</code></li>
</ol>
</li>
<li>线程间直接的数据交换：
<ul>
<li>通过管道进行线程间通：字节流、字符流</li>
</ul>
</li>
</ul>
<hr>
<h3 id="线程之间如何通信及线程之间如何同步？"><a class="headerlink" href="#线程之间如何通信及线程之间如何同步？"></a>线程之间如何通信及线程之间如何同步？</h3>
<p>答：</p>
<ul>
<li><strong>通信</strong>：是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：<strong>共享内存</strong>（wait/notify 属于Java提供的一种线程间通信的具体技术手段）和 <strong>消息传递</strong>。<strong>同步</strong>：是指程序中用于控制不同线程间操作发生相对顺序的机制</li>
<li>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行的，整个通信过程对程序员完全透明</li>
<li>在共享内存并发模型里，同步是显示进行的，必须显示指定某个方法或者某段代码需要在线程之间互斥执行</li>
</ul>
<hr>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a class="headerlink" href="#同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3>
<p>答：</p>
<ul>
<li><strong>同步块是更好的选择</strong>，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁</li>
<li>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁</li>
<li><strong>请知道一条原则：同步的范围越小越好</strong></li>
</ul>
<hr>
<h3 id="什么是线程同步和线程互斥，有哪几种实现方式？"><a class="headerlink" href="#什么是线程同步和线程互斥，有哪几种实现方式？"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h3>
<p>答：</p>
<ul>
<li><strong>线程同步</strong>：当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即：在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果</li>
<li><strong>线程互斥</strong>：是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步</li>
<li><strong>线程间的同步方法大体可分为两类：用户模式 和 内核模式</strong>
<ul>
<li>顾名思义，内核模式：就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式：就是不需要切换到内核态，只在用户态完成操作</li>
<li>用户模式下的方法有：原子操作（例如：一个单一的全局变量），临界区</li>
<li>内核模式下的方法有：事件，信号量，互斥量</li>
</ul>
</li>
<li><strong>实现线程同步的方法</strong>：
<ul>
<li><strong>同步代码方法</strong>：<code>sychronized</code> 关键字修饰的方法</li>
<li><strong>同步代码块</strong>：<code>sychronized</code> 关键字修饰的代码块</li>
<li><strong>使用特殊变量域 <code>volatile</code> 实现线程同步</strong>：<code>volatile</code> 关键字为域变量的访问提供了一种免锁机制</li>
<li><strong>使用重入锁实现线程同步</strong>：<code>reentrantlock</code> 类是可重入、互斥、实现了 <code>lock</code> 接口的锁他与  <code>sychronized</code> 方法具有相同的基本行为和语义</li>
</ul>
</li>
</ul>
<hr>
<h3 id="在监视器（Monitor）内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a class="headerlink" href="#在监视器（Monitor）内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器（Monitor）内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3>
<p>答：</p>
<ul>
<li>在 Java 虚拟机中，监视器 和 锁 在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码</li>
<li>一旦方法或者代码块被 <code>synchronized</code>  修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</li>
<li>另外 Java 还提供了 显式监视器（<code>Lock</code>）和 隐式监视器（<code>synchronized</code>）两种锁方案</li>
</ul>
<hr>
<h3 id="如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么？"><a class="headerlink" href="#如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么？"></a>如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么？</h3>
<p>答：</p>
<p>有两种可能:</p>
<ol>
<li>如果使用的是无界队列 <code>LinkedBlockingQueue</code>，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 <code>LinkedBlockingQueue</code> 可以近乎认为是一个<strong>无穷大</strong>的队列，可以无限存放任务</li>
<li>如果使用的是有界队列，比如： <code>ArrayBlockingQueue</code>，任务首先会被添加到 <code>ArrayBlockingQueue</code> 中，<code>ArrayBlockingQueue</code> 满了，会根据 <code>maximumPoolSize</code> 的值增加线程数量，如果增加了线程数量还是处理不过来，<code>ArrayBlockingQueue</code> 继续满，那么则会使用拒绝策略 <code>RejectedExecutionHandler</code> 处理满了的任务，默认是 <code>AbortPolicy</code></li>
</ol>
<hr>
<h3 id="在Java中怎么保证多线程的安全？"><a class="headerlink" href="#在Java中怎么保证多线程的安全？"></a>在Java中怎么保证多线程的安全？</h3>
<p>答：</p>
<ul>
<li>
<p>方法一：<strong>使用安全类</strong>，比如：<code>java.util.concurrent</code> 下的类，使用原子类 <code>AtomicInteger</code></p>
</li>
<li>
<p>方法二：<strong>使用自动锁</strong> <code>synchronized</code></p>
</li>
<li>
<p>方法三：<strong>使用手动锁</strong> <code>Lock</code>，手动锁 Java 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// ToDo: handle exception</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="你对线程优先级的理解是什么？"><a class="headerlink" href="#你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3>
<p>答：</p>
<ul>
<li>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的（OS dependent）。我们可以定义线程的优先级，但是<strong>这并不能保证高优先级的线程会在低优先级的线程前执行</strong>。线程优先级是一个 int 变量（从 1-10），1 代表最低优先级，10 代表最高优先级</li>
<li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，<strong>一般无需设置线程优先级</strong></li>
<li>当然，如果你真的想设置优先级可以通过 <code>setPriority()</code> 方法设置，但是设置了不一定会改变，这个是不准确的</li>
</ul>
<hr>
<h3 id="线程类的构造方法、静态块是被哪个线程调用的？"><a class="headerlink" href="#线程类的构造方法、静态块是被哪个线程调用的？"></a>线程类的构造方法、静态块是被哪个线程调用的？</h3>
<p>答：</p>
<ul>
<li>线程类的构造方法、静态块是<strong>被 new 这个线程类所在的线程</strong>所调用的，而 run 方法里面的代码才是<strong>被线程自身所调用的</strong></li>
<li>举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：
<ol>
<li>Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run() 方法是 Thread2 自己调用的</li>
<li>Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run() 方法是 Thread1 自己调用的</li>
</ol>
</li>
</ul>
<hr>
<h3 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"><a class="headerlink" href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</h3>
<p>答：</p>
<ul>
<li><strong>dump文件</strong>：是进程的内存镜像，可以把程序的执行状态通过调试器保存到 dump 文件中</li>
<li>在 Linux 下，可以通过命令 <code>jstack -| PID</code> （Java 进程的进程 ID）来获取 Java应用的 dump 文件</li>
<li>在 Windows 下，可以按下 <code>Ctrl + Break</code> 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置</li>
</ul>
<hr>
<h3 id="一个线程运行时发生异常会怎样？"><a class="headerlink" href="#一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h3>
<p>答：</p>
<ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li><code>Thread.UncaughtExceptionHandler</code>：是用于<strong>处理未捕获异常造成线程突然中断情况的一个内嵌接口</strong>，当一个未捕获异常将造成线程中断的时候，JVM 会使用 <code>Thread.getUncaughtExceptionHandler()</code> 来查询线程的 <code>UncaughtExceptionHandler</code>，并将线程和异常作为参数传递给 handler 的 <code>UncaughtException()</code> 方法进行处理</li>
</ul>
<hr>
<h3 id="Java-线程数过多会造成什么异常？"><a class="headerlink" href="#Java-线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h3>
<p>答：</p>
<ul>
<li>线程的生命周期开销非常高</li>
<li>消耗过多的 CPU</li>
<li>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU 资源时还将产生其他性能的开销</li>
<li>降低 JVM 稳定性</li>
<li>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括：JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 <code>OutOfMemoryError</code> 异常</li>
</ul>
<hr>
<h3 id="多线程的常用方法？"><a class="headerlink" href="#多线程的常用方法？"></a>多线程的常用方法？</h3>
<p>答：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241107153941650.png" alt="多线程的常用方法" loading="lazy"></p>
<hr>
<h3 id="线程B-怎么知道线程-A-修改了变量？"><a class="headerlink" href="#线程B-怎么知道线程-A-修改了变量？"></a>线程B 怎么知道线程 A 修改了变量？</h3>
<p>答：</p>
<ul>
<li><code>volatile</code> 修饰变量</li>
<li><code>synchronized</code> 修饰修改变量的方法</li>
<li><code>wait/notify</code></li>
</ul>
<hr>
<h2 id="ThreadLocal"><a class="headerlink" href="#ThreadLocal"></a>ThreadLocal</h2>
<h3 id="什么是ThreadLocal？说一说你对ThreadLocal的理解"><a class="headerlink" href="#什么是ThreadLocal？说一说你对ThreadLocal的理解"></a>什么是ThreadLocal？说一说你对ThreadLocal的理解</h3>
<p>答：</p>
<ul>
<li><code>ThreadLocal</code> 是线程变量，意思是 <code>ThreadLocal</code> 中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。<code>ThreadLocal</code> 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量</li>
<li>Thread类有两个变量：<code>threadLocals</code> 和 <code>inheritableThreadLocals</code></li>
<li>这两个变量默认为null，只有当该线程调用了 <code>ThreadLocal</code> 类的 <code>get/set</code> 方法时才会创建他们，而调用<code>ThreadLocal</code> 的 <code>get/set</code> 实际上是调用 <code>ThreadLocalMap</code> 的 <code>get/set</code></li>
<li><code>ThreadLocalMap</code> 可理解成给 <code>ThreadLocal</code> 定制化的 <code>HashMap</code></li>
<li>最终的变量放在了线程的 <code>ThreadLocalMap</code> 中，而不是 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 只是对其进行封装，向其传递变量值</li>
<li>用一个场景分析 <code>ThreadLocal</code> 的 <code>get/set</code> 流程：
<ol>
<li>首先在所有线程外部创建一个共享的 <code>ThreadLocal</code> 对象，记为<code>TL1</code>，在一个线程中调用 <code>TL1.get()</code> 时首先获取到当前线程对象，记为 <code>t</code></li>
<li>然后判断 <code>t.threadLocals</code> 是否为 null，如果为 null，就在 t 中创建一个新的 <code>ThreadLocalMap</code> 对象赋值给 <code>t.threadLocals</code>，并将 <code>&lt;TL1,null&gt;</code> 插入其中，最后 get 方法返回 null，如果不为 null，则尝试获取 <code>threadLocals</code> 中 TL1 所在的键值对，如果该键值对为 null，则向 threadLocals 中通过 set 方法插入 <code>&lt;TL1,null&gt;</code>，最后返回 null，如果键值对不为 null，则返回键值对中的值</li>
<li>调用 set 方法时，流程和 get 基本一致，只是从读变成了写</li>
<li>这样就可以实现不同线程访问同一个 ThreadLocal(TL1) 能拿到各自向其中存放的值</li>
</ol>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241107160344629.png" alt="ThreadLocal的get/set流程" loading="lazy"></p>
<hr>
<h3 id="为什么ThreadLocal会造成内存泄漏？如何解决"><a class="headerlink" href="#为什么ThreadLocal会造成内存泄漏？如何解决"></a>为什么ThreadLocal会造成内存泄漏？如何解决</h3>
<p>答：</p>
<ul>
<li><code>ThreadLocalMap</code> 中的 <code>key</code>为 <code>ThreadLocal</code> 的<strong>弱引用</strong>，<code>value</code> 为<strong>强引用</strong></li>
<li>如果 <code>ThreadLocal</code> 对象没有被外部强引用，垃圾回收时 <code>key</code> 会被清理掉，但 <code>value</code> 不会。这时<code>key=null</code>，而 value 不为 null，如果不做处理，value 将永远不会被GC掉，就有可能造成内存泄漏</li>
<li>因为 ThreadLocal 本身不存储对象，是调用 Thread 中的 ThreadLocalMaps 来保存，而 Thread 强引用 ThreadLocalMaps 对象，如果 Thread 对象生命周期过长，不能及时被回收，就会导致 ThreadLocalMaps 对象里 Entry 的 value 存在内存泄露的可能</li>
<li>ThreadLocal 自身会在调用 <code>get/set/remove</code> 时清理掉 key 为 null 的 entry，如果编写的 run 方法里不会再使用 ThreadLocal 对象，最好手动调用 remove</li>
</ul>
<hr>
<h3 id="为什么用ThreadLocal不用线程成员变量？"><a class="headerlink" href="#为什么用ThreadLocal不用线程成员变量？"></a>为什么用ThreadLocal不用线程成员变量？</h3>
<p>答：</p>
<ul>
<li>如果用成员变量，那么成员变量必须在 Thread 里，不能在 Runnable 里，因为一个 Runnable 对象可以被多个 Thread 执行</li>
<li>而如果在 Thread 中添加成员变量，就要加强 Thread 和 Runnable 的耦合，将 Thread 作为 Runnable 的成员变量，并在 Runnable 中调用具体的 Thread 变量，如果执行 Runnable 的 Thread 可能有很多子类，不同子类有不同的成员变量，则要在 run 方法中进行复杂处理，扩展性较低，不利于维护。而 ThreadLocal 就是将成员变量统一为一个 Map 放到线程里</li>
</ul>
<hr>
<h2 id="Lock"><a class="headerlink" href="#Lock"></a>Lock</h2>
<h3 id="Lock接口和synchronized同步，对比它有什么优势？"><a class="headerlink" href="#Lock接口和synchronized同步，对比它有什么优势？"></a>Lock接口和synchronized同步，对比它有什么优势？</h3>
<p>答：</p>
<ul>
<li>Lock 接口对比同步方法和同步块提供了更多扩展性的锁操作，他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象</li>
<li><strong>优势</strong>：
<ol>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁</li>
</ol>
</li>
<li>整体来说，Lock 是 synchronized 的拓展版，Lock 提供了无条件、可轮询的（<code>tryLock</code>方法）、定时的（<code>tryLock</code>带参方法）、可中断的（<code>lockInterruptibly</code>）、可多条件队列的（<code>newCondition</code>方法）锁操作</li>
<li>另外，Lock实现类基本都是支持非公平锁（默认）和公平锁，synchronized只支持非公平锁</li>
</ul>
<hr>
<h3 id="synchronized-和-Lock-有什么区别？"><a class="headerlink" href="#synchronized-和-Lock-有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3>
<p>答：</p>
<ul>
<li>首先 synchronized 是<strong>Java内置关键字</strong>，在JVM层面，Lock 是个<strong>接口</strong></li>
<li>synchronized 可以<strong>给类、方法、代码块加锁</strong>；而 lock <strong>只能给代码块加锁</strong></li>
<li>synchronized <strong>不需要手动获取锁和释放锁</strong>，使用简单，发生异常会自动释放锁，不容易造成死锁；而 lock <strong>需要自己加锁和释放锁</strong>，如果使用不当没有 unLock() 去释放锁就会造成死锁。</li>
<li>通过 Lock <strong>可以知道有没有成功获取锁</strong>，而 synchronized 却<strong>无法做到</strong></li>
</ul>
<hr>
<h3 id="怎么理解Lock与AQS的关系？"><a class="headerlink" href="#怎么理解Lock与AQS的关系？"></a>怎么理解Lock与AQS的关系？</h3>
<p>答：</p>
<ul>
<li>Lock 锁是<strong>面向锁的使用者</strong>，它定义了使用者与锁的交互接口，隐藏了实现细节</li>
<li>AQS 是<strong>面向锁的实现者</strong>，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待与唤醒等底层操作</li>
<li>锁和同步器很好的隔离了使用者和实现者所需关注的领域</li>
</ul>
<hr>
<h2 id="AQS"><a class="headerlink" href="#AQS"></a>AQS</h2>
<h3 id="什么是AQS？"><a class="headerlink" href="#什么是AQS？"></a>什么是AQS？</h3>
<p>答：</p>
<ul>
<li>AQS 是多线程同步器，它是 <code>J.U.C</code> 包中多个组件的底层实现，如：<code>Lock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 等都用到了 AQS</li>
<li>从本质上来说，AQS 提供了两种锁机制，分别是 <strong>排它锁</strong> 和 <strong>共享锁</strong>
<ul>
<li><strong>排它锁</strong>：就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就多个线程中只能有一个线程获得锁资源，比如：Lock 中的 ReentrantLock 重入锁实现就是用到了AQS 中的排它锁功能</li>
<li><strong>共享锁</strong>：也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如：<code>CountDownLatch</code> 和 <code>Semaphore</code> 都是用到了 AQS 中的共享锁功能</li>
</ul>
</li>
</ul>
<hr>
<h3 id="AQS是怎么实现同步管理的？底层数据结构？"><a class="headerlink" href="#AQS是怎么实现同步管理的？底层数据结构？"></a>AQS是怎么实现同步管理的？底层数据结构？</h3>
<p>答：</p>
<ul>
<li>AQS 主要依赖一个 <strong>双向链表</strong> 和一个 <strong>volatile类型的整数state</strong> 来实现同步控制
<ul>
<li>该整数 state 用来表示同步状态，一般情况下，<code>state=0</code> 表示没有线程占用同步资源，<code>state&gt;0</code> 表示有线程占用同步资源，<code>state&gt;1</code> 表示同步资源已经被争用了多次</li>
<li>比如：ReentrantLock 可以允许一个线程多次获得锁，每次 state 值加 1</li>
</ul>
</li>
<li><strong>AQS 实现同步的关键</strong>：它提供了一个基于 FIFO 队列的同步队列，通过将等待线程加入同步队列中，然后在释放同步状态的时候，从同步队列中唤醒等待线程，从而实现了同步机制</li>
<li><strong>AQS有两种实现方式</strong>：**独占式（Exclusive）**和 <strong>共享式（Shared）</strong>
<ul>
<li><strong>独占式</strong>：是指一个线程可以占用同步资源，比如：<code>ReentrantLock</code></li>
<li><strong>共享式</strong>：是指多个线程可以同时占用同步资源，比如：<code>CountDownLatch</code></li>
<li>在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同</li>
</ul>
</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241107170149785.png" alt="AQSAQS" loading="lazy"></p>
<hr>
<h3 id="AQS有哪些核心的方法？"><a class="headerlink" href="#AQS有哪些核心的方法？"></a>AQS有哪些核心的方法？</h3>
<p>答：</p>
<p>一共三类方法：</p>
<ul>
<li>第一类：3个访问和修改同步状态的方法</li>
<li>第二类：5个可重写方法</li>
<li>第三类：9个模板方法</li>
</ul>
<p>三类方法的关系：实现一个同步组件时，使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写5个指定的方法（<strong>第二类</strong>），重写同步器指定的方法时，需要使用同步器提供的3个方法来访问或者修改同步状态（<strong>第一类</strong>）。最后将AQS组合在自定义同步组件的实现中，并调用其9个模板方法（<strong>第三类</strong>）和5个重写过的方法来实现。另外模板方法会调用使用者重写的方法</p>
<hr>
<h2 id="ReentrantLock"><a class="headerlink" href="#ReentrantLock"></a>ReentrantLock</h2>
<h3 id="什么是可重入，什么是可重入锁？"><a class="headerlink" href="#什么是可重入，什么是可重入锁？"></a>什么是可重入，什么是可重入锁？</h3>
<p>答：</p>
<ul>
<li><strong>可重入锁</strong>：自己可以再次获取自己的内部锁，比如：一个线程获取了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的。如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0才能释放锁</li>
</ul>
<hr>
<h3 id="公平锁和非公平锁的区别？"><a class="headerlink" href="#公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h3>
<p>答：</p>
<ul>
<li><strong>公平锁</strong>：锁被释放之后，先申请的线程先得到锁，性能较差一些，因为<strong>公平锁为了保证时间上的绝对顺序</strong>，上下文切换更频繁</li>
<li><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获得锁，<strong>是随机或者按照其他优先级排序的</strong>，性能更好，但可能会导致某些线程永远无法获取到锁</li>
</ul>
<hr>
<h3 id="为什么非公平锁比公平锁性能更好？"><a class="headerlink" href="#为什么非公平锁比公平锁性能更好？"></a>为什么非公平锁比公平锁性能更好？</h3>
<p>答：</p>
<ul>
<li><strong>公平锁的执行流程</strong>：获取锁时，先将线程自己添加到同步队列的队尾并休眠，当某线程用完锁之后，会去唤醒同步队列中队首的线程尝试获取锁，锁的使用顺序就是队列中的先后顺序
<ul>
<li>在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但<strong>线程每次休眠和恢复都需要从用户态切换到内核态，而这个状态的转换比较慢</strong>，所以公平锁的执行速度会比较慢</li>
</ul>
</li>
<li><strong>非公平锁的执行流程</strong>：当线程获取锁时，会先通过CAS尝试获取锁，如果获取成功就直接拥有锁，如果获取失败就会进入同步队列，等待下次尝试获取锁
<ul>
<li>好处：获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率</li>
</ul>
</li>
</ul>
<hr>
<h3 id="ReentrantLock是如何实现公平锁的？非公平锁的？"><a class="headerlink" href="#ReentrantLock是如何实现公平锁的？非公平锁的？"></a>ReentrantLock是如何实现公平锁的？非公平锁的？</h3>
<p>答：</p>
<ul>
<li>ReentrantLock类内部总共存在<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code> 三个类，<code>NonfairSync</code>与<code>FairSync</code>类继承自<code>Sync</code>类，<code>Sync</code>类 继承自 <code>AbstractQueuedSynchronizer</code>抽象类</li>
<li>ReentrantLock的<strong>默认实现是非公平锁</strong>。公平锁对比非公平锁的实现差异<strong>主要体现在tryAcquire方法</strong>（获取锁）
<ul>
<li>非公平锁（<code>NonfairSync</code>）的 <code>tryAcquire</code> 实现直接调用了父类 <code>Sync</code> 中的 <code>nonfairTryAcquire</code></li>
<li>公平锁 <code>tryAcquire</code> 的唯一不同点为判断条件多了 <code>hasQueuedPredecessors()</code> 方法，即：加入了同步队列中当前结点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁</li>
</ul>
</li>
</ul>
<hr>
<h3 id="synchronized-和-ReentrantLock-区别是什么？"><a class="headerlink" href="#synchronized-和-ReentrantLock-区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3>
<p>答：</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中提供的<strong>可重入锁</strong>，二者的主要区别有以下5个：</p>
<ul>
<li><strong>用法不同</strong>：<code>synchronized</code> 可以用来修饰普通方法、静态方法和代码块，而 <code>ReentrantLock</code> 只能用于代码块</li>
<li><strong>获取锁和释放锁的机制不同</strong>：<code>synchronized</code> 是自动加锁和释放锁的，而 <code>ReentrantLock</code> 需要手动加锁和释放锁</li>
<li><strong>锁类型不同</strong>：<code>synchronized</code> 是非公平锁，而 <code>ReentrantLock</code> 默认为非公平锁，也可以手动指定为公平锁</li>
<li><strong>响应中断不同</strong>：<code>ReentrantLock</code> 可以响应中断，解决死锁的问题，而 <code>synchronized</code> 不能响应中断</li>
<li><strong>底层实现不同</strong>：<code>synchronized</code> 是 JVM 层面通过监视器实现的，而 <code>ReentrantLock</code> 是基于 AQS 实现的</li>
</ul>
<hr>
<h2 id="ReentrantReadWriteLock"><a class="headerlink" href="#ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2>
<h3 id="ReentrantReadWriteLock是什么？"><a class="headerlink" href="#ReentrantReadWriteLock是什么？"></a>ReentrantReadWriteLock是什么？</h3>
<p>答：</p>
<ul>
<li><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code>，是一个<strong>可重入的读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全</li>
<li><code>ReentrantReadWriteLock</code> 其实是两把锁，一个是 <code>WriteLock</code>（写锁），一个是 <code>ReadLock</code>（读锁）
<ul>
<li><strong>读锁是共享锁，写锁是独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，写锁最多只能同时被一个线程持有</li>
</ul>
</li>
</ul>
<hr>
<h3 id="共享锁和独占锁有什么区别？"><a class="headerlink" href="#共享锁和独占锁有什么区别？"></a>共享锁和独占锁有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>共享锁</strong>：一把锁可以被多个线程同时获得</li>
<li><strong>独占锁</strong>：一把锁只能被一个线程获得</li>
</ul>
<hr>
<h3 id="线程持有读锁还能获取写锁吗？"><a class="headerlink" href="#线程持有读锁还能获取写锁吗？"></a>线程持有读锁还能获取写锁吗？</h3>
<p>答：</p>
<ul>
<li><strong>在线程持有读锁的情况下：该线程不能取得写锁</strong>
<ul>
<li>因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有</li>
</ul>
</li>
<li><strong>在线程持有写锁的情况下：该线程可以继续获取读锁</strong>
<ul>
<li>因为获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况下才会获取失败</li>
</ul>
</li>
</ul>
<hr>
<h3 id="什么是锁的升降级？ReentrantReadWriteLock为什么不支持锁升级？"><a class="headerlink" href="#什么是锁的升降级？ReentrantReadWriteLock为什么不支持锁升级？"></a>什么是锁的升降级？ReentrantReadWriteLock为什么不支持锁升级？</h3>
<p>答：</p>
<ul>
<li><strong>写锁可以降级为读锁，但是读锁不能升级为写锁</strong>
<ul>
<li>因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于独占锁，影响性能</li>
<li>还可能发生死锁的问题
<ul>
<li>例如：两个线程的读锁都想升级写锁，则需要对方都释放自己的锁，而双方都不释放锁，就会产生死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="ReentrantReadWriteLock底层读写状态如何设计？"><a class="headerlink" href="#ReentrantReadWriteLock底层读写状态如何设计？"></a>ReentrantReadWriteLock底层读写状态如何设计？</h3>
<p>答：高16位为读锁，低16位为写锁</p>
<hr>
<h2 id="ConcurrentHashMap"><a class="headerlink" href="#ConcurrentHashMap"></a>ConcurrentHashMap</h2>
<h3 id="ConcurrentHashMap-JDK1-7实现的原理是什么？"><a class="headerlink" href="#ConcurrentHashMap-JDK1-7实现的原理是什么？"></a>ConcurrentHashMap JDK1.7实现的原理是什么？</h3>
<p>答：</p>
<ul>
<li>首先将数据分成一段一段（Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也可以被其他线程访问</li>
<li>ConcurrentHashMap 是由 <strong>Segment数组结构</strong> 和 <strong>HashEntry数据结构</strong> 组成</li>
<li>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据</li>
<li>一个ConcurrentHashMap包含一个Segment数组，Segment的个数一旦初始化就不能改变。Segment数组的大小默认为16，也就是说默认可以同时支持16个线程并发写</li>
</ul>
<hr>
<h3 id="ConcurrentHashMap-JDK1-8实现的原理是什么？"><a class="headerlink" href="#ConcurrentHashMap-JDK1-8实现的原理是什么？"></a>ConcurrentHashMap JDK1.8实现的原理是什么？</h3>
<p>答：</p>
<ul>
<li>在 JDK1.8 取消了 Segment 分段锁，采用 Node+CAS+synchronized 来保证并发安全。数据结构跟HashMap1.8 的结构相似，数组+链表/红黑树。Java8 在链表长度超过一定阈值（8）时将链表（<code>O(N)</code>）转换为红黑树（<code>O(logN)</code>）</li>
<li>Java8中，锁粒度更细，sychronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，也不会影响其他 Node 的读写，效率大幅度提升</li>
</ul>
<hr>
<h3 id="ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别？"><a class="headerlink" href="#ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别？"></a>ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别？</h3>
<p>答：</p>
<ul>
<li>线程安全的实现方式</li>
<li>Hash碰撞解决办法</li>
<li>并发度：JDK1.7最大并发度是segment的个数，默认是16；JDK1.8最大并发度是Node数组的大小，并发度更大</li>
</ul>
<hr>
<h3 id="JDK1-8中，ConcurrentHashMap什么情况下链表才会转换成红黑树进行存储？"><a class="headerlink" href="#JDK1-8中，ConcurrentHashMap什么情况下链表才会转换成红黑树进行存储？"></a>JDK1.8中，ConcurrentHashMap什么情况下链表才会转换成红黑树进行存储？</h3>
<p>答：<strong>链表长度大于等于8，且数组长度大于等于64</strong>。并非一开始就创建红黑树结构，如果当前Node数组长度小于 <code>MIN_TREEIFY_CAPACITY</code>，默认为 64，先通过扩容数组容量为原来的两倍以缓解单个链表元素过大的性能问题</p>
<hr>
<h3 id="ConcurrentHashMap的get方法是否需要加锁，为什么？"><a class="headerlink" href="#ConcurrentHashMap的get方法是否需要加锁，为什么？"></a>ConcurrentHashMap的get方法是否需要加锁，为什么？</h3>
<p>答：</p>
<ul>
<li><strong>不需要</strong></li>
<li>因为get方法不涉及对变量的修改，所以会导致并发下可能处理问题的原因就是读共享变量的可见性问题。而ConcurrentHashMap中，对get方法中用到的共享变量都使用 <code>volatile</code> 关键字修饰，所以整个get方法不加锁也不会有问题</li>
</ul>
<hr>
<h3 id="ConcurrentHashMap的key、value是否可以为null？"><a class="headerlink" href="#ConcurrentHashMap的key、value是否可以为null？"></a>ConcurrentHashMap的key、value是否可以为null？</h3>
<p>答：</p>
<ul>
<li><strong>不行</strong></li>
<li>如果 key 或者 value 为 null 会抛出空指针异常。原因是：<strong>没有办法解决 get 的返回值为 NULL 时的二义性问题</strong>，即：因为 value 在 get 操作下返回的 NULL 没办法确定<strong>是因为key不存在所以返回NULL，还是key存在value为NULL这个问题</strong></li>
<li>但是 HashMap 不存在二义性问题，因为 NULL 作为key put进去，hashcode 为 0 在 HashMap 中可以正确定位和存储的，通过 containsKey 也可以正常判断</li>
</ul>
<hr>
<h3 id="存储在ConcurrentHashMap中的每个节点是什么样子的，有哪些变量？"><a class="headerlink" href="#存储在ConcurrentHashMap中的每个节点是什么样子的，有哪些变量？"></a>存储在ConcurrentHashMap中的每个节点是什么样子的，有哪些变量？</h3>
<p>答：它是实现 <code>Map.Entry&lt;K, V&gt;</code>接口，里面存放了 hash、key、value 以及 next 节点，它的 value 和 next 节点是用 <code>volatile</code> 进行修饰，可以保证多线程之间的可见性</p>
<hr>
<h2 id="BlockingQueue阻塞队列"><a class="headerlink" href="#BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h2>
<h3 id="什么是BlockingQueue？"><a class="headerlink" href="#什么是BlockingQueue？"></a>什么是BlockingQueue？</h3>
<p>答：</p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列，这两个附加操作支持阻塞的插入和移除的方法</p>
<ol>
<li><strong>支持阻塞的插入方法</strong>：指当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li><strong>支持阻塞的移除方法</strong>：指当队列为空时，获取元素的线程会等待队列变为非空</li>
</ol>
<hr>
<h3 id="你了解的阻塞队列有哪些？"><a class="headerlink" href="#你了解的阻塞队列有哪些？"></a>你了解的阻塞队列有哪些？</h3>
<p>答：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：一个由<strong>数组</strong>结构组成的<strong>有界阻塞队列</strong></li>
<li><code>LinkedBlockingQueue</code>：一个由<strong>链表</strong>结构组成的<strong>阻塞队列</strong>，可以有界也可以无界</li>
<li><code>PriorityBlockingQueue</code>：一个<strong>支持优先级排序</strong>的<strong>无界阻塞队列</strong>。默认采取自然排序升序排列</li>
<li><code>DelayQueue</code>：一个<strong>使用优先级队列</strong>实现的<strong>无界阻塞队列</strong>。队列使用<code>PriorityQueue</code>来实现，但是队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能够从队列中提取元素
<ul>
<li>应用：缓存有效期、定时任务调度等场景</li>
</ul>
</li>
<li><code>SynchronousQueue</code>：一个<strong>不存储元素</strong>的<strong>阻塞队列</strong>。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身不存储任何元素，非常适合传递性场景</li>
<li><code>LinkedTransferQueue</code>：一个由<strong>链表</strong>结构组成的<strong>单向无界阻塞队列</strong>。它设计了一种直接在生产者和消费者之间传输元素的机制，称为“transfer”。当生产者调用<code>transfer(e)</code>方法时，它会阻塞直到有一个消费者接收该元素
<ul>
<li>应用：适用于需要高效地在生产者和消费者之间直接传输数据的场景，尤其是当生产者和消费者之间的速度大致匹配时</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code>：一个由<strong>链表</strong>结构组成的<strong>双向阻塞队列</strong>。所谓双向队列指的是可以从队列的两端插入和移出元素。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst</code>、<code>addLast</code>、<code>offer-First</code>、<code>offerLast</code>、<code>peekFirst</code>和<code>peekLast</code>等方法
<ul>
<li>应用：双向阻塞队列可以运用在“工作窃取”模式中</li>
</ul>
</li>
</ul>
<hr>
<h3 id="ArrayBlockingQueue和LinkedBlockingQueue有什么区别？"><a class="headerlink" href="#ArrayBlockingQueue和LinkedBlockingQueue有什么区别？"></a>ArrayBlockingQueue和LinkedBlockingQueue有什么区别？</h3>
<p>答：</p>
<p><strong>相同点</strong>：都是Java并发包中常用的两种阻塞队列实现，它们都是线程安全的</p>
<p><strong>不同点</strong>：</p>
<ul>
<li><strong>底层实现</strong>：<code>ArrayBlockingQueue</code> 基于<strong>数组</strong>实现，而 <code>LinkedBlockingQueue</code> 基于<strong>链表</strong>实现</li>
<li><strong>是否有界</strong>：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的</li>
<li><strong>锁是否分离</strong>：<code>ArrayBlockingQueue</code> 中的锁是没有分离的，即：生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code> 中的锁是分离的，即：生产用的是 <code>putLock</code>，消费是 <code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺</li>
<li><strong>内存占用</strong>：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而 <code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间</li>
</ul>
<hr>
<h3 id="如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列存在元素的呢？"><a class="headerlink" href="#如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列存在元素的呢？"></a>如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列存在元素的呢？</h3>
<p>答：</p>
<ul>
<li>使用<strong>通知模式</strong>实现
<ul>
<li>所谓通知模式，当消费者从空的队列获取元素时会阻塞住消费者，此时如果生产者放了一个元素进入队列，则需要通知阻塞住消费者当前有元素可取。同理当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。<strong>通过查看JDK源码发现部分阻塞队列使用了Condition来实现</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="CAS"><a class="headerlink" href="#CAS"></a>CAS</h2>
<h3 id="你自己怎样理解CAS机制的？"><a class="headerlink" href="#你自己怎样理解CAS机制的？"></a>你自己怎样理解CAS机制的？</h3>
<p>答：</p>
<ul>
<li>全称 <code>Compare and swap</code>，即：“比较并交换”。相当于通过一个原子的操作，同时完成“<strong>读取内</strong><br>
<strong>存、比较是否相等、修改内存</strong>”这三个步骤</li>
<li>Java 中可以<strong>通过 CAS 操作来保证原子性</strong>，原子性就是不可被中断的一些列操作或者一个操作，简单来说就是一系列操作，要么全部完成，要么失败，不能被中断</li>
<li>本质上需要 CPU 指令的支撑</li>
<li>CAS主要包含三个参数**（V，expect，update）**，V表示要更新的变量（内存值）、expect 表示预期值（旧值）、 update 表示新值。算法流程是：首先比较 V 和 expect 的值，如果相等，将 update 值赋值给V，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用 <code>(V，A，B)</code> 表示，其中：A表示预期值，B表示新值</li>
<li>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是：<strong>自旋</strong>。<strong>Java 中的自旋锁就是利用 CAS 来实现的</strong></li>
</ul>
<hr>
<h3 id="你知道JDK中哪些地方用到了CAS吗？例举几个"><a class="headerlink" href="#你知道JDK中哪些地方用到了CAS吗？例举几个"></a>你知道JDK中哪些地方用到了CAS吗？例举几个</h3>
<p>答：</p>
<ol>
<li><strong>自旋锁的实现</strong>
<ul>
<li>就是一个循环里面不停CAS操作，直到成功或者超时，一般会设置一个自旋超时时间</li>
</ul>
</li>
<li><strong>Java原子类</strong></li>
<li><strong>并发容器</strong>
<ul>
<li>例如：<code>ConcurrentHashMap</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="CAS有什么问题和缺陷？"><a class="headerlink" href="#CAS有什么问题和缺陷？"></a>CAS有什么问题和缺陷？</h3>
<p>答：</p>
<ol>
<li>ABA问题</li>
<li>只能保证单个变量的原子性，不能保证代码块的原子性。要保证多个变量共同进行原子性操作，那只能借助别的方式，例如：<code>synchronized</code></li>
<li>CAS会造成CPU利用率增加，因为CAS是不阻塞线程的，通常的用法是把CAS放到循环中，所以如果竞争比较激烈的话，CPU消耗会显著增加</li>
</ol>
<hr>
<h3 id="什么是ABA问题？"><a class="headerlink" href="#什么是ABA问题？"></a>什么是ABA问题？</h3>
<p>答：因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是<strong>如果一个值原来是A，变成了B，又变成了A</strong>，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA很多业务场景是可以容忍的，但是有些业务场景就会带来问题</p>
<hr>
<h3 id="ABA问题怎么解决？"><a class="headerlink" href="#ABA问题怎么解决？"></a>ABA问题怎么解决？</h3>
<p>答：</p>
<ol>
<li><strong>给要修改的数据引入版本号</strong>
<ul>
<li>在 CAS 比较数据当前值和旧值的同时，也要比较版本号是否符合预期。如果发现当前版本号和之前读到的版本号一致，就真正执行修改操作，并让版本号自增；如果发现当前版本号比之前读到的版本号大，就认为操作失败</li>
</ul>
</li>
<li><strong>JDK的Atomic包里提供了一个类 AtomicStampedReference 来解决ABA问题</strong>
<ul>
<li>这个类的 <code>compareAndSet</code> 方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</li>
</ul>
</li>
</ol>
<hr>
<h3 id="synchronized、volatile、CAS-之间的比较？"><a class="headerlink" href="#synchronized、volatile、CAS-之间的比较？"></a>synchronized、volatile、CAS 之间的比较？</h3>
<p>答：</p>
<ol>
<li>synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞</li>
<li>volatile 提供多线程共享变量可见性和禁止指令重排序优化</li>
<li>CAS 是基于冲突检测的乐观锁（非阻塞）</li>
</ol>
<hr>
<h2 id="原子类"><a class="headerlink" href="#原子类"></a>原子类</h2>
<h3 id="什么是原子类？"><a class="headerlink" href="#什么是原子类？"></a>什么是原子类？</h3>
<p>答：</p>
<ul>
<li>
<p><code>java.util.concurrent.atomic</code>包：是原子类的小工具包，支持在单个变量上解除锁的线程安全编程原子变量类<strong>相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-改-写操作</strong></p>
<ul>
<li>比如：AtomicInteger 表示一个 int 类型的值，并提供了 get 和 set 方法，这些 volatile 类型的 int 变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndset 方法（如果该方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、递增和递减等方法</li>
</ul>
</li>
<li>
<p>AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持</p>
</li>
<li>
<p>简单来说：<strong>就是原子类来实现CAS无锁模式的算法</strong></p>
</li>
</ul>
<hr>
<h3 id="原子类的常用类有哪些？"><a class="headerlink" href="#原子类的常用类有哪些？"></a>原子类的常用类有哪些？</h3>
<p>答：</p>
<ul>
<li><code>AtomicBoolean</code></li>
<li><code>AtomicInteger</code></li>
<li><code>AtomicLong</code></li>
<li><code>AtomicReference</code></li>
</ul>
<hr>
<h3 id="说一下-Atomic-的原理？"><a class="headerlink" href="#说一下-Atomic-的原理？"></a>说一下 Atomic 的原理？</h3>
<p>答：</p>
<p>Atomic 包中的类基本的特性就是：在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即：<strong>当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行成功</strong></p>
<hr>
<h2 id="并发工具类（了解）"><a class="headerlink" href="#并发工具类（了解）"></a>并发工具类（了解）</h2>
<h3 id="CountDownLatch、CyclicBarrier、Semaphore、Exchanger了解吗？"><a class="headerlink" href="#CountDownLatch、CyclicBarrier、Semaphore、Exchanger了解吗？"></a>CountDownLatch、CyclicBarrier、Semaphore、Exchanger了解吗？</h3>
<p>答：</p>
<ul>
<li><code>CountDownLatch</code>：倒计数器
<ul>
<li>允许一个或多个线程等待其他线程完成操作</li>
</ul>
</li>
<li><code>CyclicBarrier</code>：意思是可循环使用（Cyclic）的屏障（Barrier）
<ul>
<li>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</li>
</ul>
</li>
<li><code>Semaphore</code>（信号量）：是用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源</li>
<li><code>Exchanger</code>（交换者）：是一个用于线程间协作的工具类，Exchanger 用于进行线程间的数据交换
<ul>
<li>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CyclicBarrier和CountDownLatch有什么区别？"><a class="headerlink" href="#CyclicBarrier和CountDownLatch有什么区别？"></a>CyclicBarrier和CountDownLatch有什么区别？</h3>
<p>答：</p>
<ol>
<li>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0</li>
<li>CyclicBarrier面向的是线程数；CountDownLatch面向的是任务数</li>
<li>在使用CyclicBarrier时，必须在构造中指定参与协作的线程数，这些线程必须调用await()方法；使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</li>
<li>CyclicBarrier可以在所有的线程释放后重新使用；CountDownLatch在计数器为0时不能再使<br>
用</li>
</ol>
<hr>
<h2 id="线程池"><a class="headerlink" href="#线程池"></a>线程池</h2>
<h3 id="什么是线程池？为什么要用线程池？"><a class="headerlink" href="#什么是线程池？为什么要用线程池？"></a>什么是线程池？为什么要用线程池？</h3>
<p>答：</p>
<ul>
<li>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处：
<ol>
<li><strong>降低资源消耗</strong>
<ul>
<li>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
</ul>
</li>
<li><strong>提高响应速度</strong>
<ul>
<li>当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
</ul>
</li>
<li><strong>提高线程的可管理性</strong>
<ul>
<li>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="线程池的核心参数都哪些？"><a class="headerlink" href="#线程池的核心参数都哪些？"></a>线程池的核心参数都哪些？</h3>
<p>答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<p>线程池的构造函数有7个参数：</p>
<ul>
<li><code>corePoolSize</code>：<strong>核心线程数</strong></li>
<li><code>maximumPoolSize</code>：<strong>线程池能创建线程的最大个数</strong></li>
<li><code>keepAliveTime</code>：<strong>空闲线程存活时间</strong></li>
<li><code>unit</code>：<strong>时间单位</strong>，为 keepAliveTime 指定时间单位</li>
<li><code>workQueue</code>：<strong>阻塞队列</strong>，<strong>用于保存任务的阻塞队列</strong></li>
<li><code>threadFactory</code>：<strong>创建线程的工程类</strong></li>
<li><code>handler</code>：<strong>饱和策略（拒绝策略）</strong></li>
</ul>
<hr>
<h3 id="常用线程池的区别及特点？"><a class="headerlink" href="#常用线程池的区别及特点？"></a>常用线程池的区别及特点？</h3>
<p>答：</p>
<ol>
<li><code>newCachedThreadPool</code>
<ul>
<li>特点：<code>newCachedThreadPool</code> 创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时， 它可以灵活的添加新的线程，而<strong>不会对池的长度作任何限制</strong></li>
<li>缺点：他虽然可以无限的新建线程，但是容易造成堆内存溢出，因为它的最大值是在初始化的时候设置为 <code>Integer.MAX_VALUE</code>，一般来说机器都没那么大内存给它不断使用。当然知道可能出问题的点，就可以去重写一个方法限制一下这个最大值</li>
<li>使用场景：执行很多短期异步的小程序</li>
</ul>
</li>
<li><code>newFixedThreadPool</code>
<ul>
<li>特点：创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置</li>
<li>缺点：线程数量是固定的，但是阻塞队列是无界队列。如果有很多请求积压，阻塞队列越来越长，容易导致OOM（超出内存空间）</li>
<li>使用场景：执行长期的任务，性能好很多</li>
</ul>
</li>
<li><code>newScheduledThreadPool</code>
<ul>
<li>特点：<strong>创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行</strong>，类似于Timer（Timer是Java的一个定时器类）</li>
<li>缺点：同样使用无界队列。如果有很多请求积压，阻塞队列越来越长，容易导致OOM（超出内存空间）</li>
<li>使用场景：周期性执行任务的场景</li>
</ul>
</li>
<li><code>newSingleThreadExecutor</code>
<ul>
<li>特点：<strong>创建一个单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它必须保证前一项任务执行完毕才能执行后一项。保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li>
<li>缺点：缺点的话，很明显，它是单线程的，高并发业务下有点无力</li>
<li>使用场景：适合多个任务顺序执行的场景，不需要考虑并发问题</li>
</ul>
</li>
</ol>
<hr>
<h3 id="线程池的拒绝策略都有哪些？"><a class="headerlink" href="#线程池的拒绝策略都有哪些？"></a>线程池的拒绝策略都有哪些？</h3>
<p>答：</p>
<ul>
<li><code>AbortPolicy</code>，<strong>默认</strong>
<ul>
<li>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了<strong>丢掉这个任务并且抛出<code>RejectedExecutionException</code> 异常</strong></li>
</ul>
</li>
<li><code>DiscardPolicy</code>
<ul>
<li>这个策略和 <code>AbortPolicy</code> 的 slient 版本，如果线程池队列满了**，会直接丢掉这个任务并且不会有任何异常**</li>
</ul>
</li>
<li><code>DiscardOldestPolicy</code>
<ul>
<li>这个策略从字面上也很好理解，<strong>丢弃最老的</strong>。也就是说如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列。因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除对头元素后再尝试入队</li>
</ul>
</li>
<li><code>CallerRunsPolicy</code>
<ul>
<li>使用此策略，<strong>如果添加到线程池失败，那么主线程会自己去执行该任务</strong>，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干</li>
</ul>
</li>
</ul>
<hr>
<h3 id="在Java中，Executor和Executors的区别？"><a class="headerlink" href="#在Java中，Executor和Executors的区别？"></a>在Java中，Executor和Executors的区别？</h3>
<p>答：</p>
<ul>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求</li>
<li>Executor 接口对象能执行我们的线程任务</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值</li>
</ul>
<hr>
<h3 id="线程池都有哪些状态？"><a class="headerlink" href="#线程池都有哪些状态？"></a>线程池都有哪些状态？</h3>
<p>答：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241106134959710.png" alt="线程池的状态" loading="lazy"></p>
<ul>
<li><code>RUNNING</code>：这是最正常的状态，接受新的任务，处理等待队列中的任务</li>
<li><code>SHUTDOWN</code>：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li><code>STOP</code>：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li><code>TIDYING</code>：所有的任务都销毁了，workerCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 <code>terminated()</code></li>
<li><code>TERMINATED</code>：<code>terminated()</code> 方法结束后，线程池的状态就会变成这个</li>
</ul>
<hr>
<h3 id="线程池中submit-和execute-方法有什么区别？"><a class="headerlink" href="#线程池中submit-和execute-方法有什么区别？"></a>线程池中submit()和execute()方法有什么区别？</h3>
<p>答：</p>
<ul>
<li><strong>相同点</strong>：
<ul>
<li>相同点就是都可以开启线程执行池中的任务</li>
</ul>
</li>
<li><strong>不同点</strong>：
<ul>
<li><strong>接收参数</strong>：<code>execute()</code> 只能执行 Runnable 类型的任务，<code>submit()</code> 可以执行 Runnable 和 Callable 类型的任务</li>
<li><strong>返回值</strong>：<code>submit()</code> 方法可以返回持有计算结果的 Future 对象，而 <code>execute()</code> 没有</li>
<li><strong>异常处理</strong>：<code>submit()</code> 方便 Exception 处理</li>
</ul>
</li>
</ul>
<hr>
<h3 id="分析线程池的实现原理和线程池的调度过程？"><a class="headerlink" href="#分析线程池的实现原理和线程池的调度过程？"></a>分析线程池的实现原理和线程池的调度过程？</h3>
<p>答：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20241106135926523.png" alt="线程池的执行流程" loading="lazy"></p>
<p>提交一个任务到线程池中，线程池的处理流程如下:</p>
<ol>
<li><strong>判断线程池里的 核心线程数 是否已满</strong>，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建-1个新的工作线程来执行任务。如果核心线程数已满，则进入下个流程</li>
<li><strong>线程池判断 工作队列 是否已满</strong>，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程</li>
<li><strong>判断线程池里的线程是否都处于工作状态</strong>，如果没有，则创建一个新的工作线程来执行任务。如果已经满<br>
了，则交给饱和策略（拒绝策略）来处理这个任务</li>
</ol>
<hr>
<h3 id="如何合理分配线程池大小？"><a class="headerlink" href="#如何合理分配线程池大小？"></a>如何合理分配线程池大小？</h3>
<p>答：</p>
<p>要合理的分配线程池的大小要根据实际情况来定，简单的来说的话就是根据 <strong>CPU密集</strong> 和 <strong>IO密集</strong> 来分配：</p>
<ol>
<li>CPU密集型时，<strong>设置线程数为cpu核心数+1</strong>，这样可以使得每个线程都在执行任务</li>
<li>IO密集型时，大部分线程都阻塞故需要多配置线程数，<strong>2*cpu核数</strong></li>
</ol>
<p>总结:</p>
<ul>
<li>线程等待时间比CPU执行时间比例越高，需要越多线程</li>
<li>线程CPU执行时间比等待时间比例越高，需要越少线程</li>
<li>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整</li>
</ul>
<hr>
<h3 id="线程池如何调优？"><a class="headerlink" href="#线程池如何调优？"></a>线程池如何调优？</h3>
<p>答：</p>
<ol>
<li>CPU 密集型任务配置尽可能小的线程，cpu核数+1</li>
<li>IO 密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如：2*cpu核数</li>
<li>混合型任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后并发执行的吞吐率要高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解</li>
<li>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理，它可以让优先级高的任务先得到执行</li>
<li>执行时间不同的任务可以交给不同线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行</li>
<li>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用 CPU</li>
<li>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用</li>
</ol>
<hr>
<h3 id="线程池如何实现动态修改？"><a class="headerlink" href="#线程池如何实现动态修改？"></a>线程池如何实现动态修改？</h3>
<p>答：</p>
<ol>
<li>首先线程池提供了部分 setter 方法可以设置线程池的参数
<ul>
<li>修改核心线程数、最大线程数、空闲线程停留时间、拒绝策略等</li>
<li>可以将线程池的配置参数放入配置中心，当需要调整的时候，去<strong>配置中心</strong>修改就行</li>
</ul>
</li>
<li>什么时候修改呢？
<ul>
<li>这里需要监控报警策略，获取线程池状态指标，当指标判定为异常之后进行报警</li>
<li>分析指标异常原因，评估处理策略，最后通过上述线程池提供的接口进行动态修改（可以将动态配置）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用无界队列的线程池会导致什么问题？"><a class="headerlink" href="#使用无界队列的线程池会导致什么问题？"></a>使用无界队列的线程池会导致什么问题？</h3>
<p>答：例如：<code>newFixedThreadPool</code>使用了无界的阻塞队列<code>LinkedBlockingQueue</code>，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停升，最终导致OOM</p>
<hr>
<h3 id="线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态？"><a class="headerlink" href="#线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态？"></a>线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态？</h3>
<p>答：首先线程本身创建和销毁都是成本比较高的，那就排除 <code>new</code> 和 <code>terminated</code> 状态，没有任务运行排除 <code>runnable</code> 状态，剩下阻塞和等待，因为线程不会销毁需要一直等待执行任务，超时等待也不太可能，最后同步锁才会进入阻塞状态，所以我猜是<strong>一直等待</strong></p>
<hr>
<h2 id="线程池代码题"><a class="headerlink" href="#线程池代码题"></a>线程池代码题</h2>
<hr>
<h3 id="写一个双线程轮流打印1-100，同题目：“2个线程，交替打印100的奇偶数”"><a class="headerlink" href="#写一个双线程轮流打印1-100，同题目：“2个线程，交替打印100的奇偶数”"></a>写一个双线程轮流打印1-100，同题目：“2个线程，交替打印100的奇偶数”</h3>
<p>以下是一个简单的Java双线程程序，其中一个线程打印奇数，另一个线程打印偶数。线程之间通过 <code>wait()</code> 和 <code>notifyAll()</code> 方法进行协调，以确保它们轮流打印数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrinting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前要打印的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 用于同步的锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AlternatePrinting</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlternatePrinting</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动打印奇数线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; ap.printNumbers(<span class="literal">true</span>));</span><br><span class="line">        oddPrinter.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动打印偶数线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; ap.printNumbers(<span class="literal">false</span>));</span><br><span class="line">        evenPrinter.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据isOdd判断打印的是奇数还是偶数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isOdd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(<span class="type">boolean</span> isOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentNumber &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((isOdd &amp;&amp; currentNumber % <span class="number">2</span> == <span class="number">0</span>) || (!isOdd &amp;&amp; currentNumber % <span class="number">2</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentNumber &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread&quot;</span> + (isOdd ? <span class="string">&quot; Odd&quot;</span> : <span class="string">&quot; Even&quot;</span>) + <span class="string">&quot; print &quot;</span> + currentNumber);</span><br><span class="line">                    currentNumber++; <span class="comment">// 打印完一个数字后，将当前数字加1</span></span><br><span class="line">                    lock.notifyAll(); <span class="comment">// 唤醒等待中的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="三个线程顺序打出1-100"><a class="headerlink" href="#三个线程顺序打出1-100"></a>三个线程顺序打出1-100</h3>
<p>为了改为 3 个线程交替打印 1-100，我们需要对每个线程分配一个打印范围，例如：第一个线程打印 3 的倍数，第二个线程打印 3n+1 的数，第三个线程打印 3n+2 的数（其中n为非负整数）。同时，我们需要一种机制来确保三个线程能够交替执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrintingThreeThreads</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前要打印的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于同步的锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制应该打印哪个线程的标志位。0代表打印3n，1代表打印3n+1，2代表打印3n+2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AlternatePrintingThreeThreads</span> <span class="variable">apt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlternatePrintingThreeThreads</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动3个打印线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">print1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; apt.printNumbers(<span class="number">0</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">print2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; apt.printNumbers(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">print3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; apt.printNumbers(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        print1.start();</span><br><span class="line">        print2.start();</span><br><span class="line">        print3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据flag的值打印对应范围内的数字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 0代表打印3n，1代表打印3n+1，2代表打印3n+2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentNumber &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((flag % <span class="number">3</span>) != offset) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果当前的进程不可打印则等待</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentNumber &lt;= <span class="number">100</span> &amp;&amp; (currentNumber - <span class="number">1</span>) % <span class="number">3</span> == offset) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + offset + <span class="string">&quot; print &quot;</span> + currentNumber);</span><br><span class="line">                    currentNumber++; <span class="comment">// 打印完一个数字在原来数字的基础上加1</span></span><br><span class="line">                    flag = (flag + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 更新打印标志位</span></span><br><span class="line">                    lock.notifyAll(); <span class="comment">// 唤醒等待中的进程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在这个程序中，我们使用了 <code>turn</code> 变量来控制哪个线程应该打印。每个线程在打印前都会检查 <code>turn</code> 的值，如果不是自己的轮次，就会调用 <code>wait()</code> 方法进入等待状态。当一个线程打印完毕后，它会更新 <code>turn</code> 的值，并通过 <code>notifyAll()</code> 方法唤醒其他可能在等待的线程</p>
<hr>
<h3 id="多线程问题：线程A，B、C，分别打印1、2、3，顺序执行10次"><a class="headerlink" href="#多线程问题：线程A，B、C，分别打印1、2、3，顺序执行10次"></a>多线程问题：线程A，B、C，分别打印1、2、3，顺序执行10次</h3>
<p>为了顺序执行10次打印任务，其中线程A打印1、线程B打印2、线程C打印3，我们可以使用一个共享的计数器来跟踪当前的打印轮次，并确保每个线程在正确的轮次中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialPrinting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来跟踪当前的打印轮次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于同步的锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SequentialPrinting</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinting</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动3个打印线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; sp.printNumbers(<span class="number">1</span>), <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; sp.printNumbers(<span class="number">2</span>), <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; sp.printNumbers(<span class="number">3</span>), <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span> numberToPrint)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">3</span> != numberToPrint - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 如果不是该线程打印，则等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">30</span>) &#123; <span class="comment">// 确保只打印10轮</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; print &quot;</span> + numberToPrint);</span><br><span class="line">                    count++; <span class="comment">// 增加计数器，进入下一轮统计</span></span><br><span class="line">                    lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ol>
<li>在这个程序中， count 变量用来跟踪当前的打印轮次，并且确保每个线程在正确的轮次执行。每个线程都会检查 count 的值，如果当前轮次不是自己的，就会调用 wait() 方法进入等待状态。当一个线程打印完毕后，它会增加 count 的值，并通过 notifyAll() 方法唤醒其他可能在等待的线程</li>
<li>注意， count 变量的上限设置为30（10轮，每轮3个数字），以确保程序只执行10轮打印。每个线程都会检查这个条件，以避免超出所需的打印轮次</li>
<li>此程序会按顺序（线程A、线程B、线程C）执行打印任务，每个线程打印自己的数字，总共进行10轮</li>
</ol>
<hr>
<h3 id="计数累加怎么线程安全，可以怎么实现，100个线程，每个线程累加100次"><a class="headerlink" href="#计数累加怎么线程安全，可以怎么实现，100个线程，每个线程累加100次"></a>计数累加怎么线程安全，可以怎么实现，100个线程，每个线程累加100次</h3>
<p>以下是一个简单的 Java 示例，演示了如何使用 AtomicInteger 来实现线程安全的计数累加。在这个示例中，我们将创建 100 个线程，并且每个线程将对计数器执行 100 次累加操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCountDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个固定大小为100的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 100 个线程，并且每个线程将对计数器执行 100 次累加操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        count.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        pool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终的结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;final number：&quot;</span> + count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，定义了一个 <code>AtomicInteger</code> 类型的静态变量 <code>counter</code> 作为我们的计数器<code>incrementCounterHundredTimes</code> 方法包含了一个循环，它会使计数器递增100次。由于 <code>AtomicInteger</code> 的<code>incrementAndGet</code> 方法是线程安全的，所以不需要额外的同步措施</li>
<li>在main方法中，创建了一个拥有100个线程的线程池，并提交了100个任务，每个任务都会执行<code>incrementCounterHundredTimes</code> 方法。在所有任务完成后，输出最终的计数值。由于每个线程都会将计数器增加100，所以最终的计数值应该是100*100=10000</li>
</ul>
<hr>
<h3 id="线程交叉打印12A34B56C，多种实现方式（一个打印数字，一个打印字母）"><a class="headerlink" href="#线程交叉打印12A34B56C，多种实现方式（一个打印数字，一个打印字母）"></a>线程交叉打印12A34B56C，多种实现方式（一个打印数字，一个打印字母）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrintingDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制打印数字还是字母的标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">52</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    System.out.println(i + <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;  <span class="comment">// 切换打印标志</span></span><br><span class="line">                    lock.notifyAll();  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printLetters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;  <span class="comment">// 切换打印的标志</span></span><br><span class="line">                    lock.notifyAll();  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printNumber.start();</span><br><span class="line">        printLetters.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="两个线程交替打印ABCD…Z字母，一个大写一个小写"><a class="headerlink" href="#两个线程交替打印ABCD…Z字母，一个大写一个小写"></a>两个线程交替打印ABCD…Z字母，一个大写一个小写</h3>
<p>目标输出：<code>AbCdEfGhIjKlMnOpQrStUvWxYz</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintLettersDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">currentLetter</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小写标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">printUpperCase</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">upperCasePrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printLetters(<span class="literal">true</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">lowerCasePrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printLetters(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        upperCasePrinter.start();</span><br><span class="line">        lowerCasePrinter.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLetters</span><span class="params">(<span class="type">boolean</span> isUpperCaseThread)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentLetter &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (printUpperCase != isUpperCaseThread) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentLetter &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isUpperCaseThread) &#123;</span><br><span class="line">                    System.out.print((<span class="type">char</span>) currentLetter);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(Character.toLowerCase((<span class="type">char</span>) currentLetter));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改大小写标志</span></span><br><span class="line">                printUpperCase = !printUpperCase;</span><br><span class="line">                currentLetter++;</span><br><span class="line"></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="两个线程交替打印出a1b2c3…z26"><a class="headerlink" href="#两个线程交替打印出a1b2c3…z26"></a>两个线程交替打印出a1b2c3…z26</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个线程交替打印出a1b2c3....z26</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberAndLetterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于计数，确定打印的字母和数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制标志，true表示当前应该打印数字，false表示当前应该打印字母</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait(); <span class="comment">// 等待直到轮到打印数字</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                        System.out.print(count);</span><br><span class="line">                        count++;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printLetter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (count &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                   <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           lock.wait(); <span class="comment">// 等待直到轮到打印字母</span></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (count &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                       System.out.print((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + count - <span class="number">1</span>));</span><br><span class="line">                       flag = <span class="literal">true</span>;</span><br><span class="line">                       lock.notifyAll();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printLetter.start();</span><br><span class="line">        printNumber.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="两个线程，一个打印abcd，一个打印1234，需求交替打印出a1b2c3d4a1b2c3d4；打印10轮"><a class="headerlink" href="#两个线程，一个打印abcd，一个打印1234，需求交替打印出a1b2c3d4a1b2c3d4；打印10轮"></a>两个线程，一个打印abcd，一个打印1234，需求交替打印出a1b2c3d4a1b2c3d4；打印10轮</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个线程，一个打印abcd，一个打印1234，需求交替打印出a1b2c3d4a1b2c3d4；打印10轮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberLetterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0代表打印字母，1代表打印数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  记录当前打印的轮数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printLetter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123; <span class="comment">// 总共需要打印40个字符（每个线程各20个）</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (state != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (round &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                        System.out.print((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + (i % <span class="number">4</span>)));</span><br><span class="line">                        state = <span class="number">1</span>; <span class="comment">// 切换到打印数字的状态</span></span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (round &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> (i % <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">                        System.out.print(number);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 完成一轮打印轮数增加</span></span><br><span class="line">                        <span class="keyword">if</span> ((i % <span class="number">4</span>) + <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            round++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        state = <span class="number">0</span>; <span class="comment">// 切换到打印字母的状态</span></span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printLetter.start();</span><br><span class="line">        printNumber.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"></a><div class="post-copyright__author_name">coo1heisenberg's Blog</div><div class="post-copyright__author_desc">Diligence can make up for clumsiness!</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">coo1heisenberg's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tags-punctuation"></span>Java并发编程<span class="tagsPageCount">1</span></a></div></div><div class="social-share"></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">02 JVM 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">00 Java集合框架 笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">菜鸡的自我救赎...</div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Coo1heisenberg’s BLOG</div><div class="author-info__desc">Diligence can make up for clumsiness!</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/coo1heisenbergProject" title="Github"><i class="solitude  st-github-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Java并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-text">为什么要使用并发编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">并发编程有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E5%9B%A0%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">并发编程三个必要因素是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">并发出问题的根源是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">并行和并发的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">Java怎么进行并发控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">死锁与活锁的区别，死锁与饥饿的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%EF%BC%9F"><span class="toc-text">什么是Java内存模型（JMM）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Happens-Before-%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">什么是 Happens-Before 原则？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">说说自己是怎么使用synchronized关键字，synchronized关键字最主要的三个使用方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bsynchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下synchronized底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">synchronized可重入的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsynchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">多线程中synchronized锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-synchronized-%E6%96%B9%E6%B3%95-A-%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84-synchronized-%E6%96%B9%E6%B3%95-B"><span class="toc-text">当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">volatile关键字的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%8F%98%E9%87%8F%E5%92%8Catomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">volatile变量和atomic原子类变量有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E8%83%BD%E4%BD%BF%E5%BE%97%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%98%E6%88%90%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F"><span class="toc-text">volatile 能使得一个非原子操作变成原子操作吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">synchronized 和 volatile 的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">final关键字有哪些用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%9A%84final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%B8%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-text">所有的final修饰的字段都是编译器常量吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">什么是上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">守护线程和用户线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">什么是死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">形成死锁的四个必要条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">如何避免线程死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">Java线程有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">创建线程的几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BRunnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">说一下Runnable和Callable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCallable%E5%92%8CFuture%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFFutureTask%EF%BC%9F"><span class="toc-text">什么是Callable和Future？什么是FutureTask？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">sleep()和 wait()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95-wait-notify-%E5%92%8C-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E9%87%8C%EF%BC%9F"><span class="toc-text">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-yield-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">线程的 sleep()方法和 yield()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADinterrupted%E5%92%8CisInterrupted%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java中interrupted和isInterrupted方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是阻塞式方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">Java中怎样唤醒一个阻塞的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">notify()和 notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E4%B8%8E%E5%8D%8F%E4%BD%9C%EF%BC%9F"><span class="toc-text">Java是如何实现多线程之间的通讯与协作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">线程之间如何通信及线程之间如何同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">同步方法和同步块，哪个是更好的选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%8C%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么是线程同步和线程互斥，有哪几种实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%88Monitor%EF%BC%89%E5%86%85%E9%83%A8%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">在监视器（Monitor）内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%B7%B2%E8%BE%BE%E5%88%B0%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">在Java中怎么保证多线程的安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你对线程优先级的理解是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E5%9D%97%E6%98%AF%E8%A2%AB%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">线程类的构造方法、静态块是被哪个线程调用的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%80%E4%BB%BD%E7%BA%BF%E7%A8%8B-dump-%E6%96%87%E4%BB%B6%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%EF%BC%9F"><span class="toc-text">Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">一个线程运行时发生异常会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">Java 线程数过多会造成什么异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">多线程的常用方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8BB-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B-A-%E4%BF%AE%E6%94%B9%E4%BA%86%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">线程B 怎么知道线程 A 修改了变量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFThreadLocal%EF%BC%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">什么是ThreadLocal？说一说你对ThreadLocal的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocal%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">为什么ThreadLocal会造成内存泄漏？如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8ThreadLocal%E4%B8%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">为什么用ThreadLocal不用线程成员变量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock"><span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3%E5%92%8Csynchronized%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-text">Lock接口和synchronized同步，对比它有什么优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-Lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">synchronized 和 Lock 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Lock%E4%B8%8EAQS%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">怎么理解Lock与AQS的关系？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-text">什么是AQS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">AQS是怎么实现同步管理的？底层数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">AQS有哪些核心的方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-text">什么是可重入，什么是可重入锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">公平锁和非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%AF%94%E5%85%AC%E5%B9%B3%E9%94%81%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-text">为什么非公平锁比公平锁性能更好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ReentrantLock是如何实现公平锁的？非公平锁的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">synchronized 和 ReentrantLock 区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ReentrantReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">共享锁和独占锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8C%81%E6%9C%89%E8%AF%BB%E9%94%81%E8%BF%98%E8%83%BD%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">线程持有读锁还能获取写锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E9%99%8D%E7%BA%A7%EF%BC%9FReentrantReadWriteLock%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9F"><span class="toc-text">什么是锁的升降级？ReentrantReadWriteLock为什么不支持锁升级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock%E5%BA%95%E5%B1%82%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">ReentrantReadWriteLock底层读写状态如何设计？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-JDK1-7%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ConcurrentHashMap JDK1.7实现的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-JDK1-8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ConcurrentHashMap JDK1.8实现的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-JDK1-7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C1-8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E4%B8%AD%EF%BC%8CConcurrentHashMap%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%93%BE%E8%A1%A8%E6%89%8D%E4%BC%9A%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">JDK1.8中，ConcurrentHashMap什么情况下链表才会转换成红黑树进行存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ConcurrentHashMap的get方法是否需要加锁，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84key%E3%80%81value%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%EF%BC%9F"><span class="toc-text">ConcurrentHashMap的key、value是否可以为null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9C%A8ConcurrentHashMap%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">存储在ConcurrentHashMap中的每个节点是什么样子的，有哪些变量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">BlockingQueue阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBlockingQueue%EF%BC%9F"><span class="toc-text">什么是BlockingQueue？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">你了解的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">ArrayBlockingQueue和LinkedBlockingQueue有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%98%9F%E5%88%97%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%EF%BC%8C%E5%BD%93%E7%94%9F%E4%BA%A7%E8%80%85%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%BD%93%E5%89%8D%E9%98%9F%E5%88%97%E5%AD%98%E5%9C%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列存在元素的呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%87%AA%E5%B7%B1%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3CAS%E6%9C%BA%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-text">你自己怎样理解CAS机制的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93JDK%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E5%88%B0%E4%BA%86CAS%E5%90%97%EF%BC%9F%E4%BE%8B%E4%B8%BE%E5%87%A0%E4%B8%AA"><span class="toc-text">你知道JDK中哪些地方用到了CAS吗？例举几个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%92%8C%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-text">CAS有什么问题和缺陷？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFABA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是ABA问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">ABA问题怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E3%80%81volatile%E3%80%81CAS-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-text">synchronized、volatile、CAS 之间的比较？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="toc-text">什么是原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">原子类的常用类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Atomic-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说一下 Atomic 的原理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">并发工具类（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E3%80%81Exchanger%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">CountDownLatch、CyclicBarrier、Semaphore、Exchanger了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">CyclicBarrier和CountDownLatch有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">什么是线程池？为什么要用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E9%83%BD%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">线程池的核心参数都哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">常用线程池的区别及特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">线程池的拒绝策略都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%EF%BC%8CExecutor%E5%92%8CExecutors%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">在Java中，Executor和Executors的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">线程池都有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8Cexecute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">线程池中submit()和execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">分析线程池的实现原理和线程池的调度过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%86%E9%85%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">如何合理分配线程池大小？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-text">线程池如何调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-text">线程池如何实现动态修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">使用无界队列的线程池会导致什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BD%93%E5%89%8D%E5%A4%84%E4%BA%8E%E7%A9%BA%E9%97%B2%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E6%98%AF%E4%B8%8D%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%E7%9A%84%EF%BC%8C%E9%82%A3%E8%BF%99%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%A4%84%E4%BA%8E%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%84%E4%BA%8E%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-text">线程池代码题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%8C%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E6%89%93%E5%8D%B01-100%EF%BC%8C%E5%90%8C%E9%A2%98%E7%9B%AE%EF%BC%9A%E2%80%9C2%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0100%E7%9A%84%E5%A5%87%E5%81%B6%E6%95%B0%E2%80%9D"><span class="toc-text">写一个双线程轮流打印1-100，同题目：“2个线程，交替打印100的奇偶数”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%87%BA1-100"><span class="toc-text">三个线程顺序打出1-100</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BA%BF%E7%A8%8BA%EF%BC%8CB%E3%80%81C%EF%BC%8C%E5%88%86%E5%88%AB%E6%89%93%E5%8D%B01%E3%80%812%E3%80%813%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C10%E6%AC%A1"><span class="toc-text">多线程问题：线程A，B、C，分别打印1、2、3，顺序执行10次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E7%B4%AF%E5%8A%A0%E6%80%8E%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C100%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%B4%AF%E5%8A%A0100%E6%AC%A1"><span class="toc-text">计数累加怎么线程安全，可以怎么实现，100个线程，每个线程累加100次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%A4%E5%8F%89%E6%89%93%E5%8D%B012A34B56C%EF%BC%8C%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%E4%B8%AA%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%EF%BC%89"><span class="toc-text">线程交叉打印12A34B56C，多种实现方式（一个打印数字，一个打印字母）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABCD%E2%80%A6Z%E5%AD%97%E6%AF%8D%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%86%99%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%86%99"><span class="toc-text">两个线程交替打印ABCD…Z字母，一个大写一个小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%87%BAa1b2c3%E2%80%A6z26"><span class="toc-text">两个线程交替打印出a1b2c3…z26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%89%93%E5%8D%B0abcd%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%89%93%E5%8D%B01234%EF%BC%8C%E9%9C%80%E6%B1%82%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%87%BAa1b2c3d4a1b2c3d4%EF%BC%9B%E6%89%93%E5%8D%B010%E8%BD%AE"><span class="toc-text">两个线程，一个打印abcd，一个打印1234，需求交替打印出a1b2c3d4a1b2c3d4；打印10轮</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记"><img alt="05 MySQL知识点总结 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MySQl_ALL.png"></a><div class="content"><a class="title" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="05 MySQL知识点总结 笔记">05 MySQL知识点总结 笔记</a><a class="article-recent_post_categories" href="/2024/12/16/01-MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/" title="01 Spring全家桶 笔记"><img alt="01 Spring全家桶 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Spring1204.png"></a><div class="content"><a class="title" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/" title="01 Spring全家桶 笔记">01 Spring全家桶 笔记</a><a class="article-recent_post_categories" href="/2024/12/04/Spring%E6%A1%86%E6%9E%B6/">Spring</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="02 JVM 笔记"><img alt="02 JVM 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png"></a><div class="content"><a class="title" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="02 JVM 笔记">02 JVM 笔记</a><a class="article-recent_post_categories" href="/2024/12/02/Java-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/04/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="01 Java并发编程 笔记"><img alt="01 Java并发编程 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png"></a><div class="content"><a class="title" href="/2024/11/04/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="01 Java并发编程 笔记">01 Java并发编程 笔记</a><a class="article-recent_post_categories" href="/2024/11/04/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="00 Java集合框架 笔记"><img alt="00 Java集合框架 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Javalogobalala.png"></a><div class="content"><a class="title" href="/2024/11/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="00 Java集合框架 笔记">00 Java集合框架 笔记</a><a class="article-recent_post_categories" href="/2024/11/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Solitude</span></div><div class="footer-bar-description">来自 Heisenberg 的原创文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">Coo1heisenberg’s BLOG</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.10.6"></script><script src="/js/main.js?v=1.10.6"></script><script src="/js/third_party/waterfall.min.js?v=1.10.6"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.10.6"></script><script>dark()
</script><script src="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="//open.lightxi.com/cdnjs/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script defer pjax src="//open.lightxi.com/cdnjs/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.10.6"></script><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["2024/12/16/01-MySQL知识点归纳/","2024/12/04/Spring框架/","2024/12/02/Java-JVM虚拟机/","2024/11/04/Java-并发编程/","2024/11/01/Java-集合框架/","2024/09/28/00-前端开发入门教程/","2024/09/26/01-空间转录组/","2024/09/13/00-单细胞多组学分析/","2024/07/22/00-MongoDB/","2024/07/17/00-elasticsearch/","2024/07/15/01-黑马redis/","2024/07/13/00-黑马redis/","2024/07/08/00-黑马SSM/","2024/07/08/01-头条点评项目/","2024/07/06/00-Mybatis-Plus/","2024/06/29/00-黑马MySQL/","2024/06/25/00-头条点评项目/","2024/06/21/02-Python/","2024/06/11/01-Python/","2024/05/25/00-Python/","2024/05/13/DesignPattern/","2024/05/13/Docker/","2024/05/13/Nginx/","2024/05/13/Linux/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>