<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>00 异步框架 笔记 | coo1heisenberg's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.10.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="异步框架 异步框架介绍 适用的场景： 需要是一个 异步场景，同时为了和消息队列区别开来，最好是多阶段的 整体一定是异步 分多阶段，阶段之间有依赖 每个阶段最好也都是异步的，同步一般就放不同阶段 其实只要满足做的事情是异步的，比如：做一个AI计算也好，图像处理也好，大规模数据导入也好，"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="coo1heisenberg's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.10.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;border-radius:0 5px 5px 0",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-05-12 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.webp'
    },
    copyright: {"limit":50,"author":"作者: Coo1heisenberg’s BLOG","link":"链接: ","source":"来源: coo1heisenberg's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Project/">Project<sup>4</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/SpringCloud/">SpringCloud<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">2025/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">2024/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">2024/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">2024/06</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">2024/05</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">2024/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/Python%E9%AB%98%E7%BA%A7/">Python高级<sup>1</sup></a><a href="/tags/Docker%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Docker基础语法<sup>1</sup></a><a href="/tags/Nginx%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Nginx基础语法<sup>1</sup></a><a href="/tags/MongoDB/">MongoDB<sup>1</sup></a><a href="/tags/HTML-CSS/">HTML+CSS<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架<sup>1</sup></a><a href="/tags/Mybatis-Plus/">Mybatis-Plus<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Linux基础语法<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>1</sup></a><a href="/tags/%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/">空间转录组<sup>1</sup></a><a href="/tags/ElasticSearch/">ElasticSearch<sup>1</sup></a><a href="/tags/Project/">Project<sup>4</sup></a><a href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础<sup>2</sup></a><a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程<sup>1</sup></a><a href="/tags/SpringCloud/">SpringCloud<sup>1</sup></a><a href="/tags/MySQL/">MySQL<sup>2</sup></a><a href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">Spring全家桶<sup>1</sup></a><a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/">单细胞<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>1</sup></a><a href="/tags/Spring/">Spring<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon solitude st-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客主题</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" title="Solitude"><img class="nolazyload back-menu-item-icon" src="https://7.isyangs.cn/1/65eb200ee4dea-1.png" alt="Solitude"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">00 异步框架 笔记</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" href="/" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Asynchronous_frameworks.png" alt="00 异步框架 笔记"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java/">Java</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Project/"><span class="tags-name tags-punctuation">Project</span></a></div></div></div></div><h1 class="post-title">00 异步框架 笔记</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-01-09 20:35:15"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-01-09T12:35:15.000Z">2024-01-09T12:35:15.000Z</time></span><span class="post-meta-date" title="最后更新于 2025-01-15 20:32:42"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2025-01-15T12:32:42.356Z">2025-01-15T12:32:42.356Z</time></span><span class="post-meta-wordcount"><span class="post-meta-separator"></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>异步框架</h1>
<hr>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250110143333514.png" alt="整体流程" loading="lazy"></p>
<hr>
<h2 id="异步框架介绍"><a class="headerlink" href="#异步框架介绍"></a>异步框架介绍</h2>
<hr>
<p>适用的场景：</p>
<ul>
<li>需要是一个 <strong>异步场景</strong>，同时为了和消息队列区别开来，最好是多阶段的
<ul>
<li>整体一定是异步</li>
<li>分多阶段，阶段之间有依赖</li>
<li>每个阶段最好也都是异步的，同步一般就放不同阶段</li>
</ul>
</li>
<li>其实只要满足做的事情是异步的，比如：做一个AI计算也好，图像处理也好，大规模数据导入也好，文件下载也好，只要是这种一次处理的耗时比较多，看起来像异步的</li>
<li>其实抽象点来说就是有个具体业务的单独服务，框架就是调用这个服务的接口，比如说：微服务就是腾讯云这种，相当于就是微服务得提供创建一个事情的接口，和查询一个事情的接口，框架直接使用即可</li>
</ul>
<hr>
<h2 id="需求概述"><a class="headerlink" href="#需求概述"></a>需求概述</h2>
<hr>
<p>生产环境中，对外能力除了以同步接口的方式提供，很多业务还会涉及异步流程，比如：音视频处理、区块链、审核 等耗时操作。异步流程通常是有几种情况：</p>
<ol>
<li>发起者向同步接口发起任务</li>
<li>任务异步处理</li>
<li>发起者轮询结果</li>
</ol>
<p>现在要做的，就是为这类业务，提供通用的任务异步处理框架。原来从 0-1 开发一个异步业务，需要考虑 任务管理、异常处理、流量控制 等细节，通常开发周期很久，这个框架开发周期大大缩短</p>
<p>这里特别说一下，<strong>为什么不用直接用消息队列</strong>？</p>
<ul>
<li>核心原因是我们的场景，需要支持以下两点：
<ol>
<li>第一点，<strong>支持上下文更新操作</strong>。异步场景，可能不止一个操作，比如：一个视频处理任务，可能第一阶段是查询视频元信息、第二阶段是鉴黄、第三阶段是转码，那每一阶段的结果，当然需要记录下来，不然丢失了又是资源的损耗，而 <strong>消息队列通常是负责消息的流转，不支持更新</strong></li>
<li>第二点，这类异步任务场景，通常都 <strong>需要任务管理</strong>，比如：某个用户下进行中的任务列表，都是常见的查询方式，所以一定 <strong>需要关系化管理的能力</strong></li>
</ol>
</li>
</ul>
<p><strong>核心</strong>：框架，能力复用、节约开发成本</p>
<p><strong>功能列表</strong>：</p>
<ul>
<li>支持任务创建（同步返回任务<code>ID</code>）</li>
<li>支持通过任务 <code>ID</code> 查询</li>
<li>任务自动调度，维护任务状态</li>
<li>支持各种任务快速注册</li>
<li>任务支持优先级调度</li>
<li>服务挂掉恢复后可以自动续做</li>
<li>灵活的任务配置</li>
<li>任务使用 <code>MySQL</code> 之类 <code>DB</code> 来存储</li>
</ul>
<p><strong>性能指标</strong>：</p>
<ul>
<li>2 核 4G 的虚拟机下，创建任务接口、占据任务接口、查询任务结果接口能达到 2000 <code>QPS</code>，并可以水平扩展</li>
</ul>
<hr>
<h2 id="整体设计"><a class="headerlink" href="#整体设计"></a>整体设计</h2>
<hr>
<h3 id="目标"><a class="headerlink" href="#目标"></a>目标</h3>
<ul>
<li>实现功能为主，优化靠后</li>
<li>本次就实现一个叫 <code>lark</code> 的任务即可，<code>lark</code> 任务就做一件事，打印一条日志到控制台</li>
</ul>
<p><strong>涉及中间件有哪些</strong></p>
<ul>
<li><code>MySQL</code>：存任务信息</li>
<li><code>Redis</code>：提供分布式锁，缓存信息加速查询</li>
</ul>
<h3 id="服务介绍"><a class="headerlink" href="#服务介绍"></a>服务介绍</h3>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250110153012356.png" alt="服务介绍" loading="lazy"></p>
<ul>
<li><code>flowsvr</code> 服务：用来提供任务相关接口，比如：任务创建、任务查询、查询待处理任务，任务治理不单独作为服务，而是作为一个模块放在 <code>flowsvr</code></li>
<li>worker：通过 <code>flowsvr</code> 占据任务并执行，执行后通过 <code>flowsvr</code> 更新任务状态</li>
<li>发起任务的服务：可以直接 <code>curl</code> 发起，或者 <code>postman</code> 发起</li>
</ul>
<p>部署模式：</p>
<ul>
<li>多 个 <code>flowsvr pod</code>，部署在腾讯云集群上，通过 <code>clb</code> （负载均衡）访问</li>
<li>多 个 <code>worker pod</code>，部署在腾讯云上</li>
<li>1 个 <code>MySQL</code></li>
<li>1 个 <code>Redis</code></li>
</ul>
<hr>
<h3 id="表结构设计"><a class="headerlink" href="#表结构设计"></a>表结构设计</h3>
<hr>
<h4 id="任务信息表"><a class="headerlink" href="#任务信息表"></a>任务信息表</h4>
<p><strong>存放着的是一个任务的具体信息数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_lark_task_1` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_type` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_stage` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">3</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `crt_retry_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;已经重试几次了&#x27;</span>,</span><br><span class="line">  `max_retry_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大能重试几次&#x27;</span>,</span><br><span class="line">  `max_retry_interval` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大重试间隔&#x27;</span>,</span><br><span class="line">  `schedule_log` <span class="type">varchar</span>(<span class="number">4096</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;调度信息&#x27;</span>,</span><br><span class="line">  `priority` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;优先级&#x27;</span>,</span><br><span class="line">  `task_context` <span class="type">varchar</span>(<span class="number">8192</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;任务上下文&#x27;</span>,</span><br><span class="line">  `order_time` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度时间，越小调度越优先&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `modify_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_task_id` (`task_id`),</span><br><span class="line">  KEY `idx_user_id` (`user_id`),</span><br><span class="line">  KEY `idx_tasktype_status_modify_time` (`status`, `order_time`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>max_retry_interval</code>：<strong>最大重试间隔</strong>，设置了这个字段，就可以做阶梯间隔重试，比如：设置为 10，那就是最大间隔 10，第一次失败之后，需要间隔 1s 才能被调度，第二次 2s，第三次 4 秒，第四次 8 秒，第五次 10s（因为最大是 10）</p>
</li>
<li>
<p><code>schedule_log</code>：<strong>调度日志</strong>，包含这个任务本次调度的追踪 <code>id</code>，耗时，可以用如下结构的 <code>json</code> 化数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scheduleInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ScheduleData <span class="comment">// 最近一次调度信息LastData</span></span><br><span class="line">    HistoryDatas []scheduleData <span class="comment">// 历史调度信息，保留最近5次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduleData struct ScheduleData</span></span><br><span class="line"><span class="keyword">type</span> scheduleData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Traceld <span class="type">string</span></span><br><span class="line">    ErrMsg <span class="type">string</span></span><br><span class="line">    Cost <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>task_context</code>：<strong>上下文</strong>，一般可以把任务的请求放进去，可以用如下结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lark任务的上下文</span></span><br><span class="line"><span class="keyword">type</span> LarkTaskContext <span class="keyword">struct</span> &#123;</span><br><span class="line">    RegBody *LarkRegBody <span class="comment">// 业务请求的请求体</span></span><br><span class="line">	.... <span class="comment">// 根据业务添加更多字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="任务配置表"><a class="headerlink" href="#任务配置表"></a>任务配置表</h4>
<p><strong>存放的单个记录是某种任务类型的配置</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_lark_task_1` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_type` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `task_stage` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">3</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `crt_retry_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;已经重试几次了&#x27;</span>,</span><br><span class="line">  `max_retry_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大能重试几次&#x27;</span>,</span><br><span class="line">  `max_retry_interval` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大重试间隔&#x27;</span>,</span><br><span class="line">  `schedule_log` <span class="type">varchar</span>(<span class="number">4096</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;调度信息&#x27;</span>,</span><br><span class="line">  `priority` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;优先级&#x27;</span>,</span><br><span class="line">  `task_context` <span class="type">varchar</span>(<span class="number">8192</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;任务上下文&#x27;</span>,</span><br><span class="line">  `order_time` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度时间，越小调度越优先&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `modify_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_task_id` (`task_id`),</span><br><span class="line">  KEY `idx_user_id` (`user_id`),</span><br><span class="line">  KEY `idx_tasktype_status_modify_time` (`status`, `order_time`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>初始化 <code>lark</code> 任务配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_schedule_cfg(task type, schedule_limit, schedule_interval,</span><br><span class="line">max_processing <span class="type">time</span>, max_retry_num, retry_interval, max_retry_interval)</span><br><span class="line"><span class="keyword">values</span>(&quot;lark&quot;, <span class="number">100</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个配置是说任意一个 <code>worker</code> 每 10s 调度一次，每次调度 100 个任务，每个任务这次调度执行的时间最多 30s，当然，系统运行过程中总可能失败，所以最多有 3 次机会失败，每次失败之后，重试时间渐进式增长（翻倍），初始时 5s，重试间隔时间最大不超过 30s</p>
</li>
</ul>
<hr>
<h4 id="任务位置表"><a class="headerlink" href="#任务位置表"></a>任务位置表</h4>
<p>这个是任务位置表，<strong>用来辅助分表功能的实现</strong>，主要两个字段：</p>
<ul>
<li><code>begin</code> 用于 <strong>记录下次调度往哪个表拉取数据</strong></li>
<li><code>end</code> 用于 <strong>记录下次创建任务往哪个表存放</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_schedule_pos` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `task_type` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;调度开始于几号表&#x27;</span>,</span><br><span class="line">  `schedule_begin_pos` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度开始于几号表&#x27;</span>,</span><br><span class="line">  `schedule_end_pos` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度结束于几号表&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `modify_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_task_type` (`task_type`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_schedule_pos (task_type, schedule_begin_pos, schedule_end_pos) <span class="keyword">VALUES</span> (<span class="string">&#x27;t_lark_task&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="flowsvr-设计"><a class="headerlink" href="#flowsvr-设计"></a>flowsvr 设计</h3>
<hr>
<h4 id="创建任务（create-task）"><a class="headerlink" href="#创建任务（create-task）"></a>创建任务（<code>create_task</code>）</h4>
<p><strong>请求字段</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113172039835.png" alt="Task的结构" loading="lazy"></p>
<p><strong>返回字段</strong>：</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113172208554.png" alt="返回字段" loading="lazy"></p>
<p><strong>接口实例</strong>：</p>
<ul>
<li>
<p>请求地址：<code>http://&lt;ip地址&gt;:&lt;端口号&gt;/v1/create_task</code></p>
</li>
<li>
<p>接口方法：<code>POST</code></p>
</li>
<li>
<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;task data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;niuniu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;task_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;task_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lark&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;task_stage&quot;</span><span class="punctuation">:</span><span class="string">&quot;sendmsg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;crt_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max_retry_interval&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;schedule log&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;RegBody\&quot;:&#123;\&quot;Msg\&quot;:\&quot;nice to meet u\&quot;,\&quot;FromAddr\&quot;:\&quot;fish\&quot;,\&quot;ToAddr\&quot;:\&quot;cat\&quot;&#125;, \&quot;UserId\&quot;:\&quot;\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modify time&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;task_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;dofedf63-9bd8-4283-b584-6946fc3fbd70-lark-1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="占据一批任务（hold-tasks"><a class="headerlink" href="#占据一批任务（hold-tasks"></a>占据一批任务（<code>hold_tasks</code>)</h4>
<p><code>worker</code> 会调用该接口占据任务</p>
<p><strong>请求字段</strong>：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>task_type</code></td>
<td><code>string</code></td>
<td>任务类型</td>
</tr>
<tr>
<td><code>limit</code></td>
<td><code>int</code></td>
<td>一次占据多少条，不超过20000条</td>
</tr>
</tbody>
</table>
<p><strong>返回字段</strong>：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td><code>int</code></td>
<td>执行结果</td>
</tr>
<tr>
<td><code>msg</code></td>
<td><code>msg</code></td>
<td>失败情况的特殊说明</td>
</tr>
<tr>
<td><code>task_list</code></td>
<td><code>Task</code>数组</td>
<td>任务列表</td>
</tr>
</tbody>
</table>
<p><strong>接口实例</strong>：</p>
<ul>
<li>
<p>请求地址：<code>http://&lt;ip地址&gt;:&lt;端口号&gt;/v1/hold_tasks</code></p>
</li>
<li>
<p>接口方法：<code>POST</code></p>
</li>
<li>
<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;task type&quot;</span><span class="punctuation">:</span><span class="string">&quot;lark&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;task_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;user id&quot;</span><span class="punctuation">:</span><span class="string">&quot;niuniu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task id&quot;</span><span class="punctuation">:</span><span class="string">&quot;c3d03039-f654-4296-aaee-df189dcbc59d lark 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lark&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task stage&quot;</span><span class="punctuation">:</span><span class="string">&quot;sendmsg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;crt_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_retry_interval&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;schedule_log&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;RegBody\&quot;:&#123;\&quot;Msg\&quot;:\&quot;nice to meet u\&quot;,\&quot;FromAddr\&quot;:\&quot;fish\&quot;,\&quot;ToAddr\&quot;:\&quot;cat\&quot;&#125;, \&quot;UserId\&quot;:\&quot;\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;order_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-11-07T16:32:30+08:00&quot;</span>&#x27;modify time<span class="string">&quot;:&quot;</span><span class="number">2023</span><span class="number">-11</span><span class="number">-07</span>T16<span class="punctuation">:</span><span class="number">41</span><span class="punctuation">:</span><span class="number">50</span>+<span class="number">08</span><span class="punctuation">:</span><span class="number">00</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="获取任务列表（get-task-list）"><a class="headerlink" href="#获取任务列表（get-task-list）"></a>获取任务列表（get_task_list）</h4>
<p><strong>该接口可用于后台管理查看任务列表</strong>（按 <code>order_time</code> 由小到大排序）</p>
<p><strong>请求字段</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>task_type</code></td>
<td><code>string</code></td>
<td>任务类型</td>
</tr>
<tr>
<td><code>status</code></td>
<td><code>int</code></td>
<td>指明要查询哪种状态的任务</td>
</tr>
<tr>
<td><code>limit</code></td>
<td><code>int</code></td>
<td>一次查询多少条，不超过2000条</td>
</tr>
</tbody>
</table>
<p><strong>返回字段</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td><code>int</code></td>
<td>执行结果</td>
</tr>
<tr>
<td><code>msg</code></td>
<td><code>msg</code></td>
<td>失败情况的特殊说明</td>
</tr>
<tr>
<td><code>task_list</code></td>
<td><code>Task</code>数组</td>
<td>任务列表</td>
</tr>
</tbody>
</table>
<p><strong>接口实例</strong></p>
<ul>
<li>
<p><strong>请求地址</strong>：<code>http://&lt;ip地址&gt;:&lt;端口号&gt;/v1/get_task_list?taskType=&lt;类型&gt;&amp;status=&lt;状态&gt;&amp;limit=&lt;数量&gt;</code></p>
<ul>
<li>eg：<code>http://43.139.192.217:41555/v1/get_task_list?task_type=lark&amp;status=3&amp;limit=200</code></li>
</ul>
</li>
<li>
<p><strong>接口方法</strong>：<code>GET</code></p>
</li>
<li>
<p><strong>响应体</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;task list&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;user id&quot;</span><span class="punctuation">:</span><span class="string">&quot;niuniu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task id&quot;</span><span class="punctuation">:</span><span class="string">&quot;c3d03039-f654-4296-aaee-df189dcbc59d lark 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lark&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;task stage&quot;</span><span class="punctuation">:</span><span class="string">&quot;sendmsg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;crt_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_retry_interval&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;schedule_log&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;RegBody\&quot;:&#123;\&quot;Msg\&quot;:\&quot;nice to meet u\&quot;,\&quot;FromAddr\&quot;:\&quot;fish\&quot;,\&quot;ToAddr\&quot;:\&quot;cat\&quot;&#125;, \&quot;UserId\&quot;:\&quot;\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;order_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-11-07T16:32:30+08:00&quot;</span>&#x27;modify time<span class="string">&quot;:&quot;</span><span class="number">2023</span><span class="number">-11</span><span class="number">-07</span>T16<span class="punctuation">:</span><span class="number">41</span><span class="punctuation">:</span><span class="number">50</span>+<span class="number">08</span><span class="punctuation">:</span><span class="number">00</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="更新任务信息（set-task）"><a class="headerlink" href="#更新任务信息（set-task）"></a>更新任务信息（set_task）</h4>
<p><strong>更新任务信息</strong></p>
<p><strong>请求字段</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>task_id</code></td>
<td><code>string</code></td>
<td>任务id</td>
</tr>
<tr>
<td><code>status</code></td>
<td><code>int</code></td>
<td>任务状态，为0则不更新</td>
</tr>
<tr>
<td><code>context</code></td>
<td><code>string</code></td>
<td>上下文，为 <code>&quot;&quot;</code> 则不更新</td>
</tr>
<tr>
<td><code>stage</code></td>
<td><code>string</code></td>
<td>阶段，为 <code>&quot;&quot;</code> 则不更新</td>
</tr>
<tr>
<td><code>schedule_log</code></td>
<td><code>string</code></td>
<td>调度日志，为空则不更新</td>
</tr>
</tbody>
</table>
<p><strong>返回字段</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td><code>int</code></td>
<td>执行结果</td>
</tr>
<tr>
<td><code>msg</code></td>
<td><code>msg</code></td>
<td>失败情况的错误说明</td>
</tr>
</tbody>
</table>
<p><strong>接口实例</strong>：</p>
<ul>
<li>
<p>请求地址：<code>http://&lt;ip地址&gt;:&lt;端口号&gt;/v1/set_task</code></p>
</li>
<li>
<p>接口方法：<code>POST</code></p>
</li>
<li>
<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;task_data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;task_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;3c1e7d8d-3c7c-426c-a1a7-6308058536c7-lark-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stage&quot;</span><span class="punctuation">:</span><span class="string">&quot;record&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;schedule_log&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="获取任务配置列表（get-task-schedule-cfg-list）"><a class="headerlink" href="#获取任务配置列表（get-task-schedule-cfg-list）"></a>获取任务配置列表（get_task_schedule_cfg_list）</h4>
<p><strong>返回字段</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td><code>int</code></td>
<td>执行结果</td>
</tr>
<tr>
<td><code>msg</code></td>
<td><code>msg</code></td>
<td>失败情况的错误说明</td>
</tr>
<tr>
<td><code>task_schedule_cfg_list</code></td>
<td><code>TaskScheduleCfg</code>数组</td>
<td>任务配置列表</td>
</tr>
</tbody>
</table>
<p><strong>TaskScheduleCfg结构</strong></p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113175802316.png" alt="TaskScheduleCfg结构" loading="lazy"></p>
<p><strong>接口实例</strong>：</p>
<ul>
<li>
<p>请求地址：<code>http://&lt;ip地址&gt;:&lt;端口号&gt;/v1/get_task_schedule_cfg_list</code></p>
</li>
<li>
<p>接口方法：<code>GET</code></p>
</li>
<li>
<p>响应体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;task_schedule_cfg_list&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;task_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lark&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;schedule_limit&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;schedule_interval&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_processing_time&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_retry_num&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;retry_interval&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;max_retry_interval&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;create_time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-11-07T09:15:14+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;modify_time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-11-07T09:15:14+08:00&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="worker-设计"><a class="headerlink" href="#worker-设计"></a>worker 设计</h3>
<hr>
<ul>
<li><code>worker</code> 定时去获取对应任务</li>
<li><code>worker</code> 通过 <code>hold_tasks</code> 接口占据并获取任务</li>
<li>多个 <code>worker</code> 获取任务，使用分布式锁解决竞争</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113182344567.png" alt="worker设计" loading="lazy"></p>
<ul>
<li>
<p><code>worker</code> 处理某个任务的示意：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *LarkTask)</span></span> Process() <span class="type">error</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> p.ContextData.Stage &#123;</span><br><span class="line">    <span class="keyword">case</span> stageDosomething:</span><br><span class="line">        err := p.Dosometing()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        p.ContextData.stage= stagestoreData</span><br><span class="line">        p.SetcontextLocal(p.ContextData)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> StageStoreData:</span><br><span class="line">        err := p.storeData()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        p.SetcontextLocal(p.ContextData)</span><br><span class="line">        p.Base().status = <span class="type">int</span>(rpc_model.TaskstatusSuccess)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="重点流程"><a class="headerlink" href="#重点流程"></a>重点流程</h3>
<hr>
<h4 id="创建任务（flowsvr）"><a class="headerlink" href="#创建任务（flowsvr）"></a>创建任务（flowsvr）</h4>
<p>注意：该流程由用户触发，请求到 <code>flowsvr</code></p>
<ol>
<li>用户（可能是前端、可能是用户自己的后端服务）发起创建任务请求</li>
<li><code>flowsvr</code> 接收到之后，会根据路由找到创建任务函数</li>
<li>检查参数</li>
<li>执行任务，具体是找到要插入几号表（目前没实现分表，默认都是1），向数据库插入任务信息，填充返回包</li>
<li>依赖框架给用户回包</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113183615449.png" alt="创建任务的流程" loading="lazy"></p>
<h4 id="占据任务（flowsvr）"><a class="headerlink" href="#占据任务（flowsvr）"></a>占据任务（flowsvr）</h4>
<p>注意：该流程由 <code>worker</code> 触发，请求到 <code>flowsvr</code></p>
<ol>
<li><code>worker</code> 发起占据任务请求</li>
<li><code>flowsvr</code> 接收到之后，会根据路由找到占据任务函数</li>
<li>检查参数</li>
<li>执行请求，具体是找到要拉取几号表（目前没实现分表，默认都是1），从数据库拉取一批任务，将这批任务设置为执行中，填充返回包</li>
<li>依赖框架给 <code>worker</code> 回包</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113183826478.png" alt="占据任务流程" loading="lazy"></p>
<h4 id="任务调度（worker）"><a class="headerlink" href="#任务调度（worker）"></a>任务调度（worker）</h4>
<ol>
<li>启动任务调度</li>
<li>根据任务间隔来触发调度函数</li>
<li>获取锁</li>
<li>调用 <code>hold_tasks</code> 接口占据任务，并得到要执行的任务列表</li>
<li>释放锁</li>
<li>并发去执行这些任务</li>
<li>等待下次调度，跳转到第 2 步</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113184137119.png" alt="任务调度流程" loading="lazy"></p>
<hr>
<h3 id="状态流转"><a class="headerlink" href="#状态流转"></a>状态流转</h3>
<hr>
<p>状态分为：等待中、执行中、成功、失败</p>
<ul>
<li>其中 <strong>等待中</strong> 和 <strong>执行中</strong> 属于 中间态，根据不同情况可以跳转到其它状态</li>
<li><strong>成功</strong>、<strong>失败</strong> 为终态，不会再改变（直接操作数据库，或者后台管理改数据除外）</li>
</ul>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250113184711201.png" alt="状态流转" loading="lazy"></p>
<hr>
<h3 id="最大重试间隔"><a class="headerlink" href="#最大重试间隔"></a>最大重试间隔</h3>
<hr>
<ul>
<li>普遍的重试间隔需求无非是 <strong>均匀重试</strong> 和 <strong>渐进式重试</strong></li>
<li>本框架默认使用一个 <code>interval</code> 字段支持 渐进式重试，<code>interval</code> 表示最大的间隔秒。考虑到确实有部分场景，希望均匀重试，但这里并不想新增一个标记字段来配合表示，这里 <strong>选择了一种巧妙的方式，即：使用负数表示均匀重试时间</strong></li>
</ul>
<p>eg：</p>
<ul>
<li>如果 <code>interval</code> 等于 <code>-10</code>，均匀重试，那么重试间隔为 <code>[10,10,10 .....10]</code> 直到最大重试次数</li>
<li>如果 <code>interval</code> 等于 <code>10</code>，渐进式重试，那么重试间隔为 <code>[1,2,4,8,10 .....10]</code> 直到最大重试次数</li>
</ul>
<p>更丰富的重试策略：</p>
<ol>
<li>按列表，也就是 <code>interval</code> 变成字符串，值直接是每次时间间隔，比如：1, 10, 25, 5, 100</li>
<li>按<code>Lua</code>，也就是把配置逻辑放到 <code>Lua</code> 文本，实际不需要这么复杂</li>
</ol>
<hr>
<h3 id="优先级设计"><a class="headerlink" href="#优先级设计"></a>优先级设计</h3>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_lark_task_1` (</span><br><span class="line"> ....</span><br><span class="line">  `priority` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;优先级&#x27;</span>,</span><br><span class="line"> ....</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<p>这里 <code>priority</code> 有两种使用方案：</p>
<ul>
<li>
<p><strong>方案一</strong>：用 <code>priority</code> 排序，提供优先级的概念</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> `t lark task <span class="number">1</span>` <span class="keyword">WHERE</span> (status <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> priority <span class="keyword">desc</span>, modify <span class="type">time</span> LIMIT <span class="number">100</span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>核心就是将 <code>priority</code> 加入排序参数，做联合排序，当然，这种高频操作是需要建联合索引的</li>
<li>优点：
<ol>
<li>简单</li>
</ol>
</li>
<li>缺点：
<ol>
<li>需要将 <code>priority</code> 加入联合索引，影响性能，并且大多时候 <code>priority</code> 都是一样的，这个开销有点亏</li>
<li><code>priority</code> 是固定的，不够灵活，比如：优先度高的任务，即使失败之后，马上又是最先被调度到的，占据资源还容易堵死普通任务</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>方案二</strong>：<code>order_time</code> 是个好东西，既然都抽象了 <code>order_time</code> 作为排序字段，<code>order_time</code> 可以包含创建时间、更新时间、重试间隔的影响，这里 <strong>给 <code>priority</code> 一个语意，表示优先几秒</strong>，最大优先 1 年（足够大）</p>
<ul>
<li>创建时，<code>order_time</code> = 当前时间 - <code>priority</code>，表示优先 <code>priority</code>秒排序，比如：<code>priority</code> = 10，相当于你是提前10s创建的任务</li>
<li>调度之后，<code>order_time</code> = 当前时间 - <code>priority</code>，始终维持着优先秒数但是如果是重试之后，这时候如果重试间隔不等于0，也就是设置了重试间隔，此时 <code>order_time</code> = 当前时间 + 算出来的重试间隔，因为这里就是要让他等一会儿再调度，优先就没用了</li>
</ul>
</li>
</ul>
<p>优点：解耦；不用加入联合索引；足够灵活适合框架</p>
<p><strong>对比</strong>：很明显，方案二，性能友好，同时多阶段情况下，让低优任务也有被更多被调度的机会，整体更加灵活，耦合更小。用户可以灵活使用优先级，比如：用户可以定义高优是优先就是优先 1 天，转换成 <code>priority</code> 参数即可</p>
<p>这里我们采用的方式，是将 <code>priority</code> 秒化，及 <code>priority</code> 不表示级别，而表示优先多少秒，然后将这个数字融入我们的排序字段，这种方案耦合小、成本低、足够灵活适合框架</p>
<hr>
<h3 id="分表设计"><a class="headerlink" href="#分表设计"></a>分表设计</h3>
<hr>
<p>分表的意义：就是防止表里面数据量太大，影响对表操作的性能</p>
<p>涉及到 <code>t_schedule_pos</code> 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_schedule_pos` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `task_type` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;调度开始于几号表&#x27;</span>,</span><br><span class="line">  `schedule_begin_pos` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度开始于几号表&#x27;</span>,</span><br><span class="line">  `schedule_end_pos` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调度结束于几号表&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `modify_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_task_type` (`task_type`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键字段 <code>schedule_begin_pos</code> 表示热点任务数据从几号表开始位置，<code>schedule_end_pos</code> 表示热点任务数据从几号表结束，一开始两者都等于1，表示只有一张表</li>
</ul>
<h4 id="分表流程"><a class="headerlink" href="#分表流程"></a>分表流程</h4>
<ol>
<li>当 1 号表达到闽值</li>
<li>任务治理通过扫描，发现了 1 号表记录数量达到了阈值，触发分表，也就是创建了 2 号表</li>
<li>经过步骤 2，此时的状态是占据任务请求走 1 号表，也就是 <code>schedule_begin_pos</code> 为1，但新创建的任务，是放入 2 号表，也就是 <code>schedule_end_pos</code> 为 2</li>
<li><code>worker</code> 持续占据任务、消费任务，直到 1 号表任务都消费完成</li>
<li>此时 <code>worker</code> 再去占据任务，就会发现 1 号表没存活任务了，就会将 <code>schedule_begin_pos</code> 变成2，此后，占据任务请求和写入任务请求都是到 2 号表了</li>
<li>当然任务治理循环也可能发现 1 号表没存活任务了，也会将 <code>schedule begin_pos</code> 变成 2，此后，占据任务请求和写入任务请求都是到 2 号表了</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250114134008395.png" alt="分表流程示意图" loading="lazy"></p>
<h4 id="数据库状态流转"><a class="headerlink" href="#数据库状态流转"></a>数据库状态流转</h4>
<ol>
<li>初始时候，<code>schedule_begin_pos</code> 和 <code>schedule_end_pos</code> 都是 1，此时占据请求、写入请求都走 1 号表</li>
<li>1 号表纪录数量达到阈值，并创建 2 号表之后，<code>schedule_begin_pos</code> 依然是1，但 <code>schedule_end_pos</code> 变成 2，此时占据请求走 1 号表，写入请求，走 2 号表</li>
<li>消费完 1 号表后，<code>schedule_begin_pos</code> 就会变成 2，此时占据请求、写入请求都走 2 号表</li>
</ol>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250114134317887.png" alt="数据库状态流转示意图" loading="lazy"></p>
<h4 id="常见疑问点"><a class="headerlink" href="#常见疑问点"></a>常见疑问点</h4>
<p><strong>介绍你的分表方式</strong>？</p>
<p>答：</p>
<p>我们的任务数量达到一定阈值就会发生分表，分表之后新增任务写入新表，消费还是走老表，老表消费完成之后再消费到新表。消费几号表、写入几号表，这个信息我们也是<strong>通过 一张单独的任务位置表 记录的</strong></p>
<p><strong>为什么按大小分表</strong>？</p>
<p>答：</p>
<ul>
<li>我们是记录任务，任务一般做完之后，很快就成了比较冷的数据，甚至某些业务1，2月前的历史数据都可以删除掉，所以更适合这样滚动分表。</li>
<li><strong>分表之后，我们的任务消费、任务创建这种主要操作都是发生在热表上，通过任务 <code>id</code> 查询任务信息这种相对低频操作则可以发生通过后缀快速去对应的表查，无论冷热</strong></li>
<li>这种策略对性能友好、也对后面存储友好，同时也非常适合我们的场景</li>
</ul>
<p><strong>你为了机器人项目做了一个框架？你量这么小，弄500w分表</strong></p>
<p>答：</p>
<ul>
<li>这个我们其实 <strong>考虑了收益和成本</strong></li>
<li>首先，作为一个框架，我们需要能应对不同的情况，机器人项目虽然小，但其他异步场景一天几十万也是正常的比如区块链场景，所以提供分表对我们而言让框架不那么玩具化，这是收益</li>
<li>同时，从成本考虑，我们的分表方案其实 <strong>偏向滚表</strong>，到 500w 就产生新的表，<strong>旧表还有存活任务就继续消费旧表新任务写入新表</strong>，实现起来代码量也比较少，思路也比较清晰，成本较低</li>
<li>综合收益和成本来看，我认为这个算是前瞻性设计而不是过度设计</li>
</ul>
<p><strong>如果读写请求大到单个MySQL数据表处理不过来呢</strong>？</p>
<p>答：</p>
<ul>
<li>我们的热点请求，都是 <strong>任务调度相关的拉取任务</strong> 和 <strong>设置任务状态</strong></li>
<li>这两个操作都有走索引。通常来说普通的 <code>MySQL</code> 配置如：8核16G，每秒6000是没什么问题的，这样一小时可以支持2160W任务，在异步场景下瓶颈通常也不在这里</li>
<li>如果单表确实性能不够了，我们也可以支持按用户<code>Hash</code>分片，一个比较容易的方式是<strong>接入 <code>tdsql</code> 这种完全兼容 <code>mysql</code> 的数据库，可以自动分片</strong>。另外我们也打算<strong>提供 <code>mongodb</code> 这样天然支持分片的文档数据库用作任务管理</strong>，这个可以根据场景选择的</li>
</ul>
<p><strong>补充</strong>：</p>
<p>思路就 2 点：</p>
<ol>
<li>这块需要量很大才会成为瓶颈，而异步任务一般不会这么大，所以没过度设计</li>
<li>我们也思考了怎么扩展，虽然没做，但考虑周全</li>
</ol>
<p><strong>会不会出现schedule beign_pos和schedule_end_ pos跨不止1张表的情况</strong>？</p>
<p>答：</p>
<p>不会的，我们分表是当成一个过渡状态，预期就是短时间内能完成，所以 <strong>最多跨一张表分</strong></p>
<hr>
<h3 id="同步与异步问题"><a class="headerlink" href="#同步与异步问题"></a>同步与异步问题</h3>
<hr>
<ul>
<li><strong>同步</strong> 就是：
<ul>
<li>发起请求，服务端执行完任务回包</li>
</ul>
</li>
<li><strong>异步</strong> 就是：
<ol>
<li>发起者是用接口发起任务</li>
<li>任务异步处理</li>
<li>发起者轮询结果</li>
</ol>
</li>
</ul>
<h4 id="举例说明"><a class="headerlink" href="#举例说明"></a>举例说明</h4>
<ul>
<li>一个接口假设要执行 100 分钟</li>
<li>同步 就是：
<ol>
<li>发起请求，服务端执行完任务回包，这里干等了100分钟</li>
</ol>
</li>
<li>异步 就是：
<ol>
<li>发起者使用接口发起任务，这时候收到一个任务凭证，一般就是任务<code>id</code>，也就是服务端告诉你，兄弟，你的任务生成了，拿好这个<code>id</code>，剩下的交给我</li>
<li>任务在服务端异步处理，处理了100分钟</li>
<li>发起者每隔1分钟（或者5分钟，或者10分钟，看你喜欢或业务需要），来调用另一个接口（参数肯定是任务<code>id</code>），看任务完成没有</li>
</ol>
</li>
<li>异步 就是把原来 100 分钟的接口分为了 2 个接口
<ol>
<li>第一个接口，还是一个同步调用，但是只记录下来要做某件事，还没真正去做</li>
<li>查询任务结果的接口，参数就是第一个接口拿到的任务 <code>id</code></li>
</ol>
</li>
<li>当然，具体的任务自然是服务端后台默默去做了，跟接口无关了</li>
</ul>
<h4 id="适合异步的场景"><a class="headerlink" href="#适合异步的场景"></a>适合异步的场景</h4>
<ul>
<li>本框架就是 <strong>解决异步场景的</strong>，他本身就是为处理异步任务这个特定领域而生</li>
<li>本框架的核心责任就是 <strong>调度</strong>，而不是具体去做底层的事情，底层的事情可以理解为封装好的，或者第三方的能力，对框架可以认为是透明的</li>
</ul>
<hr>
<h3 id="任务治理"><a class="headerlink" href="#任务治理"></a>任务治理</h3>
<hr>
<p><strong>任务治理</strong> 就是处理我们框架里一些特殊流程，以确保其满足业务需求和合规要求，其实就是 <strong>针对框架的一些特殊情况单独处理，而不是放在正常流程里面去做</strong></p>
<h4 id="主要用途"><a class="headerlink" href="#主要用途"></a>主要用途</h4>
<ul>
<li><strong>创建新表</strong>（<strong>滚动分表</strong>）
<ul>
<li>定期扫描所有任务类型 对应的 <code>end_pos</code> 表，查看 <strong>是否需要分表</strong>（表记录数量是否超出阈值，如果是，创建一个新表，<code>end_pos++</code>）</li>
</ul>
</li>
<li><strong>消费表下标移动</strong>
<ul>
<li>定期扫描所有任务类型 对应的 <code>begin_pos</code> 表，查询 <strong>这个表所有任务是否都已经冷却</strong>（只包含成功和失败状态的任务），如果是，对应的 <code>begin_pos++</code></li>
</ul>
</li>
<li><strong>任务超时检查</strong>
<ul>
<li>定期扫描所有任务类型对应的 <code>begin_pos</code> 表，然后 <strong>将处于长时间执行的任务（超出最大执行时间）拉回正轨</strong>（任务状态置为 <code>pending</code>，待调度/待执行）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="代码说明"><a class="headerlink" href="#代码说明"></a>代码说明</h2>
<hr>
<h3 id="Flowsvr"><a class="headerlink" href="#Flowsvr"></a>Flowsvr</h3>
<hr>
<p><code>Flowsvr</code> 负责和存储（<code>MySQL</code>）打交道，以及提供任务管理接口。整个 <code>Flowsvr</code> 主要就是再实现对三个信息的增删改查，即：任务信息 <code>AsyncFlowTask</code>，任务配置信息 <code>Schedule_Config</code>，任务位置信息表信息 <code>Schedule_Pos</code></p>
<ol>
<li><code>constant</code>：定义了一些项目用到的常量</li>
<li><code>controller</code>: 对外提供的 <code>http</code> 接口定义。包括对（任务信息和任务配置信息）增删改查 <code>http</code> 接口</li>
<li><code>dao</code>：对数据库操作的接口定义。分别对应：任务信息表，任务配置信息表，任务位置信息表</li>
<li><code>data</code>：定义了运行过程中用到的数据结构</li>
<li><code>enum</code>：各种用到的枚举值</li>
<li><code>service</code>：服务层；相关接口操作的具体实现逻辑，对上承接并处理 <code>controller</code> 请求做具体处理，对下调用 <code>dao</code> 层完成数据库相关操作等</li>
<li><code>util</code>：项目中用到的一些工具类或方法定义</li>
<li><code>flowsvrApplication</code>：<code>Flowsvr</code> 服务入口，<code>main</code> 方法入口</li>
<li><code>resource</code>：项目配置文件
<ul>
<li><code>mapper</code>：项目用到的 <code>mybatis</code> 相关 <code>mapper</code> 配置</li>
<li><code>application.yml</code>：记录配置信息，比如：<code>flowsvr</code> 运行的端口，<code>MySQL</code> 的 <code>ip</code>、<code>port</code> 等</li>
</ul>
</li>
<li><code>test</code>：测试生成的文件，忽略</li>
<li><code>pom.xml</code>：<code>flowsver</code> 项目用到的 <code>Maven</code> 依赖</li>
</ol>
<hr>
<h3 id="Worker"><a class="headerlink" href="#Worker"></a>Worker</h3>
<hr>
<p>所有 <code>worker</code> 端相关代码。负责拉取执行任务</p>
<ol>
<li><code>boot</code>：<code>worker</code> 启动入口。一个具体绑定好任务类型的 <code>worker</code> 启动入口</li>
<li><code>Client</code>：对外部调用获取数据的 <code>Client</code>。<code>Demo</code> 里目前只有对 <code>Flowsvr</code> 的调用，用于获取任务和任务配置信息</li>
<li><code>constant</code>：项目中用到的常量</li>
<li><code>core</code>：这部分是 <code>worker</code> 核心，定义 <code>worker</code> 的执行流程。将流程拆分为了多个阶段，并且定义好了每个阶段应该执行什么方法。目前阶段包括（初始阶段 <code>onBoot</code>、获取任务阶段 <code>onObtain</code>、执行阶段<code>onExecute</code>、执行失败 <code>onError</code>、执行正常结束 <code>onFinish</code>、执行停止 <code>onStop</code> 目前没用）
<ul>
<li>注意这些是 <code>worker</code> 的执行流程阶段，不是单个任务的阶段</li>
</ul>
</li>
<li><code>data</code>：定义了运行过程中用到的数据结构</li>
<li><code>enum</code>：各种用到的枚举值</li>
<li><code>http</code>：定义了对 <code>Flowsvr</code> 的 <code>http</code> 接口调用逻辑。上面 <code>Client</code> 实现里会用到这里，等于 <code>Client</code> 是对此进一步封装</li>
<li><code>lock</code>：分布式锁定义</li>
<li><code>task</code>：具体任务类型的运行逻辑。目前只定义了一个 <code>Lark</code> 类型的任务。 任务分成 <code>handleProcess</code> → <code>printMsg2</code> 两个阶段。 并且使用方法名直接作为了阶段 <code>stage</code> 的名字，所以在执行过程中会用到反射，目的就是对比 <code>stage</code> 和 方法名，找到对应任务阶段的执行方法</li>
<li><code>test</code>：做项目测试用到的文件。例如：可以使用里面的测试方法 <code>testCeateTask</code> 来创建测试任务。</li>
<li><code>WorkerApplication</code>：<code>worker</code> 工程启动入口，<code>main</code> 方法入口</li>
<li><code>resource</code>：项目配置文件
<ul>
<li><code>application</code>：记录配置信息，比如： <code>flowsvr</code> 运行的端口，<code>MySQL</code> 的 <code>ip</code>、<code>port</code></li>
</ul>
</li>
<li><code>test</code>：这是第二个 <code>test</code> 包，这个可以忽略</li>
<li><code>pom.xml</code>：<code>worker</code> 工程里用到的 <code>Maven</code> 依赖</li>
</ol>
<hr>
<h3 id="创建Task流程"><a class="headerlink" href="#创建Task流程"></a>创建Task流程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ReturnStatus&lt;T&gt; <span class="title function_">createTask</span><span class="params">(AsyncTaskRequest asyncTaskRequest)</span> &#123;</span><br><span class="line">    <span class="type">AsyncFlowClientData</span> <span class="variable">asyncFlowClientData</span> <span class="operator">=</span> getAsyncFlowClientData(asyncTaskRequest);</span><br><span class="line">    <span class="type">TSchedulePos</span> <span class="variable">taskPos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取表号 getTaskPos</span></span><br><span class="line">        taskPos = tSchedulePosDao.getTaskPos(asyncFlowClientData.getTask_type());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorStatusReturn.ERR_GET_TASK_POS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (taskPos == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;db.TaskPosNsp.GetTaskPos failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 根据表号Pos和创建参数中的任务类型 task Type，生成表名tableName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getTableName(taskPos.getScheduleEndPos(), asyncFlowClientData.getTask_type());</span><br><span class="line">    ScheduleConfig taskTypeCfg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 获取任务类型配置taskTypeCfg</span></span><br><span class="line">        taskTypeCfg = scheduleConfigDao.getTaskTypeCfg(asyncFlowClientData.getTask_type());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Visit t_task_type_cfg error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ErrorStatusReturn.ERR_GET_TASK_SET_POS_FROM_DB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AsyncFlowTask</span> <span class="variable">asyncFlowTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncFlowTask</span>();</span><br><span class="line">    <span class="comment">// 4. 生成taskId</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">taskId</span> <span class="operator">=</span> getTaskId(asyncFlowClientData.getTask_type(), taskPos.getScheduleEndPos(), tableName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 构建完整写入数据库的任务信息：fillTaskModel</span></span><br><span class="line">        fillTaskModel(asyncFlowClientData, asyncFlowTask, taskId, taskTypeCfg);</span><br><span class="line">        <span class="comment">// 6. 将任务存入数据库：asyncFlowTaskDao.create(tableName, asyncFlowTask)</span></span><br><span class="line">        asyncFlowTaskDao.create(tableName, asyncFlowTask);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        logger.error(<span class="string">&quot;create task error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ErrorStatusReturn.ERR_CREATE_TASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 最后将 taskid 作为返回值返回给调用方</span></span><br><span class="line">    <span class="type">TaskResult</span> <span class="variable">taskResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskResult</span>(taskId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnStatus</span>(taskResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="调度流程"><a class="headerlink" href="#调度流程"></a>调度流程</h3>
<hr>
<h4 id="主线流程"><a class="headerlink" href="#主线流程"></a>主线流程</h4>
<ol>
<li>
<p>初始化配置：<code>Main</code> 方法首先 <code>new</code> 生成了一个 <code>AppLaunch</code> 对象，<code>AppLaunch</code> 类的构造函数中，会进行了初始化配置等工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WorkerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Launch</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppLaunch</span>();</span><br><span class="line">        <span class="comment">// 启动worker</span></span><br><span class="line">        l.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AppLaunch</span><span class="params">(<span class="type">int</span> scheduleLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个线程安全的哈希表，用于存储任务配置信息</span></span><br><span class="line">    scheduleCfgDic = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个单线程的定时任务线程池，用于定期执行某些任务</span></span><br><span class="line">    loadPool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个任务处理类的实例（实现类）</span></span><br><span class="line">    taskFlower = <span class="keyword">new</span> <span class="title class_">TaskFlowerImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置任务类型为 Lark，并获取其包名</span></span><br><span class="line">    taskType = Lark.class;</span><br><span class="line">    packageName = taskType.getPackage().getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置任务拉取的限制数量（从参数传入）</span></span><br><span class="line">    <span class="built_in">this</span>.scheduleLimit = scheduleLimit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化观察者管理器，用于管理观察者模式中的观察者</span></span><br><span class="line">    observerManager = <span class="keyword">new</span> <span class="title class_">ObserverManager</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向观察者管理器注册一个时间观察者（TimeObserver）</span></span><br><span class="line">    observerManager.registerEventObserver(<span class="keyword">new</span> <span class="title class_">TimeObserver</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化任务偏移量为 0</span></span><br><span class="line">    offset = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用初始化方法，加载任务配置信息</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开始调度：执行 <code>l.start()</code> 方法开始调度流程</p>
<ul>
<li>获取 <code>scheduleConfig</code>：里面定义了 <code>schedule_limit</code> 和 <code>schedule_interval</code> 等信息，控制每次拉去的频率和拉取的数量等</li>
<li>进入 <code>for()</code> 死循环：<code>worker</code> 会在循环中不断拉取任务然后执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取任务类型对应的任务配置信息</span></span><br><span class="line">    <span class="type">ScheduleConfig</span> <span class="variable">scheduleConfig</span> <span class="operator">=</span> scheduleCfgDic.get(taskType.getSimpleName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定任务执行的时间间隔（默认时间或用户配置时间）</span></span><br><span class="line">    intervalTime = scheduleConfig.getSchedule_interval() == <span class="number">0</span> </span><br><span class="line">        ? TaskConstant.DEFAULT_TIME_INTERVAL * <span class="number">1000L</span> </span><br><span class="line">        : scheduleConfig.getSchedule_interval() * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程池，设置核心线程数、最大线程数、以及队列容量</span></span><br><span class="line">    <span class="built_in">this</span>.threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        concurrentRunTimes, </span><br><span class="line">        MaxConcurrentRunTimes, </span><br><span class="line">        intervalTime + <span class="number">1</span>, </span><br><span class="line">        TimeUnit.SECONDS, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(UserConfig.QUEUE_SIZE)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环用于持续拉取和执行任务</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 检查队列是否有足够空间，确保不超出限制</span></span><br><span class="line">        <span class="keyword">if</span> (UserConfig.QUEUE_SIZE - threadPoolExecutor.getQueue().size() &gt;= scheduleLimit) &#123;</span><br><span class="line">            <span class="comment">// 如果满足条件，执行任务拉取和分发</span></span><br><span class="line">            execute(taskType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待指定的时间间隔后再执行下一轮任务拉取</span></span><br><span class="line">            Thread.sleep(intervalTime + (<span class="type">int</span>)(Math.random() * <span class="number">500</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获中断异常，打印堆栈信息</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单次调度逻辑：<code>execute(taskType);</code></p>
<ul>
<li>第一步：<code>scheduleTask</code> 获取一批任务</li>
<li>第二步：把任务一个个丢入线程池。线程池里的线程会负责运行任务，运行逻辑就是 <code>executeTask</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Class&lt;?&gt; taskType)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 scheduleTask 方法来拉取任务列表</span></span><br><span class="line">    List&lt;AsyncTaskBase&gt; asyncTaskBaseList = scheduleTask(taskType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果拉取到的任务列表为空，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (asyncTaskBaseList == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务列表的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> asyncTaskBaseList.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历任务列表并将每个任务提交给线程池执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i; <span class="comment">// 将索引 i 存入 finalI 以便在 lambda 表达式中使用</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; executeTask(asyncTaskBaseList, finalI)); <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取一批待执行任务逻辑解析：<code>scheduleTask</code></p>
<ul>
<li><code>observerManager.wakeupObserver(ObserverType.onBoot)</code>：执行 <code>worker</code>调度流程的第一个阶段<code>onBoot</code></li>
<li>后面就是 <code>getAsyncTaskBases</code> 中从 <code>Flowsvr</code> 获取到具体的一批任务 <code>asyncTaskBaseList</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拉取任务的方法</span></span><br><span class="line"><span class="keyword">private</span> List&lt;AsyncTaskBase&gt; <span class="title function_">scheduleTask</span><span class="params">(Class&lt;?&gt; taskType)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在任务执行前做一些准备工作（这里简单地打印一句话，可以根据需求扩展）</span></span><br><span class="line">        observerManager.wakeupObserver(ObserverType.onBoot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并打印堆栈信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getAsyncTaskBases 方法，拉取指定任务类型的任务列表</span></span><br><span class="line">    List&lt;AsyncTaskBase&gt; asyncTaskBaseList = getAsyncTaskBases(observerManager, taskType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果任务列表为空，则返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (asyncTaskBaseList == <span class="literal">null</span> || asyncTaskBaseList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回拉取到的任务列表</span></span><br><span class="line">    <span class="keyword">return</span> asyncTaskBaseList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单个任务的运行逻辑：<code>executeTask(List&lt;AsyncTaskBase&gt; asyncTaskBaseList, int i)</code></p>
<ul>
<li>根据 <code>Task_type</code> 和 <code>task_stage</code> 等找到对应的执行类和阶段方法，并执行</li>
<li><code>observerManager.wakeupObserver(ObserverType.onExecute,v);</code> 这些属于旁路逻辑，打一些日志记录当前执行到 <code>worker</code> 的哪一个阶段了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(List&lt;AsyncTaskBase&gt; asyncTaskBaseList, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前任务</span></span><br><span class="line">    <span class="type">AsyncTaskBase</span> <span class="variable">v</span> <span class="operator">=</span> asyncTaskBaseList.get(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前的准备工作，这里简单地打印了一句，可根据需求扩展</span></span><br><span class="line">        observerManager.wakeupObserver(ObserverType.onExecute, v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并打印堆栈信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储任务的阶段状态</span></span><br><span class="line">    <span class="type">AsyncTaskSetStage</span> <span class="variable">asyncTaskSetStage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用于存储任务类型的类</span></span><br><span class="line">    Class&lt;?&gt; aClass = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 利用反射获取任务的类类型</span></span><br><span class="line">        aClass = getaClass(v.getTask_type());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取对应方法，这里通过 TaskBuilder 获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> TaskBuilder.getMethod(aClass, v.getTask_stage(), v.getTask_context().getParams(), v.getTask_context().getClazz());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印执行的方法名（便于调试）</span></span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行任务方法并获取返回值</span></span><br><span class="line">        <span class="type">TaskRet</span> <span class="variable">returnVal</span> <span class="operator">=</span> (TaskRet) method.invoke(aClass.newInstance(), v.getTask_context().getParams());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果返回值不为空，获取任务阶段状态和执行结果</span></span><br><span class="line">        <span class="keyword">if</span> (returnVal != <span class="literal">null</span>) &#123;</span><br><span class="line">            asyncTaskSetStage = returnVal.getAsyncTaskSetStage();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> returnVal.getResult();</span><br><span class="line">            System.out.println(<span class="string">&quot;执行结果为：&quot;</span> + result); <span class="comment">// 打印执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 任务执行失败时处理异常：</span></span><br><span class="line">            <span class="comment">// 更改任务状态为PENDING，增加重试次数，超过最大重试次数则设置为FAIL</span></span><br><span class="line">            observerManager.wakeupObserver(ObserverType.onError, v, scheduleCfgDic.get(v.getTask_type()), asyncTaskBaseList, aClass, e);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 返回，避免执行后续代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException ex) &#123;</span><br><span class="line">            ex.printStackTrace(); <span class="comment">// 捕获并打印异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行成功后做一些后续操作，方便后续扩展</span></span><br><span class="line">        observerManager.wakeupObserver(ObserverType.onFinish, v, asyncTaskSetStage, aClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 捕获并打印异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250114162601939.png" alt="6种状态流程" loading="lazy"></p>
</li>
</ol>
<h4 id="使用反射的原因"><a class="headerlink" href="#使用反射的原因"></a>使用反射的原因</h4>
<p>答：使用了 <code>Lark</code> 这个具体任务类， 类名 <code>Lark</code> 作为任务类型名，而使用了 <code>Lark</code> 类中的方法名（如：“<code>handleProcess</code>”，“<code>printMsg2</code>”）作为任务的阶段名 <code>stage</code></p>
<ul>
<li>例如：获取到的任务
<ul>
<li>类型名：<code>v.getTask_type() = &quot;Lark&quot;</code></li>
<li>阶段名：<code>v.getTask_stage() = &quot;handleProcess&quot;</code></li>
<li>上面那都是字符串，只有通过反射才能获取到 <code>Lark</code> 类里面的对应同名的 <code>handleProcess</code> 方法进行执<br>
行</li>
</ul>
</li>
</ul>
<h4 id="样例任务Lark"><a class="headerlink" href="#样例任务Lark"></a>样例任务Lark</h4>
<ul>
<li>定义了任务的多个阶段，例如：<code>handleProcess</code>，<code>printMsg2</code> 等；每个阶段就是简单打个日志，真实的可能是各种任务具体运行逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lark</span> <span class="keyword">implements</span> <span class="title class_">AsyncExecutable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">printMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The printed msg is: &quot;</span> + msg);</span><br><span class="line">        <span class="type">AsyncTaskSetStage</span> <span class="variable">asyncTaskSetStage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;printMsg2&quot;</span>, String.class);</span><br><span class="line">            asyncTaskSetStage = setStage(<span class="built_in">this</span>.getClass(), method.getName(), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;我要开花！&quot;</span>&#125;, method.getParameterTypes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskRet</span>(<span class="string">&quot;SUCCESS&quot;</span>, asyncTaskSetStage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">printMsg2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二阶段开启中文打印: &quot;</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskRet</span>(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">handleProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> printMsg(<span class="string">&quot;I did it!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">handleFinish</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务后置处理，可以自定义做点任务执行成功后的后置处理，例如回收资源等&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskRet</span>(<span class="string">&quot;全部任务阶段执行完毕~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">handleError</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务最终执行失败干点事，可以自定义一些操作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskRet</span>(<span class="string">&quot;任务实在是执行不了了，还是人工检查一下吧~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TaskRet <span class="title function_">contextLoad</span><span class="params">(String context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上下文加载，用户可以根据自己定义的协议格式对上下文进行解析&quot;</span>);</span><br><span class="line">        <span class="type">NftTaskContext</span> <span class="variable">nftTaskContext</span> <span class="operator">=</span> JSON.parseObject(context, NftTaskContext.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TaskRet</span>&lt;&gt;(nftTaskContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="常见问题"><a class="headerlink" href="#常见问题"></a>常见问题</h2>
<hr>
<h3 id="Async-和-消息队列-有什么区别？"><a class="headerlink" href="#Async-和-消息队列-有什么区别？"></a>Async 和 消息队列 有什么区别？</h3>
<p>答：</p>
<p>定位不一样，<code>Async</code> 是一个框架，消息队列是个组件。消息队列确实在异步场景用的比较多，本质上就是做消息的流转。但是 <code>Async</code> 还支持阶段性任务，也就是可以更新任务，以及 <code>Async</code> 还可以做完善的任务管理，这两点是消息队列比较缺失的</p>
<hr>
<h3 id="怎么做更新任务和任务管理的呢？"><a class="headerlink" href="#怎么做更新任务和任务管理的呢？"></a>怎么做更新任务和任务管理的呢？</h3>
<p>答：</p>
<ul>
<li>更新任务就是做完一个阶段，可以通过服务端的更新任务 <code>web</code> 接口来将上下文保存到 <code>DB</code> 中</li>
<li>管理任务的话，其实就是可以通过 <code>web</code> 接口对外的能力，去访问 <code>DB</code> 中的任务，比如：我们可以通过接口 用任务 <code>ID</code> 查询对应任务、查询任务列表等等</li>
<li>其本质就是我们服务端的 <code>web</code> 模块提供外界访问的能力，并根据对应的接口去访问 <code>DB</code> 数据源</li>
</ul>
<hr>
<h3 id="为什么不用业界已有的异步任务框架？"><a class="headerlink" href="#为什么不用业界已有的异步任务框架？"></a>为什么不用业界已有的异步任务框架？</h3>
<p>答：</p>
<ul>
<li>业界有两个比较出名的任务框架，<code>celery</code> 和 <code>machinery</code>，<code>celery</code> 是 <code>python</code> 编写的，<code>machinery</code> 是 <code>go</code> 模仿 <code>celery</code> 实现的</li>
<li>他们可能都更倾向于 消息流转、而不是 任务管理。这里我们需要的是一个能 <strong>快速实现异步任务的轻量级框架，支持中间上下文更改</strong>，这是 <code>celery</code> 和 <code>machinery</code> 的定位是不一样的。同时呢，像 <code>machinery</code> 功能很齐全，<strong>支持 延迟任务机制、任务定时机制、任务回调机制、任务流模式 等一系列机制</strong>，很多我们并用不上，我们想做的就是一个支持异步任务管理、调度的轻量级框架</li>
</ul>
<p><strong>详细链接</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903689103081480">高性能异步框架Celery入坑指南在一个应用服务中，对于时效性要求没那么高的业务场景，我们没必要等到所有任务执行完才返回 - 掘金</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037680234">go-machinery入门教程（异步任务队列） - 个人文章 - SegmentFault 思否</a>、[20 技术选型：分布式定时调度框架的功能和未来](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20">https://learn.lianglianglee.com/专栏/中间件核心技术与实战/20</a> 技术选型：<a target="_blank" rel="noopener" href="http://xn--kbr7nj3cm0me8c81a7un24bktc4qx1am3cjy9gpw4ajt8a.md">分布式定时调度框架的功能和未来.md</a>)</p>
<hr>
<h3 id="相比于xxx-job有什么优势或不同？"><a class="headerlink" href="#相比于xxx-job有什么优势或不同？"></a>相比于xxx-job有什么优势或不同？</h3>
<p>答：</p>
<p>相比于 <code>xxx-job</code>，我们更轻量，也更专注于异步任务场景，这是主要的优势，其次一些灵活性功能也是我们的优势，比如：秒级优先级、两种重试策略</p>
<p><strong>补充</strong>：</p>
<ul>
<li>主要还是出于我们这个更简单，更轻量。轻量可以说他架构复杂，还可以说他功能大而全，不光支持异步任务，很多逻辑还是为了支持定时任务，甚至定时任务是他主要的，这并不是我们需要的，我们需要的是特定的异步任务框架</li>
<li>还有就是功能上，他肯定不支持多种重试策略，以及优先级数字化这种方式，这个就可以咬死我们就是需要这些，这两个点很小，一般也不需要，但是做区分的时候可以讲讲，说白了，基本我们能做的，<code>xxx-job</code> 都能做，这时候只能从其它角度 “抹黑” 他</li>
</ul>
<hr>
<h3 id="框架是怎么接入呢？"><a class="headerlink" href="#框架是怎么接入呢？"></a>框架是怎么接入呢？</h3>
<p>答：</p>
<ul>
<li>首先，用户需要自己部署框架依赖的中间件，我们框架依赖 <code>MySQL</code> 和 <code>Redis</code>，用户自己要先部署好，同时我们框架任务 依赖 <code>MySQL</code> 中的 位置信息表 和 任务配置表，任务信息表，这个也得先创建好</li>
<li>接着，就可以部署服务端（启动<code>fowsvr</code>程序），我们可以选择使用脚本调用 <code>flowsvr</code> 对应的创建任务的接口，然后 <code>fowsvr</code> 会和我们部署的 <code>MySQL</code> 交互，将任务存储到对应的任务信息表（任务信息表名字和这个任务类型强相关）
<ul>
<li><code>flowsvr</code> 是提供 <code>web</code> 服务的，也就是我们可以通过 <code>HTTP</code> 协议来访问对应的路由，访问 <code>HTTP</code> 接口的方式多种多样最简单的话就是使用测试接口的工具，例如：<code>postman</code>，<code>apipost</code></li>
</ul>
</li>
<li>接下来，我们需要想办法消费任务
<ol>
<li>第一步，将任务执行的逻辑，写到消费端（<code>worker</code>）里面，逻辑写进 <code>worker</code> 之后，等拉到对应类型的任务，也就可以执行了，具体一点来说，<code>worker</code> 通过 <code>sdk</code> 的方式提供了三个接口方法，任务需要实现这三个接口方法，将业务逻辑写进三个接口方法，才可以将这类任务注册进框架
<ul>
<li>这三个接口方法分别是：
<ul>
<li><code>ContextLoad</code>：<strong>框架的使用者也就是用户，得定义如何解析上下文</strong>（比如：如何将上下文字符串解析到程序中使用）</li>
<li><code>HandleProcess</code>：<strong>用户得自己定义一种任务类型的真正处理逻辑</strong></li>
<li><code>HandleFinish</code>：<strong>用于处理任务完成后的逻辑，也就是在任务成功或失败后，需要执行的一些后续操作</strong>。例如：可以在这个方法中发送任务完成的通知、记录任务的执行日志等等。具体的逻辑根据业务需求而定</li>
</ul>
</li>
</ul>
</li>
<li>第二步，就是部署 <code>worker</code>，消费任务
<ul>
<li>说是部署，其实就是启动这个 <code>worker</code> 程序，然后 <code>worker</code> 按照用户定义的逻辑去执</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="框架是怎么部署呢？"><a class="headerlink" href="#框架是怎么部署呢？"></a>框架是怎么部署呢？</h3>
<p>答：</p>
<ul>
<li>思路1：
<ul>
<li>我们是提供框架，业务方可以根据自己的需要部署：一般我们推荐服务端和服务端都是多机部署， <code>MySQL</code> 或 <code>Redis</code> 使用 主从模式 即可
<ul>
<li><code>flowsvr</code> 和 <code>worker</code> 多机部署，其实就是启动多个 <code>flowsvr</code> 和 <code>worker</code> 程序，他们都是无状态的（<code>worker</code> 之间 或 <code>flowsvr</code> 之间 无交互），由于 <code>flowsvr</code> 是提供 <code>web</code> 服务，所以我们访问到对应的 <code>flowsvr</code> 可以先做负载均衡（选择一个 <code>flowsvr</code> 节点）</li>
</ul>
</li>
</ul>
</li>
<li>思路2：
<ul>
<li>如果有可以挂靠的场景，可以再说详细点，这种模式就是要咬死，不要自相矛盾
<ul>
<li>我们是提供框架，业务方可以根据自己的需要部署，我们目前的场景使用的部署模式是提供两台 <code>16c</code> 、<code>32G</code> 的主机，在腾讯云上 <code>k8s</code> 部署，<code>flowsvr</code> 和 <code>worker</code> 都部署在集群中，<code>flowsvr</code> 有 2 个 <code>pod</code>，<code>worker</code> 是 3 个 <code>pod</code>，<code>MySQL</code>、<code>Redis</code>使用主从模式，<code>flowsvr</code> 通过 <code>clb</code> （云负载均衡器）的能力对外提供接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="worker是托管在框架这边的服务器吗？还是在对于异步任务的模块？如果worker托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么回写到业务方的数据库？"><a class="headerlink" href="#worker是托管在框架这边的服务器吗？还是在对于异步任务的模块？如果worker托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么回写到业务方的数据库？"></a>worker是托管在框架这边的服务器吗？还是在对于异步任务的模块？如果worker托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么回写到业务方的数据库？</h3>
<p>答：</p>
<p>我们这边是提供框架。如果一个业务团队想接入，需要自己部署 <code>flowsvr</code>、<code>worker</code>。如果业务下有几个子业务，我们是推荐业务提供共用的 <code>flowsvr</code>，子业务都调用这个 <code>fowsvr</code>，<code>worker</code> 的话可以子业务自己部署</p>
<ul>
<li>其实本质上，一个 <code>worker</code> 可以调度多种任务类型，只要有对应任务类型的接入</li>
<li>但一个 <code>worker</code> 调度一种任务类型也是可以的，让架构更加鲜明</li>
</ul>
<hr>
<h3 id="为什么存储用MySQL不用Redis？"><a class="headerlink" href="#为什么存储用MySQL不用Redis？"></a>为什么存储用MySQL不用Redis？</h3>
<p>答：</p>
<p>不用 <code>Redis</code> 的原因是因为 <code>Redis</code> 的 <strong>可靠性</strong> 不如 <code>MySQL</code>，以及 <code>Redis</code> <strong>不支持关系型查询</strong>，而我们的场景是任务管理场景，涉及的关系型查询还蛮多的，最典型的就是要根据状态拉一批任务来执行</p>
<p><strong>补充</strong>：</p>
<ul>
<li>用 <code>MySQL</code> 我们是有考虑的，首先 <code>MySQL</code> 可以持久化，数据更可靠，其次 <code>MySQL</code> 支持管理化场景，比如：获取任务列表的时候，要根据任务类型和任务状态去获取</li>
<li>虽然 <code>Redis</code> 也能持久化，但是毕竟没 <code>MySQL</code> 那么可靠，其次呢，<code>Redis</code> 也不支持关系型查询</li>
</ul>
<hr>
<h3 id="为什么存储用MySQL不用MongoDB？"><a class="headerlink" href="#为什么存储用MySQL不用MongoDB？"></a>为什么存储用MySQL不用MongoDB？</h3>
<p>答：</p>
<p>其实 <code>MySQL</code> 和 <code>MongoDB</code> 都比较适合我们的场景，我们的存储能力查询是封装过的，后面也打算接入 <code>MongoDB</code> 作为底层存储之一。现在默认用 <code>MySQL</code> 的原因是因为大多数场景，上下文都是简洁的，而且 <code>MySQL</code> 是很多业务团队的基础设施，这样不用引入新的存储组件，减少运维和容灾成本</p>
<p><strong>补充</strong>：</p>
<ul>
<li>众多选型中，<code>MongoDB</code> 无疑是最有竞争力的，<code>MongoDB</code> 可以说是最接近关系型的非关系型数据库，性能好、可扩展、支持文档数据库</li>
<li>但我们的场景，其实几乎也不用事务和 <code>Join</code>（<code>MySQL</code>中的联表查询），<code>Mongo</code> 的局限在于不支持事务和不支持 <code>Join</code>，所以说实话，<code>Mongo</code> 还挺适合我们的场景</li>
<li>我们底层后续也是要支持 <code>Mongo</code>，提供更多能力</li>
<li>回答的时候要偏向实际出发，毕竟很多团队都不用 <code>Mongo</code>，并且也不想引入新的存储组件</li>
</ul>
<hr>
<h3 id="上下文怎么存储的，存不下怎么办？"><a class="headerlink" href="#上下文怎么存储的，存不下怎么办？"></a>上下文怎么存储的，存不下怎么办？</h3>
<p>答：</p>
<ul>
<li>我们是用一个字段 <code>context</code> 表示，最大 <code>8192</code> 个字节。首先任务大多数情况下，上下文都是简洁的，<strong>关键信息才用上下文存储</strong>，8192 是够用的。如果遇到真存不下的情况，我们也推荐这里用 <code>url</code> 传递，内容太大走字节无论是存储还是传递都不太友好</li>
<li>另外，这里后面也会支持 <code>MongoDB</code> 做底层引擎，<strong>上下文过大就可以看作是文档了，这时候用 <code>MongoDB</code> 会比较合适</strong></li>
</ul>
<hr>
<h3 id="讲讲任务创建的流程？"><a class="headerlink" href="#讲讲任务创建的流程？"></a>讲讲任务创建的流程？</h3>
<p>答：</p>
<ul>
<li>首先，请求通过 <code>http</code> 调用，到达 <code>flowsvr</code>。接着，<code>flowsvr</code> 通过路由找到对应的执行函数，解析参数并检查是否合法</li>
<li>然后开始执行创建任务的逻辑，先查询目前插入的表号，然后将数据插入数据库，最后构造返回包给调用方。这就是完整的创建任务的流程</li>
</ul>
<hr>
<h3 id="讲讲拉取任务接口的流程？"><a class="headerlink" href="#讲讲拉取任务接口的流程？"></a>讲讲拉取任务接口的流程？</h3>
<p>答：</p>
<p><code>worker</code> 发起占据任务请求，<code>flowsvr</code> 接收到之后，会根据路由找到占据任务函数并进行检查参数，接着从数据库拉取一批任务，将这批任务设置为执行中，填充返回包并返回给 <code>worker</code></p>
<p><strong>补充</strong>：</p>
<ul>
<li>重点在于服务之间的交互流程、服务内的执行逻辑</li>
<li>设置执行中，其实这一步是 <code>flowsvr</code> 在返回 <code>worker</code> 之前会做的，也就是将 <code>DB</code> 任务状态修改为执行中</li>
</ul>
<hr>
<h3 id="项目里面-worker-是手动还是自动发请求拉任务？"><a class="headerlink" href="#项目里面-worker-是手动还是自动发请求拉任务？"></a>项目里面 worker 是手动还是自动发请求拉任务？</h3>
<p>答：</p>
<p>拉不到任务的情况下是 <strong>自动按一定时间间隔去拉取</strong>，<strong>时间间隔</strong> 作为 <strong>任务配置表的参数</strong>，用户可以灵活配置。能拉到的情况是拉一批消费一批，消费完了再去拉下一批</p>
<hr>
<h3 id="你们的MySQL中查询是查一大批还是查一个？"><a class="headerlink" href="#你们的MySQL中查询是查一大批还是查一个？"></a>你们的MySQL中查询是查一大批还是查一个？</h3>
<p>答：</p>
<p>拉取任务时，我们是一次获取一批任务，这样是为了减少对 <code>MySQL</code> 的请求，节约性能，具体拉取多少我们有<strong>任务配置表</strong>可以配置</p>
<hr>
<h3 id="任务拉取按什么顺序？"><a class="headerlink" href="#任务拉取按什么顺序？"></a>任务拉取按什么顺序？</h3>
<p>答：</p>
<ul>
<li>我们考虑过用 创建时间 或者 更新时间 来排序，但都存在弊端</li>
<li>用 创建时间 排序，如果是多阶段任务，一个阶段完成之后，回到 <code>DB</code> 中，这时候创建时间还是最小的那批，下次调度还是他。这样就不无法让出调度给更饥饿的任务</li>
<li>如果用更新时间排序，如果我们还需要按照 <code>priority</code> 排序的话，那就需要建立一个联合索引</li>
<li>后面我就想着优化一下，将 <code>priority</code> 和 修改时间 整合成一个字段 <code>order_time</code>，抽象出一个专门的排序字段，用来排序，并且将 <code>priority</code> 秒化，比如：<code>priority</code> 为 10 是代表优先 10 秒</li>
<li>在任务创建时<code>order_time</code> 等于 <strong>当前时间 - priority</strong>。在 任务更新时候 等于 <strong>当前时间-priority</strong>（始终保持优先），但如果是失败之后，<code>order_time</code> = <strong>当前时间 + 重试间隔</strong>（优先级失效）</li>
</ul>
<h3 id="如果数据库只有一个任务，尽管加上了重试间隔，失败重试间隔到达之前也能被拉取到吗？"><a class="headerlink" href="#如果数据库只有一个任务，尽管加上了重试间隔，失败重试间隔到达之前也能被拉取到吗？"></a>如果数据库只有一个任务，尽管加上了重试间隔，失败重试间隔到达之前也能被拉取到吗？</h3>
<p>答：</p>
<p>不会，我们这里做了 <strong>强语义限制</strong>，从数据库里面取出一批，会按照重试间隔筛选，<strong>如果没到重试间隔，也不会运送给 <code>worker</code></strong></p>
<hr>
<h3 id="优先级是怎么设计的？"><a class="headerlink" href="#优先级是怎么设计的？"></a>优先级是怎么设计的？</h3>
<p>答：</p>
<ul>
<li>优先级通常实现都是提供几个数字，表示优先级的级别，排序时就先按优先级排序，再按排序字段排序</li>
<li>但这种方案在我们的架构中会引入 2 个问题，一个是需要<strong>将 <code>priority</code> 加入联合索引，影响性能</strong>，并且大多时候 <code>priority</code> 都是一样的，这个开销有点亏，而且 <strong><code>priority</code> 不够灵活</strong>，比如：优先度高的任务，即使失败之后，马上又是最先被调度到的，占据资源还容易堵死普通任务</li>
<li>所以这里我们采用的方式，是<strong>将 <code>priority</code> 秒化</strong>，即：<code>priority</code> 不表示级别，而表示优先多少秒，然后将这个数字融入我们的排序字段，这种方案耦合小、成本低、足够灵活适合框架</li>
</ul>
<h4 id="为什么大多时候priority都是一样的呢？"><a class="headerlink" href="#为什么大多时候priority都是一样的呢？"></a>为什么大多时候priority都是一样的呢？</h4>
<ul>
<li>其实算作是业务经验，大部分时候都是普通的任务，偶尔的时候是 <code>VIP</code> 任务，这个时候就需要考虑更高的优先级</li>
</ul>
<hr>
<h4 id="你说的这个优先级，和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少，A比B为什么优先？"><a class="headerlink" href="#你说的这个优先级，和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少，A比B为什么优先？"></a>你说的这个优先级，和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少，A比B为什么优先？</h4>
<p>答：</p>
<ul>
<li>我们的优先级，表示优先多少秒。业务可以自行抽象，比如：一个视频处理团队，他可以定义超级 VIP，优先级 10 小时，也就是说正常情况下，他都是排到队头，但是如果任务已经阻塞了几天，他并不是最先执行的，这时候还是优先照顾已经等很久的任务</li>
<li>也可以定义一个 SSVIP，这种VIP就是优先1年，也就是说基本无视时间，即使队列积压了几天的任务，他也直接最先处理</li>
</ul>
<hr>
<h4 id="你觉得你的优先级设计是绝对优先还是相对优先？"><a class="headerlink" href="#你觉得你的优先级设计是绝对优先还是相对优先？"></a>你觉得你的优先级设计是绝对优先还是相对优先？</h4>
<p>答：</p>
<p>我们的优先级是 <strong>逻辑上相对优先级</strong>，因为绝对优先容易形成阻塞。当然功能上我们是可以实现绝对优先级的，比如：一个业务，其他任务都是优先个几十秒、几分钟。某些特别重要的任务设置优先级100年，这就是绝对优先了</p>
<p><strong>补充</strong>：</p>
<p>为什么绝对优先会形成阻塞呢？</p>
<ul>
<li>比如优先级固定100的（假设是最高优先级），他重试10000次，每次他也都是最前面的</li>
</ul>
<hr>
<h3 id="重试间隔是什么机制？"><a class="headerlink" href="#重试间隔是什么机制？"></a>重试间隔是什么机制？</h3>
<p>答：</p>
<ul>
<li>通常而言，普遍的重试间隔需求无非是 <strong>均匀重试</strong> 和 <strong>渐进式重试</strong></li>
<li>我们的框架默认<strong>使用一个 <code>interval</code> 字段</strong>支持渐进式重试，<code>interval</code> 表示最大的间隔秒。考虑到确实有部分场景，希望均匀重试，但我们这里并不想新增一个标记字段来配合表示，<strong>这里选择了一种巧妙的方式，即：使用负数表示均匀重试时间</strong></li>
<li>其实应该还有更丰富的重试策略，更进一步可能需要列表甚至 <code>Lua</code> 这种解析策略，但我们也调研了业界<code>celery</code> 等竞品，都不会做这么复杂，这里我们提供两种策略已经是很完善了</li>
</ul>
<hr>
<h3 id="服务端怎么知道任务超时了，定时器轮询吗，判断任务是否超时，有无更好办法？"><a class="headerlink" href="#服务端怎么知道任务超时了，定时器轮询吗，判断任务是否超时，有无更好办法？"></a>服务端怎么知道任务超时了，定时器轮询吗，判断任务是否超时，有无更好办法？</h3>
<p>答：</p>
<p>我们使用 <strong>定时器轮询</strong>，这里是 <strong>抽象了一个任务治理模块</strong>，去扫描这些超过最大执行时间的任务，最大执行时间也是业务根据经验设置的，这类任务一般都是由于异常原因，<code>worker</code> 没有上报结果导致，可能是worker挂掉等原因，所以需要任务治理去发现</p>
<p><strong>补充</strong>：</p>
<p>首先这里需要对齐所谓任务超时是什么情况，这里容易有歧义的，我们这里所谓的 <strong>任务超时，是指一个任务被占据之后，长时间处于执行中</strong>，这个长时间的判断标准，是由业务来设置的，比如：如果我们是调用腾讯云图片审核能力，也就是发起一个接口调用，那这个阶段的占据时间，通常不会超过1分钟，1分钟就是最大执行时间，如果是下载一个文件，那时间可能就是5分钟或者更久</p>
<hr>
<h3 id="任务如果执行中失败了怎么办？"><a class="headerlink" href="#任务如果执行中失败了怎么办？"></a>任务如果执行中失败了怎么办？</h3>
<p>答：</p>
<p><strong>框架 支持 重做</strong>，如果任务执行失败了并且没有超过重试次数，就会将状态改成待执行，等待下次被调度执行，如果执行失败并且超过重试次数了，那么就是彻底失败，将状态改成失败</p>
<hr>
<h3 id="Worker-怎么竞争任务？"><a class="headerlink" href="#Worker-怎么竞争任务？"></a>Worker 怎么竞争任务？</h3>
<p>答：</p>
<p>我们是使用 <strong>分布式锁</strong> 的方式，<code>worker</code> 在拉取任务前，会竞争一个分布式锁，拿到了锁才能占据任务，为了提高速度，我们是占据任务成功之后，然后就释放锁，这样并发受到的影响稍微小一些</p>
<hr>
<h3 id="为什么不用-MySQL-自带的锁？"><a class="headerlink" href="#为什么不用-MySQL-自带的锁？"></a>为什么不用 MySQL 自带的锁？</h3>
<p>答：</p>
<ul>
<li>我也考虑过用 <code>MySQL</code> 自带的锁，并且有两个思路
<ul>
<li>第一个就是用拉任务用 <code>for update</code> 语句，但这产生的间隙锁容易对其它 <code>SQL</code> 语句产生影响，并且《高性能MySQL》也是不推荐使用 <code>for update</code> 这种方式的</li>
<li>第二个思路是先拉一次任务，然后将这批任务设置为执行中，并设置自己为 <code>owner</code>，接着再拉一次执行中并且自己为 <code>owner</code> 的任务，但这个方案也有缺点，一个是多次 <code>SQL</code> 调用，第二个是当 <code>worker</code> 多一点，碰撞就容易很激烈，都去抢那头部200个任务，去竞争设置他们，大量的锁排队</li>
</ul>
</li>
<li>这样测试下来也<strong>发现 <code>MySQL</code> 的 <code>CPU</code>不稳定，冲突激烈时会很高，而且因为冲突的随机性，业务执行性能不稳定，而且很难预知</strong>。所以 <strong>采用分布式锁的方式，避免这种冲突，也减少 <code>SQL</code> 调用次数</strong></li>
</ul>
<hr>
<h3 id="用了分布式锁，一个任务就一定不会被多个worker同时拿到吗？"><a class="headerlink" href="#用了分布式锁，一个任务就一定不会被多个worker同时拿到吗？"></a>用了分布式锁，一个任务就一定不会被多个worker同时拿到吗？</h3>
<p>答：</p>
<ul>
<li>不一定，分布式锁只能说在绝大数情况下，都能让一个任务被一个 <code>worker</code> 拿到，但是如果发生一些异常，比如：<code>worker</code> 陷入 <code>gc</code> ，锁又过期了，这时候就会被其它 <code>worker</code> 拿到，这时候头一个 <code>worker</code> 恢复过来了，他们就同时执行一个任务。</li>
<li>所以这里，<strong>业务自身是需要做幂等的</strong></li>
</ul>
<hr>
<h3 id="竞争分布式锁这种方式，会不会有什么问题？"><a class="headerlink" href="#竞争分布式锁这种方式，会不会有什么问题？"></a>竞争分布式锁这种方式，会不会有什么问题？</h3>
<p>答：</p>
<ul>
<li>
<p>加入 分布式锁 之后，<strong>分布式锁 的 抢锁 操作</strong> 可能成为一个瓶颈，影响 <code>worker</code> 的水平扩容，因为每个<code>worker</code> 在拉取任务之前都需要抢 分布式锁，所有 <code>worker</code> 越多，抢分布式锁的竞争就越激烈，如果锁持有时间是一定的，则一个时间段可以抢到锁的 <code>worker</code> 数量是有限的，这也限制了 <code>worker</code> 的水平扩容。同时，<code>worker</code> 在抢锁失败之后需要等一段时间再次抢锁，使得大量 <code>worker</code>可能只是空转，浪费了资源</p>
</li>
<li>
<p>总体上来说，导致这个问题的本质原因是在设计中将 <strong>同步拉取</strong> 和 <strong>并发执行</strong> 两个操作耦合，如果要进一步解决这个问题还是要思考将两个操作解耦</p>
</li>
<li>
<p>这里我也考虑过优化方案，就是叙述单独服务拉取任务到消息队列的解耦方案</p>
<p><img src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/image-20250115165107666.png" alt="优化方案" loading="lazy"></p>
</li>
</ul>
<h4 id="为什么用MySQL锁的方案，会让CPU不稳定？"><a class="headerlink" href="#为什么用MySQL锁的方案，会让CPU不稳定？"></a>为什么用MySQL锁的方案，会让CPU不稳定？</h4>
<p>答：在 <code>MySQL</code> 中，<strong>死锁检测机制</strong> 是默认开启的，当一个线程新加入到某个资源的阻塞队列时，会检测它的加入是否与其它正在发生阻塞的线程存在资源的相互依赖，从而导致死锁的发生。如果这是一个高并发的资源，阻塞队列里有大量排队的线程，那么每个线程都要把其它线程检查一遍，每个线程要检查的时间复杂度就是<code>O(N)</code></p>
<ul>
<li>比如：有 1000 个并发线程，那么要总共要检测的数量就是 1000*1000 = 100W，即：<code>O(N^2)</code>，这种数量级的检测就会导致消耗大量的 <code>CPU</code> 资源，你看到的现象就是 <code>CPU</code> 占用率很高，却处理不了多少事务，或是你发现理处的事务很少，但CPU占用率却很高</li>
</ul>
<h4 id="分布式锁加在占据任务之前，占据任务完成之后就解锁，为什么说拉取和执行耦合了？"><a class="headerlink" href="#分布式锁加在占据任务之前，占据任务完成之后就解锁，为什么说拉取和执行耦合了？"></a>分布式锁加在占据任务之前，占据任务完成之后就解锁，为什么说拉取和执行耦合了？</h4>
<p>答：</p>
<ol>
<li>定时拉取有间隔，竞争失败要等这个间隔，这段时间浪费了</li>
<li>什么时候能做，依赖于拿到锁的 <code>worker</code>，多久完成任务占据、锁释放，这个过程这个拿到锁的 <code>worker</code>如果 <code>gc</code> 了，如果挂了，如果任务占据、锁释放失败再本地重试 3 次了，都会影响其他 <code>worker</code>。本来<code>worker</code> 就是做任务的，就算 100 个 <code>worker</code> 也该各做各做，不互相干扰，用了锁，就会互相干扰了</li>
</ol>
<p>详细链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247524580&amp;idx=1&amp;sn=8032d1de9a45304f91dbb2e6f5a12e0e&amp;chksm=f98d244ecefaad58a21f730cd9f0646b41e20cd16d20e76c97b6de3b081d3554637366746fd3&amp;token=1905900309&amp;lang=zh_CN#rd">我打赌！这个 SQL 题，大部分人答不出来</a></p>
<hr>
<h3 id="不使用Redis，如何解决多机竞争问题？设计一个新方案"><a class="headerlink" href="#不使用Redis，如何解决多机竞争问题？设计一个新方案"></a>不使用Redis，如何解决多机竞争问题？设计一个新方案</h3>
<p>答：</p>
<p>其实我也考虑过这个问题，分布式锁会带来 <code>worker</code> 无法水平扩容的问题，本质是：<strong>同步拉取和并发执行的耦合</strong>，所以这里可以引入一个拉取服务，专门来拉取并占据任务，然后扔入 <code>kafka</code>，通过 <code>kafka</code>多分区特性<code>worker</code> 就可以并发消费，这样就实现了解耦</p>
<hr>
<h3 id="你采用的是多台worker竞争任务的方式，那这样会不会出现有些worker在执行大量任务但是一部分worker处于空闲的状态呢？"><a class="headerlink" href="#你采用的是多台worker竞争任务的方式，那这样会不会出现有些worker在执行大量任务但是一部分worker处于空闲的状态呢？"></a>你采用的是多台worker竞争任务的方式，那这样会不会出现有些worker在执行大量任务但是一部分worker处于空闲的状态呢？</h3>
<p>答：</p>
<ul>
<li>不会的，我们占据任务之后就会释放锁，这个是在执行之前，假设资源配置合理，那多台机器都会有任务去做。如果出现有机器闲置，说明可以缩容</li>
<li>另外，为了避免任务比较少时，一个 <code>worker</code> 老是竞争成功这种不均衡的情况，我们也<strong>加入了一个随机的间隔时间，以增加更多随机性</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p>我们以 分布式锁 的方案来讨论，我们的 <code>worker</code> 占据任务之后，在执行前就释放了锁，这个时间很短，这种情况下执行时间才是大头，那第一个 <code>worker</code> 还在执行中，其它 <code>worker</code> 就可以拉到任务，不会出现所谓一部分 <code>worker</code> 处于空闲，如果出现了，那其实就是 <code>worker</code> 太多了</p>
<hr>
<h3 id="任务如果执行中-worker-挂掉怎么办？"><a class="headerlink" href="#任务如果执行中-worker-挂掉怎么办？"></a>任务如果执行中 worker 挂掉怎么办？</h3>
<p>答：</p>
<p><strong>任务会停留在执行中的状态，框架提供最大执行时间的配置，超过执行时间就会由任务治理重置任务</strong>，由于我们保存了上下文，所以下次再做时候会从最新阶段开始做，这样一部分已经做过的事情就不会重复做了</p>
<p><strong>补充</strong>：</p>
<ul>
<li>如果 <code>worker</code> 挂了，那么之前拉取的任务就处于执行中的状态</li>
<li>不会再被调度，那么这就有任务卡死的现象</li>
<li>任务治理服务会定期的检测是否有长期处于执行中卡死的任务</li>
<li>如果有，任务治理服务会获得这些卡死的任务，并将他们的状态重置为待执行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> now() <span class="operator">&gt;</span> modify_time <span class="operator">+</span> max_processing_time;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="那你是怎么得出分布式锁的性能很差，然后要引入MQ的结论的呢？是理论上觉得比较差还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的个决定。"><a class="headerlink" href="#那你是怎么得出分布式锁的性能很差，然后要引入MQ的结论的呢？是理论上觉得比较差还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的个决定。"></a>那你是怎么得出分布式锁的性能很差，然后要引入MQ的结论的呢？是理论上觉得比较差还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的个决定。</h3>
<p>答：</p>
<p>主要是通过理论设想到这个优化，属于做完项目的一个 <code>review</code>。同时也确实考虑到分布式锁在大多数场景都是够用了，同时也没有实际场景因为分布式锁遇到性能瓶颈，所以还没有这么去做，原则就是不过度去实现</p>
<p><strong>补充</strong>：</p>
<p>架构的设计需要有前瞻性，可以不做，但是不能没考虑到</p>
<hr>
<h3 id="你在这个项目里用-MySQL-是比较多的，那有用到事务吗？"><a class="headerlink" href="#你在这个项目里用-MySQL-是比较多的，那有用到事务吗？"></a>你在这个项目里用 MySQL 是比较多的，那有用到事务吗？</h3>
<p>答：</p>
<p>我们的业务没有主动开启事务。目前没有地方涉及 2 张表的更新操作，也没有手动开启事务的场景，都是单独的 <code>sql</code> 语句去处理的</p>
<hr>
<h3 id="如果有很多个客户端一起使用这个框架，可能会发生什么问题？"><a class="headerlink" href="#如果有很多个客户端一起使用这个框架，可能会发生什么问题？"></a>如果有很多个客户端一起使用这个框架，可能会发生什么问题？</h3>
<p>答：</p>
<ul>
<li>我们天然支持多个客户端一起使用这个框架，但随着用户的增多，请求量加大，我们这里目前测试只测到了 2000/s，如果超过的话，可以部署多套框架来服务不同客户</li>
<li>我们支持部署一个<code>flowsvr</code>，业务共用，但是 <code>worker</code> 每个业务自己需要部署一套，因为业务逻辑只有业务方自己才清楚，当然共用一个 <code>fowsvr</code> 只适用于这些业务加一起的量都不大的情况，比如：加一起小于2000/s，如果压力大了，还是推荐每个业务部署自己的 <code>flowsvr</code></li>
</ul>
<hr>
<h3 id="有多个flowsvr的话，怎么让不同的flowsvr不要拉倒同样的任务？"><a class="headerlink" href="#有多个flowsvr的话，怎么让不同的flowsvr不要拉倒同样的任务？"></a>有多个flowsvr的话，怎么让不同的flowsvr不要拉倒同样的任务？</h3>
<p>答：</p>
<p>我们拉取任务的时候 <code>worker</code> 加了分布式锁，所以同一时间只会有一个 <code>worker</code> 来发一个拉取并占据任务的情况，占据之后对应的一批任务状态也变成了执行中，下一次拉取占据就是另一批任务了，所以 <code>flowsvr</code> 不会拉取到同样任务</p>
<p><strong>补充</strong>：</p>
<p><code>worker</code> 拉取任务的时候是加了分布式锁的</p>
<hr>
<h3 id="用户怎么知道任务的执行情况？有没有项目配套的可视化界面？"><a class="headerlink" href="#用户怎么知道任务的执行情况？有没有项目配套的可视化界面？"></a>用户怎么知道任务的执行情况？有没有项目配套的可视化界面？</h3>
<p>答：</p>
<p>用户可以通过 <strong>接口查询任务当前信息</strong>，比如：某个任务分3个阶段，目前进行到第二个阶段，这时候用户来查，都是能查到的。可视化界面没有配套，我们对外提供的都是接口，当然有图形化肯定是锦上添花，后续会考虑</p>
<hr>
<h3 id="分表为什么自己写，为什么不用组件？"><a class="headerlink" href="#分表为什么自己写，为什么不用组件？"></a>分表为什么自己写，为什么不用组件？</h3>
<p>答：</p>
<ul>
<li>常见的组件比如：<code>MyCat</code> 分表，是按照业务字段 <code>hash</code>，比如：<code>userid</code> hash不同用户分到不同的分片里</li>
<li>而在 <code>Asyncflow</code> 框架里面，是需要 <strong>按照大小</strong> 来迭代新表的</li>
<li>并且思路是老表逐渐作废，不是多个分片长期提供服务，相当于一个窗口不断的滑动</li>
<li>同时这个分表逻辑并不复杂，评估了成本和需求之后决定自己做</li>
</ul>
<p><strong>补充</strong>：</p>
<ol>
<li>我们需要按大小迭代</li>
<li>老表热度越来越低</li>
<li>业界组件不支持按大小分片</li>
<li>自己实现成本低</li>
</ol>
<hr>
<h3 id="分表难在哪里？"><a class="headerlink" href="#分表难在哪里？"></a>分表难在哪里？</h3>
<p>答：</p>
<ul>
<li>难点我觉得有两个方面：
<ol>
<li>选型上，我们其实是二维分表，一个是 <code>taskType</code> 来做了隔离，另一个是根据大小进行了滚动分表，这里我们没有按调研的常用分表组件来做，而是选了适合我们的方式，我觉得这个是一定难度的</li>
<li>实现上的细节设计考虑点还是很多，比如：什么时候分表、谁来分表、怎么降低检查分表对性能的影响，比如：我们一开始是想在创建任务时来 <code>count(*)</code> 检查</li>
</ol>
</li>
<li>但是考虑到这会造成性能问题，所以选择了<strong>定时检查</strong>，容忍了一定程度的延迟。比如：还有一个问题，我们分表之后，怎么快速查询到某个任务在哪张表？<strong>这里我们选择了通过在任务 <code>ID</code> 上做手脚，加了个数字尾巴，这种方式减少了查询成本。这些细节其实都花了不少心思去设计</strong></li>
</ul>
<hr>
<h3 id="介绍你的分表方式？"><a class="headerlink" href="#介绍你的分表方式？"></a>介绍你的分表方式？</h3>
<p>答：</p>
<p>我们的任务数量达到一定阈值就会发生分表，分表之后新增任务写入新表，消费还是走老表，老表消费完成之后再消费到新表。<strong>消费几号表、写入几号表，这个信息我们也是通过一张单独的任务位置表记录的</strong></p>
<p><strong>补充</strong>：</p>
<ol>
<li>按大小分表</li>
<li>分表之后消费生产的变化</li>
</ol>
<hr>
<h3 id="为什么按大小分表？"><a class="headerlink" href="#为什么按大小分表？"></a>为什么按大小分表？</h3>
<p>答：</p>
<ul>
<li>我们是记录任务，任务一般做完之后，很快就成了比较冷的数据，甚至某些业务1，2月前的历史数据都可以删除掉，所以更适合这样滚动分表</li>
<li>分表之后，我们的任务消费、任务创建这种主要操作都是发生在热表上，通过任务 <code>id</code> 查询任务信息这类操作则可以通过后缀快速去对应的表查，无论冷热</li>
<li>这种策略对性能友好、也对后面存储友好，同时也非常适合我们的场景</li>
</ul>
<p><strong>补充</strong>：</p>
<ol>
<li>我们的任务执行完了基本就冷了，和账单那种随时间变冷其实很像，并且我们会更冷一些</li>
<li>这里要明确我们其实更偏向于滚表，但是我们之前的数据还能支持提供了按 <code>id</code> 查询等能力，所以分表是 ok 的</li>
</ol>
<hr>
<h3 id="我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天10W条，10天100W，那你两个月分一次就可以了，不用这么麻烦"><a class="headerlink" href="#我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天10W条，10天100W，那你两个月分一次就可以了，不用这么麻烦"></a>我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天10W条，10天100W，那你两个月分一次就可以了，不用这么麻烦</h3>
<p>答：</p>
<p>我觉得对于任务的增速，和流量大小，很有可能是不平均的，比如说：秒杀场景，会有一大波任务过来。这种情况下，我们如果靠一个平均的速率去预估进行分表，肯定是不合理的，很容易发生数据量超过分表阈值，但是没有及时分表影响性能的情况，<strong>我认为这里不如去定时扫描任务量，这样可以保证分表是及时的</strong></p>
<p><strong>补充</strong>：</p>
<p>其实本质还是按时间划分，老表时间肯定比新表早，但区别在于，触发的时机不是固定的时间分割，而是大小分割，为的是一个及时性和数据量均匀性</p>
<hr>
<h3 id="你为了项目做了一个框架？你量这么小，弄500w分表？"><a class="headerlink" href="#你为了项目做了一个框架？你量这么小，弄500w分表？"></a>你为了项目做了一个框架？你量这么小，弄500w分表？</h3>
<p>答：</p>
<ul>
<li>这个我们其实考虑了收益和成本</li>
<li>首先，作为一个框架，我们需要能应对不同的情况，项目虽然小，但其他异步场景一天几十万也是正常的,比如：区块链场景，所以提供分表对我们而言让框架不那么玩具化，这是收益</li>
<li>同时，从成本考虑，我们的分表方案<strong>其实偏向滚表，到500w就产生新的表，旧表还有存活任务就继续消费旧表新任务写入新表</strong>，实现起来代码量也比较少，思路也比较清晰，成本较低。<strong>综合收益和成本来看</strong>，我认为这个算是前瞻性设计而不是过度设计</li>
</ul>
<hr>
<h3 id="flowsvr怎么知道到达分表阈值了，轮询吗，这里有细节吗？"><a class="headerlink" href="#flowsvr怎么知道到达分表阈值了，轮询吗，这里有细节吗？"></a>flowsvr怎么知道到达分表阈值了，轮询吗，这里有细节吗？</h3>
<p>答：</p>
<ul>
<li>我们有个 <strong>任务治理模块</strong> 去轮询，可以理解为有个线程去 <code>count(*)</code> 查看总数是否达到國值。这里其实我们还考虑过在创建时判断，但是如果增加一个 <code>count(*)</code> 去判断，这样创建的吞吐会大幅降低，这种方式也可以进一步优化，比如：这样可以用 <code>Redis</code> 来进行判断，至于 <code>Redis</code> 可能遗漏一些数据，本身对我们而言这个数创建时同时在 <code>Redis</code> 中增加据也不需要完全准确。</li>
<li>但为什么后面没这样做，是因为目前线程轮询的方式并不会带来瓶颈，虽然不是最好，但也够用，所以没去做太过前瞻的设计</li>
</ul>
<hr>
<h3 id="如果读写请求大到超过MySQL的处理能力呢，比如一个MySQL假设就是8000-s的处理能力，此时请求有2万，这个是怎么考虑的"><a class="headerlink" href="#如果读写请求大到超过MySQL的处理能力呢，比如一个MySQL假设就是8000-s的处理能力，此时请求有2万，这个是怎么考虑的"></a>如果读写请求大到超过MySQL的处理能力呢，比如一个MySQL假设就是8000/s的处理能力，此时请求有2万，这个是怎么考虑的?</h3>
<p>答：</p>
<ul>
<li>我们的热点请求，都是任务调度相关的拉取任务和设置任务状态。这两个操作都有走索引</li>
<li>通常来说普通的 <code>MySQL</code> 配置如 8 核 16 G，每秒 6000 是没什么问题的，这样一小时可以支持 2160W 任务，在异步场景下瓶颈通常也不在这里</li>
<li>如果单表确实性能不够了，我们也可以<strong>支持按用户 <code>Hash</code> 分片</strong>，一个比较容易的方式是<strong>接入 <code>tdsql</code> 这种完全兼容 <code>mysql</code> 的数据库，可以自动分片</strong>。另外我们也打算<strong>提供 <code>mongodb</code> 这样天然支持分片的文档数据库</strong>用作任务管理，这个可以根据场景选择的</li>
</ul>
<p><strong>补充</strong>：</p>
<p>我们的思路就2点：</p>
<ol>
<li>这块需要量很大才会成为瓶颈，而异步任务一般不会这么大，所以没过度设计</li>
<li>我们也思考了怎么扩展，虽然没做，但考虑周全</li>
</ol>
<hr>
<h3 id="会不会出现schedule-beign-pos和schedule-end-pos跨不止1张表的情况？"><a class="headerlink" href="#会不会出现schedule-beign-pos和schedule-end-pos跨不止1张表的情况？"></a>会不会出现schedule_beign_pos和schedule_end_pos跨不止1张表的情况？</h3>
<p>答：</p>
<p>不会的，我们分表是当成一个过渡状态，预期就是短时间内能完成，所以最多跨一张表分</p>
<p><strong>补充</strong>：</p>
<p>我们分表逻辑限制了最多同时 2 张表存在</p>
<hr>
<h3 id="推荐分表的阈值是多少？为什么这么推荐？"><a class="headerlink" href="#推荐分表的阈值是多少？为什么这么推荐？"></a>推荐分表的阈值是多少？为什么这么推荐？</h3>
<p>答：</p>
<ul>
<li>500W。网上推荐比较多是<strong>把 B+ 树层高维持在 三层，也就是最多是2000W</strong>。实践中这个数字其实应该更小一些，阿里巴巴就推荐 500W 数据分表，因为实际查询很多时候不全是走索引场景，比如：我们的场景需要支持比较丰富的任务管理，以及数量统计等请求，举个例子，查询某个用户当前进行中任务总数，以及分页查询，这些请求在 500W 左右就已经有压力了</li>
<li>同时，500W 和 2000W 对于相对正常的任务生产消费而言，都是够用的，所以选择了500W</li>
</ul>
<hr>
<h3 id="分表时，如果任务全到1号表，0号表是清掉吗？用什么语句清，为什么，这里有做设计吗？"><a class="headerlink" href="#分表时，如果任务全到1号表，0号表是清掉吗？用什么语句清，为什么，这里有做设计吗？"></a>分表时，如果任务全到1号表，0号表是清掉吗？用什么语句清，为什么，这里有做设计吗？</h3>
<p>答：</p>
<ul>
<li>分表之后，0 号表如果还有任务，是先消费0号表，完成之后再消费1号表，也就类似于一个老队列，需要先做完再做新队列</li>
<li>这样滚动下去，历史的已完成老表，就可以根据业务情况清理，比如：一个半年前的表，通常可以直接<code>drop</code> 掉</li>
</ul>
<hr>
<h3 id="能否继续往0-1-2-3-4号表滚动，这样不就支持更多任务了？"><a class="headerlink" href="#能否继续往0-1-2-3-4号表滚动，这样不就支持更多任务了？"></a>能否继续往0 1 2 3 4号表滚动，这样不就支持更多任务了？</h3>
<p>答：</p>
<p>异步任务瓶颈在执行，而不在任务拉取，通常来说单个表 500W 是够用了。但如果进一步需要支持更多任务，我会选择用 <code>TDSQL</code> 这种分布式 <code>MySQL</code>，或者 <code>MongoDB</code> 这样可以分片的数据库，这样单表的数据就可以进一步往上走了，也就是说维持现在的编号分表，但是某个分表，比如：1号表，他本身又是支持了分片的</p>
<hr>
<h3 id="你是对任务信息表分表，为什么不直接按照任务id分表，比如：大于500w一张表，大于1000w一张表？"><a class="headerlink" href="#你是对任务信息表分表，为什么不直接按照任务id分表，比如：大于500w一张表，大于1000w一张表？"></a>你是对任务信息表分表，为什么不直接按照任务id分表，比如：大于500w一张表，大于1000w一张表？</h3>
<p>答：</p>
<p>用 <code>id</code> 分其实是可以的。但是考虑到 <code>count</code> 是最准确的，<strong>依赖于 <code>id</code> 这种递增规则，其实是不通用的做法。同时，如果使用 <code>id</code>，也无法在创建时去做分表，这会将分表逻辑和业务创建功能耦合，且影响创建任务的性能，所以还是得单独开线程定时去查，这样的做的话没有明显的收益</strong>，反而因为前面原因增加了心智成本，所以最终还是用count总数的方式</p>
<p><strong>补充</strong>：</p>
<p>是可以按 <code>id</code> 分，但是就耦合这个数据，同时也不能创建之后就知道 <code>id</code> 是多少了，还是得线程去轮询查，没有明显受益</p>
<hr>
<h3 id="如果分表中，因为某些原因老表迟迟没做完，新表的高优任务会不会饿死？"><a class="headerlink" href="#如果分表中，因为某些原因老表迟迟没做完，新表的高优任务会不会饿死？"></a>如果分表中，因为某些原因老表迟迟没做完，新表的高优任务会不会饿死？</h3>
<p>答：</p>
<p>滚表我们预期是比较短暂的，如果时间超过值，那么我们会改变调度策略，比如：原来从0表获取100个任务执行，那么达到阈值之后，就从0表，1表各获取50个，避免新的紧急任务被饿死</p>
<hr>
<h3 id="Async分表之后，怎么解决的主键冲突？"><a class="headerlink" href="#Async分表之后，怎么解决的主键冲突？"></a>Async分表之后，怎么解决的主键冲突？</h3>
<p>答：</p>
<p>在我们的场景，访问任务都是使用任务<code>ID</code>，而非主键 <code>ID</code>，任务<code>ID</code>是 <code>uuid</code> 不会重复，主键 <code>ID</code> 我们每张表自然自增即可，不用全局唯一</p>
<p><strong>补充</strong>：</p>
<p>关键是要理解 主键<code>ID</code> 和 任务<code>ID</code> 不是一个东西</p>
<hr>
<h3 id="这个框架的性能怎么样？"><a class="headerlink" href="#这个框架的性能怎么样？"></a>这个框架的性能怎么样？</h3>
<p>答：</p>
<p>这里我们测了主要的接口，包括：创建任务、查询任务、占据任务等。其中创建任务能达到2000，机器是 2 核 4G 的云虚拟机，原来是 500 <code>QPS</code>，优化之后达到 2000 <code>QPS</code></p>
<hr>
<h3 id="选的是什么数据来测试？"><a class="headerlink" href="#选的是什么数据来测试？"></a>选的是什么数据来测试？</h3>
<p>答：</p>
<p>我们在数据库装满 500w 数据情况下，测试了 创建任务、占据任务、查询任务结果 这几个核心接口，创建任务和占据任务调优之后可以从 500 到 2000 <code>QPS</code>，查询任务结果因为有缓存所以很轻松能达到 4000 以上<code>QPS</code>，没有进一步去测他极限，理论上 Redis 查询是可以 10多万的</p>
<hr>
<h3 id="一开始的性能瓶颈是什么？"><a class="headerlink" href="#一开始的性能瓶颈是什么？"></a>一开始的性能瓶颈是什么？</h3>
<p>答：</p>
<p>一开始在产生大量并发请求时，发现很多请求失败了，经过日志排查发现数据库连接数出现了大量的失败的情况，然后查了一下，发现是客户端默认的比较小，然后经过资料查询呢，发现这个值也不能设置的特别大，需要根据实际的机器配置，场景进行设置，并不是自己当初预想的设置为几千并发数就能提高那么简单，设置的特别大有可能会导致整个机器崩掉。然后将其提高为 80，发现 <code>QPS</code> 提升至 1800 左右，但是排查服务器，发现在压测时会出现少量的 <code>TIME_WAIT</code> 状态，经过查阅资料发现是一般来说，<code>maxActive</code> 和 <code>maxIdle</code> 这两个参数设置的比较相近，但是在调整时只调大了 <code>maxActive</code> 而没有调整 <code>maxIdle</code>，超过 <code>maxIdle</code> 的链接会在使用后立即销毁，所以会出现 <code>TIME_WAIT</code> 状态，所以将 <code>maxIdle</code> 也设置为 80，<code>QPS</code> 又提升至 2000 左右。（这里用的是 <code>DBCP</code> 连接池，非 <code>Druid</code>，4 核 8G 机器）</p>
<p><code>Apache DBCP</code> 示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Resource</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;jdbc/myDB&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxActive</span>=<span class="string">&quot;50&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxIdle</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxWait</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">&quot;dbuser&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">password</span>=<span class="string">&quot;dbpassword&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">driverClassName</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxActive</code> ：指定连接池中允许同时分配的最大数据库连接数，包括空闲和正在使用的连接</li>
<li><code>maxIdle</code>：连接池中允许的最大空闲连接数</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://xiaoxiami.gitbook.io/swoole/swoole-gao-ji-te-xing/shu-ju-ku-lian-jie-chi">mysql连接池 | swoole 高手之路</a></p>
<hr>
<h3 id="你是怎么测试的？"><a class="headerlink" href="#你是怎么测试的？"></a>你是怎么测试的？</h3>
<p>答：</p>
<p>我一开始是自己写的 <code>Java</code> 程序来进行压测，但后面感觉不够专业，就采用了 <code>Wrk</code> 这个轻量级开源工具来进行测试，配合 <code>Lua</code> 脚本可以很方便地发起压测，支持设置并发数、持续时间、间隔时间等参数</p>
<hr>
<h3 id="如果突然有特别多数据怎么处理呢？不考虑对worker进行扩容，不考虑增加机器，比如就多了50-这样的需求，框架的的瓶颈在什么地方？这个模块会出什么问题"><a class="headerlink" href="#如果突然有特别多数据怎么处理呢？不考虑对worker进行扩容，不考虑增加机器，比如就多了50-这样的需求，框架的的瓶颈在什么地方？这个模块会出什么问题"></a>如果突然有特别多数据怎么处理呢？不考虑对worker进行扩容，不考虑增加机器，比如就多了50%这样的需求，框架的的瓶颈在什么地方？这个模块会出什么问题</h3>
<p>答：</p>
<ul>
<li>我觉得瓶颈可能考虑三个地方
<ol>
<li>从数据库来看，我们拉取之前会判断是否这个任务类型是否达到了当前能执行的最大个数，这种 <code>count</code> 的操作，也容易成为瓶颈，这里可以做一个 <code>Redis</code> 缓存，定时刷新，这样也能提升执行时的吞吐</li>
<li>从设计来看，我们刚才提到的消息队列解耦方式，也能提高吞吐</li>
<li>从 <code>worker</code> 程序本身来看，<code>HTTP</code> 连接池，<code>gc</code> 回收阈值参数，这些也可以进一步调优，这个实践的话需要结合测试</li>
</ol>
</li>
</ul>
<p><strong>补充</strong>：</p>
<p>数据库是最容易成为瓶颈的，先提数据库，然后从方案设计，然后从 <code>worker</code> 程序优化</p>
<hr>
<h3 id="任务积压怎么解决，怎么发现，不能说积压了甩给-worker-不管了？"><a class="headerlink" href="#任务积压怎么解决，怎么发现，不能说积压了甩给-worker-不管了？"></a>任务积压怎么解决，怎么发现，不能说积压了甩给 worker 不管了？</h3>
<p>答：</p>
<ul>
<li>首先我们可以 <strong>通过日志和监控</strong> 发现积压，同时我们在拉取任务时是会检查当前任务总数的，这时候也能发现</li>
<li>如果 <strong>积压不严重</strong> 的话，我们可以<strong>扩容 <code>worker</code> 来解决</strong></li>
<li>如果是 <strong>积压太过严重</strong>，老任务已经受影响了，可以考虑保新任务，我们这里 <strong>基于分表逻辑来处理</strong></li>
<li>简单来说，<strong>是发现积压过重时，通过触发一个特殊的分表接口，主动分表，并且从新表开始调度，用户调用这个接口，老任务就不会被调度到，回头有余力再处理他们</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<ol>
<li>积压是队列化场景常见的问题</li>
<li>解决思路可以从多个方向去说</li>
<li>这个功能属于细节加强，目前没有实现的，通过这个问题，正好可以思考出一些方案</li>
</ol>
<hr>
<h3 id="如何调优的？（Java）"><a class="headerlink" href="#如何调优的？（Java）"></a>如何调优的？（Java）</h3>
<p>答：</p>
<ul>
<li><strong>连接池调优</strong>，<strong>原来连接池设置过小</strong>，大概是 10，压力上去之后，<code>QPS</code> 大量降低，根据无法打开 <code>MySQL</code> 连接的报错，定位到是连接池的问题，调大之后不再有问题，同时性能高了接近一倍，提升这么多主要原因也是因为链接无法打开导致压力也上不去</li>
<li><strong><code>GC</code> 调优</strong>，那就是说因为我们对象频繁申请和释放，所以 <code>gc</code> 也过于频繁，<strong>这里通过 调大年轻代 来缓解</strong>，这样 <code>gc</code> 频率变小，性能提高 30%</li>
<li><strong>缓存调优</strong>，<strong>将一些查询使用 <code>Redis</code> 缓存</strong>，比如：查询任务结果这个接口，通过加入 <code>Redis</code> 缓存提升到了 5000 <code>QPS</code>，实际理论上还可以更大，但我的网络带宽等资源不够了，没有进一步往上压</li>
</ul>
<hr>
<h3 id="flowsrv-性能是怎么优化的，瓶颈点是哪里？"><a class="headerlink" href="#flowsrv-性能是怎么优化的，瓶颈点是哪里？"></a>flowsrv 性能是怎么优化的，瓶颈点是哪里？</h3>
<p>答：</p>
<ul>
<li>我主要从几方面调优的
<ul>
<li>连接池调优，原来连接池设置过小，大概是 10，压力上去之后，<code>QPS</code> 大量降低，定位到是连接池的问题，调大之后性能高了接近一倍，提升这么多主要原因也是因为报错太多导致</li>
<li>同时，一些流程的查询很慢，拉低整体效率，比如：我们去拉取任务时，会查看处于执行中的任务有多少个，如果太多就暂时不执行这批任务，当执行中任务比较多时，这个 <code>count</code> 操作是比较耗时的，这里我们并不需要严格保证数目，通过缓存的方式进行了优化</li>
<li>另外，针对一些读接口，比如：查询任务结果，也加了缓存，也大大提升了查询的效率</li>
<li>最后，我们目前的一个瓶颈实际是在 <code>MySQL</code>，我单机部署的 <code>MySQL</code> 只有3000 <code>QPS</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="你不是说你的worker只有六台吗？六台worker拉取任务需要2000QPS？"><a class="headerlink" href="#你不是说你的worker只有六台吗？六台worker拉取任务需要2000QPS？"></a>你不是说你的worker只有六台吗？六台worker拉取任务需要2000QPS？</h3>
<p>答：</p>
<p>我们是框架，我们的场景虽然不需要这么高的 <code>TPS</code>（在性能测试中，<code>TPS</code> 通常表示系统每秒可以处理的事务数量，是衡量系统性能的重要指标），但是我们会测到一个相对高的数值。不止是这个接口，创建任务、拉取任务、查询任务等我们都做了。虽然拉取任务不需要 2000，但我们压测适度调优就达到了2000，属于一个非常够用的值</p>
<hr>
<h3 id="任务特别多怎么办？你的框架会怎么处理？"><a class="headerlink" href="#任务特别多怎么办？你的框架会怎么处理？"></a>任务特别多怎么办？你的框架会怎么处理？</h3>
<p>答：</p>
<ul>
<li>如果积压了，这时候我们还是会如常根据优先级调度，不让紧急任务饿着</li>
<li>积压严重的话，是建议扩容执行资源来解决的，当然如果资源也不好协调，<strong>还提供了一个特殊的接口，强行分出一张新的表，并且从新表开始调度，用户调用这个接口，老任务就不会被调度到，回头有余力再处理他们</strong></li>
</ul>
<p><strong>补充</strong>：</p>
<p>这类积压问题解决思路就3个：</p>
<ol>
<li>增加资源去消费掉</li>
<li>优先保新任务，老任务慢都慢了，回头有余力再做</li>
<li>保老任务，不给新任务提供服务</li>
</ol>
<hr>
<h3 id="待处理的任务过多时，不允许-worker-扩容的情况下怎么处理？"><a class="headerlink" href="#待处理的任务过多时，不允许-worker-扩容的情况下怎么处理？"></a>待处理的任务过多时，不允许 worker 扩容的情况下怎么处理？</h3>
<p>答：</p>
<p>（类似上面的回答）</p>
<ul>
<li>如果积压了，这时候我们还是会如常根据优先级调度，不让紧急任务饿着</li>
<li>这里还提供了一个特殊的接口，强行分出一张新的表，并且从新表开始调度，用户调用这个接口，老任务就不会被调度到，回头有余力再处理他们，这也是种保新任务的策略</li>
</ul>
<hr>
<h3 id="500QPS你这个项目不够用吗？还需要提升到2000QPS？"><a class="headerlink" href="#500QPS你这个项目不够用吗？还需要提升到2000QPS？"></a>500QPS你这个项目不够用吗？还需要提升到2000QPS？</h3>
<p>答：</p>
<ul>
<li>我们是框架，也许我们目前场景还不需要2000/s，但是综合考虑投入产出比，我们还是进行了相关优化，这些优化无论从人力还是从组件成本而言，都是很低的，所以我们做了优化</li>
<li>而像 <code>MySQL</code> 分库或者 水平分片 这种架构上增加很大复杂性且会增加机器成本的事情我们就不会做，消息队列引入同样的，投入高，收益低</li>
</ul>
<hr>
<h3 id="我现在有个需求要求从-500-QPS提升到-50000-QPS谈谈你的思路？"><a class="headerlink" href="#我现在有个需求要求从-500-QPS提升到-50000-QPS谈谈你的思路？"></a>我现在有个需求要求从 500 QPS提升到 50000 QPS谈谈你的思路？</h3>
<p>答：</p>
<p>我们的 <code>worker</code>、<code>flowsvr</code> 其实都可以水平扩容，这里最大的瓶颈还是 <code>MySQL</code>，虽然是滚表，但是同时提供热点服务的，是一张表，这里我们可以根据 用户<code>id</code> 的 <code>hash</code> 做水平分片，比如：一个 <code>MySQL</code> 如果是5000/s，那么我们分 10 片，就能到 5W 每秒</p>
<p><strong>补充</strong>：</p>
<p>5w/s 这里如果单用 <code>MySQL</code> 可能需要做水平分片了</p>
<hr>
<h3 id="你有对项目进行SQL调优？"><a class="headerlink" href="#你有对项目进行SQL调优？"></a>你有对项目进行SQL调优？</h3>
<p>答：</p>
<ul>
<li>在 <code>Async</code> 项目里，<strong>获取任务 的接口</strong>，有一个频繁查询的 <code>SQL</code> 是拉去任务，这个 <code>SQL</code> 是查询任务状态为等待执行，然后根据优先级来排序，然后取前 1000 个任务，这查询会有涉及 <code>ORDER BY</code> 语句</li>
<li>当时自己构造了上千万的任务量进行测试，压测获取任务的接口的性能，发现接口耗时很长，达到秒级别，打开了慢查询日志，发现是这条 <code>SQL</code> 执行很慢，查询耗时达到了秒级，通过 <code>explian</code> 观察发现 <code>extra</code> 信息里显示了 <code>file sort</code>，就是进行了额外的排序操作</li>
<li>在设计任务表之初，我考虑到这个查询可能会存在额外排序的问题，所以<strong>建立 <code>(status, order_time)</code> 联合索引来优化</strong>，因为索引是天然有序的，这样排序操作就不需要额外操作了，能避免 <code>file sort</code> 的过程</li>
</ul>
<p><strong>补充</strong>：</p>
<p>在 <code>Async</code> 项目，有针对拉去任务 <code>SQL</code> 的优化操作，通过建立 <code>(status，order_time)</code> 联合索引来优化，避免了 <code>file sort</code> 的过程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据优先级来排序，Async 项日拉去任务的时候的 sql 语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t_lark_task_2` <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_time LIMIT <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原因在于联合索引的 <strong>有序性</strong> 和数据库对索引的高效利用</li>
</ul>
<hr>
<h3 id="比如说你像如果说要做一个流程，首先是它这个稳定性对不对？这个特性上面你是怎么去考虑并设计的？就是如果做流程系统的话，我觉得这这个点是肯定是要着重去考虑。"><a class="headerlink" href="#比如说你像如果说要做一个流程，首先是它这个稳定性对不对？这个特性上面你是怎么去考虑并设计的？就是如果做流程系统的话，我觉得这这个点是肯定是要着重去考虑。"></a>比如说你像如果说要做一个流程，首先是它这个稳定性对不对？这个特性上面你是怎么去考虑并设计的？就是如果做流程系统的话，我觉得这这个点是肯定是要着重去考虑。</h3>
<p>答：</p>
<ol>
<li><strong>集群化部署</strong>，包括：<code>Redis</code> 主从部署，<code>MySQL</code> 主从部署，服务多节点部署</li>
<li><strong>服务无状态化</strong>，我的服务层和执行层都是无状态的，这样假设一个节点出现问题，其他节点还能正常工作</li>
<li><strong>上下文存储</strong>，一个任务如果执行到一半，节点崩溃了，那么下次我可以从已经保存的阶段继续执行，避免浪费资源</li>
<li><strong>其他异常兜底</strong>，比如：滚表我们预期是比较短暂的，如果时间超过阈值，那么我们会改变调度策略，比如：原来从 0 表获取 100 个任务执行，那么达到值之后，就从 0 表，1 表各获取50个，避免新的紧急任务被饿死</li>
</ol>
<hr>
<h3 id="你觉得你这个项目的缺点是什么？"><a class="headerlink" href="#你觉得你这个项目的缺点是什么？"></a>你觉得你这个项目的缺点是什么？</h3>
<p>答：</p>
<ol>
<li>底层存储目前比较单一，只支持 <code>MySQL</code>，后面有计划支持 <code>MongoDB</code></li>
<li>任务模型较简单，任务之间没关联，如果有后续倒是考虑增加父子任务</li>
<li>任务治理功能还比较初浅，没有根据 <code>worker</code> 上报做一些动态调整的能力</li>
</ol>
<p><strong>补充</strong>：</p>
<p>父子任务是说现在的任务之间是没关系的，我们可以让他们有关系，比如：一个任务，他可以依赖另外几个任务这个设计起来就复杂了。如果系统设计能力还不到位，父子任务就别说了，扩展开来，容易翻车</p>
<hr>
<h3 id="你的框架的优点是什么？"><a class="headerlink" href="#你的框架的优点是什么？"></a>你的框架的优点是什么？</h3>
<p>答：</p>
<p>灵活的优先级设计、灵活的重试间隔、用滚表实现冷热数据分离、低成本解决任务竞争问题、以及 清晰简洁的架构设计</p>
<hr>
<h3 id="Async-用了哪些个线程池？（Java）"><a class="headerlink" href="#Async-用了哪些个线程池？（Java）"></a>Async 用了哪些个线程池？（Java）</h3>
<p>答：</p>
<ul>
<li>线程池我们主要是在 <code>Worker</code> 里处理并发任务时使用，这里我们自定义了一个 <code>ThreadPoolExecutor</code> 线程池，用来并行处理拉下来的任务</li>
<li>另外在处理一些周期性的任务上，我们也是用了线程池的扩展类 <code>ScheduledThreadPoolExecutor</code>，比如：去定时更新任务配置</li>
<li>如果回答了任务治理模块的内容，任务治理模块里使用了自定义的 <code>ScheduledThreadPoolExecutor</code> 和 <code>spring</code> 的 <code>@Scheduled</code> 注解来处理分表和任务治理的逻辑</li>
</ul>
<p><strong>详细链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/105270194">一文搞懂Executor执行器和线程池的关系，整体介绍其任务执行/调度体系：ThreadPoolExecutor、ScheduledExecutorService_scheduledexecutorservice 和 threadpooltaskexecutor-CSDN博客</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/7082538457251184647">Spring @Scheduled 使用详解Spring 为任务调度和基于使用@Scheduled 注释的 cron 表 - 掘金</a></p>
<hr>
<h3 id="Async-分布式锁怎么实现的？（Java）"><a class="headerlink" href="#Async-分布式锁怎么实现的？（Java）"></a>Async 分布式锁怎么实现的？（Java）</h3>
<p>答：</p>
<p>我们调研过 <code>Java</code> 中比较主流的做法是使用 <code>redisson</code> 实现的，所以项目中我们也是这么做的，使用上非常简单，但是我也研究过 <code>redis</code> 做分布式锁的一些问题，以及 <code>redisson</code> 是如何解决这些问题的，可以详细说说吗？</p>
<p><strong>详细链接</strong>：见Redis笔记</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42056183">分布式锁看这篇就够了 - 知乎</a>、</p>
<hr>
<h3 id="Async-线程池的参数设置了多少？（Java）"><a class="headerlink" href="#Async-线程池的参数设置了多少？（Java）"></a>Async 线程池的参数设置了多少？（Java）</h3>
<p>答：</p>
<ul>
<li>核心线程 和 最大线程 都是 5</li>
<li>阻塞队列使用了有界的 <code>LinkedBlockingQueue</code></li>
<li>队列大小设置的是 <code>1000</code></li>
<li>拒绝策略使用的默认 <code>AbortPolicy</code></li>
</ul>
<hr>
<h3 id="数据库连接池怎么合理的设置？"><a class="headerlink" href="#数据库连接池怎么合理的设置？"></a>数据库连接池怎么合理的设置？</h3>
<p>答：</p>
<p>之前看到 <code>Hikari</code> 数据库连接池官方推荐的数据库连接池大小的建议值公式：<strong>CPU核心数 * 2 + 1</strong></p>
<p><strong>详细链接</strong>：</p>
<ul>
<li>常见的数据库连接池有 <code>DBCP</code>、<code>C3P0</code>、阿里的 <code>Druid</code>、<code>Hikari</code>
<ul>
<li>连接池并不是越大越好，比如：<code>Druid</code> 的默认最大连接池大小是 8，<code>Hikari</code> 默认最大连接池大小是 10，盲目地加大连接池的大小，系统执行效率反而有可能降低
<ul>
<li><strong>原因</strong>：对于每一个连接，服务端会创建一个单独的线程去处理，连接数越多，服务端创建的线程自然也就越多。而线程数超过 <code>CPU</code> 个数的情况下，<code>CPU</code> 势必要通过分配时间片的方式进行线程的上下文切换，频繁的上下文切换会造成很大的性能开销</li>
</ul>
</li>
<li><code>Hikari</code> 官方给出了一个 <code>PostgreSQL</code> 数据库连接池大小的建议值公式：<strong>CPU核心数 * 2 + 1</strong>。假设服务器的 <code>CPU</code> 核心数是 4、把连接池设置成 9 就可以了。这种公式在一定程度上对其他数据库也是适用的</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Async-用什么垃圾回收算法？（Java）"><a class="headerlink" href="#Async-用什么垃圾回收算法？（Java）"></a>Async 用什么垃圾回收算法？（Java）</h3>
<p>答：</p>
<p>这一块我没有去做特殊调整，使用的 <code>Java 1.8 JVM</code> 的默认配置，其中年轻代是 <code>Parallel Scavenge</code> 使用 <strong>标记-复制</strong> 算法的多线程收集器，老年代是 <code>Parallel Old</code> 使用 <strong>多线程 和 “标记-整理” 算法</strong></p>
<p><strong>补充</strong>：</p>
<ul>
<li><code>Async</code> 项目没有特殊去配置这块的内容，采用的是默认值，也是想引出 <code>gc</code> 的问题，回答之前先确认自己的 <code>jdk</code> 版本，再去回答接下来的问题</li>
</ul>
<hr>
<h3 id="Async-用了什么设计模式？"><a class="headerlink" href="#Async-用了什么设计模式？"></a>Async 用了什么设计模式？</h3>
<p>答：</p>
<p>目前项目里用的设计模式都比较单一，主要使用了单例模式</p>
<hr>
<h3 id="项目代码量有多少？当时做了多久？"><a class="headerlink" href="#项目代码量有多少？当时做了多久？"></a>项目代码量有多少？当时做了多久？</h3>
<p>答：</p>
<p>2000，3000行，方案和设计以及一些知识的调研做得比较久，有1个月。真正写代码就20多天</p>
<hr>
<h3 id="你的项目最大的难点是什么？怎么解决的？"><a class="headerlink" href="#你的项目最大的难点是什么？怎么解决的？"></a>你的项目最大的难点是什么？怎么解决的？</h3>
<p>答：</p>
<p>我觉得我这个项目，有这么几个难点：</p>
<ol>
<li><strong>性能调优涉及面广</strong>：我们定的目标是 2000 <code>QPS</code>，但是一开始只有500 <code>QPS</code>。最终通过 <code>MySQL</code> 连接池、<code>Redis</code> 缓存、减少竞争 等手段优化到 2000 <code>QPS</code></li>
<li><strong>分表方案选型难</strong>：我们框架所需的分表，是需要按照大小来迭代新表，不断向前推进的，而不是传统的分片长期稳定存在，而业界的方案都是按某个 <code>Key</code> 来水平切片，这个在选型取舍上有难度</li>
<li><strong>处理多机竞争问题</strong>：多机时候可能会拉取到同一批任务重复做，造成资源浪费，引入分布式锁解决</li>
</ol>
<hr>
<h3 id="开发过程中有出现什么bug？"><a class="headerlink" href="#开发过程中有出现什么bug？"></a>开发过程中有出现什么bug？</h3>
<p>答：</p>
<ul>
<li>比如：数据库一开始 <code>context</code> 字段设置过小，只有 32 的长度，大一点的上下文插入失败</li>
<li>比如：优先级计算逻辑忘记考虑重试间隔，导致重试间隔失效</li>
<li>比如：忘记做参数检查，没有注册过的任务也插入了数据库，无法消费</li>
</ul>
<p>（这里根据当时开发环境说）</p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"></a><div class="post-copyright__author_name">coo1heisenberg's Blog</div><div class="post-copyright__author_desc">Diligence can make up for clumsiness!</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">coo1heisenberg's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Project/"><span class="tags-punctuation"></span>Project<span class="tagsPageCount">4</span></a></div></div><div class="social-share"></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/05/07/00-spike-program/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">00 秒杀微服务项目 笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="solitude st-star-smile-fill"></i><span>喜欢这篇的人也看了</span><div class="relatedPosts-link"><a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a></div></div><div class="relatedPosts-list"><div><a href="/2024/07/08/01-%E5%A4%B4%E6%9D%A1%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/" title="01 仿今日头条项目"><img class="cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Snipaste_2024-06-25_21-33-23.png" alt="cover"><div class="content is-center"><div class="title">01 仿今日头条项目</div></div></a></div><div><a href="/2024/06/25/00-%E5%A4%B4%E6%9D%A1%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/" title="00 仿今日头条项目"><img class="cover" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/Snipaste_2024-06-25_21-33-23.png" alt="cover"><div class="content is-center"><div class="title">00 仿今日头条项目</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/MyPhoto.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">菜鸡的自我救赎...</div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Coo1heisenberg’s BLOG</div><div class="author-info__desc">Diligence can make up for clumsiness!</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/coo1heisenbergProject" title="Github"><i class="solitude  st-github-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">异步框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">异步框架介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-text">需求概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">整体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-text">服务介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">表结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF%E8%A1%A8"><span class="toc-text">任务信息表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E8%A1%A8"><span class="toc-text">任务配置表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BD%8D%E7%BD%AE%E8%A1%A8"><span class="toc-text">任务位置表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flowsvr-%E8%AE%BE%E8%AE%A1"><span class="toc-text">flowsvr 设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%EF%BC%88create-task%EF%BC%89"><span class="toc-text">创建任务（create_task）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E6%8D%AE%E4%B8%80%E6%89%B9%E4%BB%BB%E5%8A%A1%EF%BC%88hold-tasks"><span class="toc-text">占据一批任务（hold_tasks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%88get-task-list%EF%BC%89"><span class="toc-text">获取任务列表（get_task_list）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF%EF%BC%88set-task%EF%BC%89"><span class="toc-text">更新任务信息（set_task）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%88%97%E8%A1%A8%EF%BC%88get-task-schedule-cfg-list%EF%BC%89"><span class="toc-text">获取任务配置列表（get_task_schedule_cfg_list）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-%E8%AE%BE%E8%AE%A1"><span class="toc-text">worker 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E6%B5%81%E7%A8%8B"><span class="toc-text">重点流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%EF%BC%88flowsvr%EF%BC%89"><span class="toc-text">创建任务（flowsvr）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E6%8D%AE%E4%BB%BB%E5%8A%A1%EF%BC%88flowsvr%EF%BC%89"><span class="toc-text">占据任务（flowsvr）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%EF%BC%88worker%EF%BC%89"><span class="toc-text">任务调度（worker）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC"><span class="toc-text">状态流转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E9%87%8D%E8%AF%95%E9%97%B4%E9%9A%94"><span class="toc-text">最大重试间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E8%AE%A1"><span class="toc-text">优先级设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">分表设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">分表流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC"><span class="toc-text">数据库状态流转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%96%91%E9%97%AE%E7%82%B9"><span class="toc-text">常见疑问点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">同步与异步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">适合异步的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%B2%BB%E7%90%86"><span class="toc-text">任务治理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-text">主要用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-text">代码说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flowsvr"><span class="toc-text">Flowsvr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker"><span class="toc-text">Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BATask%E6%B5%81%E7%A8%8B"><span class="toc-text">创建Task流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-text">调度流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-text">主线流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">使用反射的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E4%BB%BB%E5%8A%A1Lark"><span class="toc-text">样例任务Lark</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E5%92%8C-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Async 和 消息队列 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么做更新任务和任务管理的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%B8%9A%E7%95%8C%E5%B7%B2%E6%9C%89%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-text">为什么不用业界已有的异步任务框架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E6%AF%94%E4%BA%8Exxx-job%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E6%88%96%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">相比于xxx-job有什么优势或不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A5%E5%85%A5%E5%91%A2%EF%BC%9F"><span class="toc-text">框架是怎么接入呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E5%91%A2%EF%BC%9F"><span class="toc-text">框架是怎么部署呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker%E6%98%AF%E6%89%98%E7%AE%A1%E5%9C%A8%E6%A1%86%E6%9E%B6%E8%BF%99%E8%BE%B9%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%97%EF%BC%9F%E8%BF%98%E6%98%AF%E5%9C%A8%E5%AF%B9%E4%BA%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%A6%82%E6%9E%9Cworker%E6%89%98%E7%AE%A1%E5%9C%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E8%BF%99%E8%BE%B9%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%82%A3%E5%A4%84%E7%90%86%E5%AE%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%9B%9E%E5%86%99%E5%88%B0%E4%B8%9A%E5%8A%A1%E6%96%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">worker是托管在框架这边的服务器吗？还是在对于异步任务的模块？如果worker托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么回写到业务方的数据库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E7%94%A8MySQL%E4%B8%8D%E7%94%A8Redis%EF%BC%9F"><span class="toc-text">为什么存储用MySQL不用Redis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E7%94%A8MySQL%E4%B8%8D%E7%94%A8MongoDB%EF%BC%9F"><span class="toc-text">为什么存储用MySQL不用MongoDB？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%8C%E5%AD%98%E4%B8%8D%E4%B8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">上下文怎么存储的，存不下怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">讲讲任务创建的流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E6%8B%89%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">讲讲拉取任务接口的流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2-worker-%E6%98%AF%E6%89%8B%E5%8A%A8%E8%BF%98%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8F%91%E8%AF%B7%E6%B1%82%E6%8B%89%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-text">项目里面 worker 是手动还是自动发请求拉任务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E7%9A%84MySQL%E4%B8%AD%E6%9F%A5%E8%AF%A2%E6%98%AF%E6%9F%A5%E4%B8%80%E5%A4%A7%E6%89%B9%E8%BF%98%E6%98%AF%E6%9F%A5%E4%B8%80%E4%B8%AA%EF%BC%9F"><span class="toc-text">你们的MySQL中查询是查一大批还是查一个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8B%89%E5%8F%96%E6%8C%89%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">任务拉取按什么顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%B0%BD%E7%AE%A1%E5%8A%A0%E4%B8%8A%E4%BA%86%E9%87%8D%E8%AF%95%E9%97%B4%E9%9A%94%EF%BC%8C%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E9%97%B4%E9%9A%94%E5%88%B0%E8%BE%BE%E4%B9%8B%E5%89%8D%E4%B9%9F%E8%83%BD%E8%A2%AB%E6%8B%89%E5%8F%96%E5%88%B0%E5%90%97%EF%BC%9F"><span class="toc-text">如果数据库只有一个任务，尽管加上了重试间隔，失败重试间隔到达之前也能被拉取到吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">优先级是怎么设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%97%B6%E5%80%99priority%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么大多时候priority都是一样的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%E7%9A%84%E8%BF%99%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E6%83%B3%E8%BF%87%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%BC%98%E5%85%88%E7%BA%A7A%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7B%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8CA%E6%AF%94B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%98%E5%85%88%EF%BC%9F"><span class="toc-text">你说的这个优先级，和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少，A比B为什么优先？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%A7%89%E5%BE%97%E4%BD%A0%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E8%AE%A1%E6%98%AF%E7%BB%9D%E5%AF%B9%E4%BC%98%E5%85%88%E8%BF%98%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BC%98%E5%85%88%EF%BC%9F"><span class="toc-text">你觉得你的优先级设计是绝对优先还是相对优先？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E9%97%B4%E9%9A%94%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">重试间隔是什么机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BD%AE%E8%AF%A2%E5%90%97%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%90%A6%E8%B6%85%E6%97%B6%EF%BC%8C%E6%9C%89%E6%97%A0%E6%9B%B4%E5%A5%BD%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-text">服务端怎么知道任务超时了，定时器轮询吗，判断任务是否超时，有无更好办法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%A6%82%E6%9E%9C%E6%89%A7%E8%A1%8C%E4%B8%AD%E5%A4%B1%E8%B4%A5%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">任务如果执行中失败了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-%E6%80%8E%E4%B9%88%E7%AB%9E%E4%BA%89%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-text">Worker 怎么竞争任务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-MySQL-%E8%87%AA%E5%B8%A6%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">为什么不用 MySQL 自带的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%86%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%A4%9A%E4%B8%AAworker%E5%90%8C%E6%97%B6%E6%8B%BF%E5%88%B0%E5%90%97%EF%BC%9F"><span class="toc-text">用了分布式锁，一个任务就一定不会被多个worker同时拿到吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">竞争分布式锁这种方式，会不会有什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8MySQL%E9%94%81%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BC%9A%E8%AE%A9CPU%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%9F"><span class="toc-text">为什么用MySQL锁的方案，会让CPU不稳定？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8A%A0%E5%9C%A8%E5%8D%A0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%8D%A0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E5%B0%B1%E8%A7%A3%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%8B%89%E5%8F%96%E5%92%8C%E6%89%A7%E8%A1%8C%E8%80%A6%E5%90%88%E4%BA%86%EF%BC%9F"><span class="toc-text">分布式锁加在占据任务之前，占据任务完成之后就解锁，为什么说拉取和执行耦合了？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8Redis%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9C%BA%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%EF%BC%9F%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%B0%E6%96%B9%E6%A1%88"><span class="toc-text">不使用Redis，如何解决多机竞争问题？设计一个新方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E5%A4%9A%E5%8F%B0worker%E7%AB%9E%E4%BA%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E9%82%A3%E8%BF%99%E6%A0%B7%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%9C%89%E4%BA%9Bworker%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%A4%A7%E9%87%8F%E4%BB%BB%E5%8A%A1%E4%BD%86%E6%98%AF%E4%B8%80%E9%83%A8%E5%88%86worker%E5%A4%84%E4%BA%8E%E7%A9%BA%E9%97%B2%E7%9A%84%E7%8A%B6%E6%80%81%E5%91%A2%EF%BC%9F"><span class="toc-text">你采用的是多台worker竞争任务的方式，那这样会不会出现有些worker在执行大量任务但是一部分worker处于空闲的状态呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%A6%82%E6%9E%9C%E6%89%A7%E8%A1%8C%E4%B8%AD-worker-%E6%8C%82%E6%8E%89%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">任务如果执行中 worker 挂掉怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%BE%97%E5%87%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%E5%BE%88%E5%B7%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A6%81%E5%BC%95%E5%85%A5MQ%E7%9A%84%E7%BB%93%E8%AE%BA%E7%9A%84%E5%91%A2%EF%BC%9F%E6%98%AF%E7%90%86%E8%AE%BA%E4%B8%8A%E8%A7%89%E5%BE%97%E6%AF%94%E8%BE%83%E5%B7%AE%E8%BF%98%E6%98%AF%E5%AE%9E%E9%99%85%E4%B8%8A%E8%A7%82%E5%AF%9F%E5%88%B0%E7%9A%84%E6%AF%94%E8%BE%83%E5%B7%AE%E3%80%82%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%98%AF%E5%85%88%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%8D%E6%83%B3%E7%9D%80%E5%8E%BB%E4%BC%98%E5%8C%96%E5%90%A7%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8B%8D%E8%84%91%E8%A2%8B%E7%9A%84%E4%B8%AA%E5%86%B3%E5%AE%9A%E3%80%82"><span class="toc-text">那你是怎么得出分布式锁的性能很差，然后要引入MQ的结论的呢？是理论上觉得比较差还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的个决定。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%94%A8-MySQL-%E6%98%AF%E6%AF%94%E8%BE%83%E5%A4%9A%E7%9A%84%EF%BC%8C%E9%82%A3%E6%9C%89%E7%94%A8%E5%88%B0%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="toc-text">你在这个项目里用 MySQL 是比较多的，那有用到事务吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%BE%88%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">如果有很多个客户端一起使用这个框架，可能会发生什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%A4%9A%E4%B8%AAflowsvr%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%A9%E4%B8%8D%E5%90%8C%E7%9A%84flowsvr%E4%B8%8D%E8%A6%81%E6%8B%89%E5%80%92%E5%90%8C%E6%A0%B7%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-text">有多个flowsvr的话，怎么让不同的flowsvr不要拉倒同样的任务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%A1%B9%E7%9B%AE%E9%85%8D%E5%A5%97%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2%EF%BC%9F"><span class="toc-text">用户怎么知道任务的执行情况？有没有项目配套的可视化界面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%B7%B1%E5%86%99%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-text">分表为什么自己写，为什么不用组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E9%9A%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">分表难在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%BD%A0%E7%9A%84%E5%88%86%E8%A1%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">介绍你的分表方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E5%A4%A7%E5%B0%8F%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-text">为什么按大小分表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E8%A7%89%E5%BE%97%E4%B8%8E%E5%85%B6%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%9A%E8%BF%87%E6%97%B6%E9%97%B4%E5%88%86%E8%A1%A8%E5%91%A2%EF%BC%9F%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BA%94%E8%AF%A5%E6%8C%BA%E5%A4%8D%E6%9D%82%E7%9A%84%EF%BC%8C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95%E4%BB%BB%E5%8A%A1%E4%BD%8D%E7%BD%AE%EF%BC%8C%E6%88%91%E5%8F%AF%E4%BB%A5%E9%A2%84%E4%BC%B0%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%87%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E5%88%86%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82%E6%AF%94%E5%A6%82%E4%BD%A0%E4%B8%80%E5%A4%A910W%E6%9D%A1%EF%BC%8C10%E5%A4%A9100W%EF%BC%8C%E9%82%A3%E4%BD%A0%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%88%86%E4%B8%80%E6%AC%A1%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%8C%E4%B8%8D%E7%94%A8%E8%BF%99%E4%B9%88%E9%BA%BB%E7%83%A6"><span class="toc-text">我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天10W条，10天100W，那你两个月分一次就可以了，不用这么麻烦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%B8%BA%E4%BA%86%E9%A1%B9%E7%9B%AE%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6%EF%BC%9F%E4%BD%A0%E9%87%8F%E8%BF%99%E4%B9%88%E5%B0%8F%EF%BC%8C%E5%BC%84500w%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-text">你为了项目做了一个框架？你量这么小，弄500w分表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flowsvr%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%88%B0%E8%BE%BE%E5%88%86%E8%A1%A8%E9%98%88%E5%80%BC%E4%BA%86%EF%BC%8C%E8%BD%AE%E8%AF%A2%E5%90%97%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E7%BB%86%E8%8A%82%E5%90%97%EF%BC%9F"><span class="toc-text">flowsvr怎么知道到达分表阈值了，轮询吗，这里有细节吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AF%BB%E5%86%99%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%88%B0%E8%B6%85%E8%BF%87MySQL%E7%9A%84%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E5%91%A2%EF%BC%8C%E6%AF%94%E5%A6%82%E4%B8%80%E4%B8%AAMySQL%E5%81%87%E8%AE%BE%E5%B0%B1%E6%98%AF8000-s%E7%9A%84%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%AD%A4%E6%97%B6%E8%AF%B7%E6%B1%82%E6%9C%892%E4%B8%87%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91%E7%9A%84"><span class="toc-text">如果读写请求大到超过MySQL的处理能力呢，比如一个MySQL假设就是8000&#x2F;s的处理能力，此时请求有2万，这个是怎么考虑的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0schedule-beign-pos%E5%92%8Cschedule-end-pos%E8%B7%A8%E4%B8%8D%E6%AD%A21%E5%BC%A0%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">会不会出现schedule_beign_pos和schedule_end_pos跨不止1张表的情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%88%86%E8%A1%A8%E7%9A%84%E9%98%88%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E6%8E%A8%E8%8D%90%EF%BC%9F"><span class="toc-text">推荐分表的阈值是多少？为什么这么推荐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BB%BB%E5%8A%A1%E5%85%A8%E5%88%B01%E5%8F%B7%E8%A1%A8%EF%BC%8C0%E5%8F%B7%E8%A1%A8%E6%98%AF%E6%B8%85%E6%8E%89%E5%90%97%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E5%8F%A5%E6%B8%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E5%81%9A%E8%AE%BE%E8%AE%A1%E5%90%97%EF%BC%9F"><span class="toc-text">分表时，如果任务全到1号表，0号表是清掉吗？用什么语句清，为什么，这里有做设计吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E7%BB%A7%E7%BB%AD%E5%BE%800-1-2-3-4%E5%8F%B7%E8%A1%A8%E6%BB%9A%E5%8A%A8%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%B8%8D%E5%B0%B1%E6%94%AF%E6%8C%81%E6%9B%B4%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%BA%86%EF%BC%9F"><span class="toc-text">能否继续往0 1 2 3 4号表滚动，这样不就支持更多任务了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%AF%B9%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF%E8%A1%A8%E5%88%86%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%8C%89%E7%85%A7%E4%BB%BB%E5%8A%A1id%E5%88%86%E8%A1%A8%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A%E5%A4%A7%E4%BA%8E500w%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%8C%E5%A4%A7%E4%BA%8E1000w%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F"><span class="toc-text">你是对任务信息表分表，为什么不直接按照任务id分表，比如：大于500w一张表，大于1000w一张表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%88%86%E8%A1%A8%E4%B8%AD%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%9F%90%E4%BA%9B%E5%8E%9F%E5%9B%A0%E8%80%81%E8%A1%A8%E8%BF%9F%E8%BF%9F%E6%B2%A1%E5%81%9A%E5%AE%8C%EF%BC%8C%E6%96%B0%E8%A1%A8%E7%9A%84%E9%AB%98%E4%BC%98%E4%BB%BB%E5%8A%A1%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%A5%BF%E6%AD%BB%EF%BC%9F"><span class="toc-text">如果分表中，因为某些原因老表迟迟没做完，新表的高优任务会不会饿死？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%BB%E9%94%AE%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">Async分表之后，怎么解决的主键冲突？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">这个框架的性能怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-text">选的是什么数据来测试？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一开始的性能瓶颈是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E7%9A%84%EF%BC%9F"><span class="toc-text">你是怎么测试的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AA%81%E7%84%B6%E6%9C%89%E7%89%B9%E5%88%AB%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F%E4%B8%8D%E8%80%83%E8%99%91%E5%AF%B9worker%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%EF%BC%8C%E4%B8%8D%E8%80%83%E8%99%91%E5%A2%9E%E5%8A%A0%E6%9C%BA%E5%99%A8%EF%BC%8C%E6%AF%94%E5%A6%82%E5%B0%B1%E5%A4%9A%E4%BA%8650-%E8%BF%99%E6%A0%B7%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9A%84%E7%93%B6%E9%A2%88%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%BC%9A%E5%87%BA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">如果突然有特别多数据怎么处理呢？不考虑对worker进行扩容，不考虑增加机器，比如就多了50%这样的需求，框架的的瓶颈在什么地方？这个模块会出什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%91%E7%8E%B0%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%A7%AF%E5%8E%8B%E4%BA%86%E7%94%A9%E7%BB%99-worker-%E4%B8%8D%E7%AE%A1%E4%BA%86%EF%BC%9F"><span class="toc-text">任务积压怎么解决，怎么发现，不能说积压了甩给 worker 不管了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%E7%9A%84%EF%BC%9F%EF%BC%88Java%EF%BC%89"><span class="toc-text">如何调优的？（Java）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flowsrv-%E6%80%A7%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%8C%E7%93%B6%E9%A2%88%E7%82%B9%E6%98%AF%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">flowsrv 性能是怎么优化的，瓶颈点是哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%B8%8D%E6%98%AF%E8%AF%B4%E4%BD%A0%E7%9A%84worker%E5%8F%AA%E6%9C%89%E5%85%AD%E5%8F%B0%E5%90%97%EF%BC%9F%E5%85%AD%E5%8F%B0worker%E6%8B%89%E5%8F%96%E4%BB%BB%E5%8A%A1%E9%9C%80%E8%A6%812000QPS%EF%BC%9F"><span class="toc-text">你不是说你的worker只有六台吗？六台worker拉取任务需要2000QPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%89%B9%E5%88%AB%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E4%BD%A0%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">任务特别多怎么办？你的框架会怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%85%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%BF%87%E5%A4%9A%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8-worker-%E6%89%A9%E5%AE%B9%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">待处理的任务过多时，不允许 worker 扩容的情况下怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#500QPS%E4%BD%A0%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%A4%9F%E7%94%A8%E5%90%97%EF%BC%9F%E8%BF%98%E9%9C%80%E8%A6%81%E6%8F%90%E5%8D%87%E5%88%B02000QPS%EF%BC%9F"><span class="toc-text">500QPS你这个项目不够用吗？还需要提升到2000QPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%AA%E9%9C%80%E6%B1%82%E8%A6%81%E6%B1%82%E4%BB%8E-500-QPS%E6%8F%90%E5%8D%87%E5%88%B0-50000-QPS%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-text">我现在有个需求要求从 500 QPS提升到 50000 QPS谈谈你的思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%AF%B9%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8CSQL%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-text">你有对项目进行SQL调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E5%A6%82%E8%AF%B4%E4%BD%A0%E5%83%8F%E5%A6%82%E6%9E%9C%E8%AF%B4%E8%A6%81%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%8C%E9%A6%96%E5%85%88%E6%98%AF%E5%AE%83%E8%BF%99%E4%B8%AA%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F%E8%BF%99%E4%B8%AA%E7%89%B9%E6%80%A7%E4%B8%8A%E9%9D%A2%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E8%80%83%E8%99%91%E5%B9%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E6%9E%9C%E5%81%9A%E6%B5%81%E7%A8%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%88%91%E8%A7%89%E5%BE%97%E8%BF%99%E8%BF%99%E4%B8%AA%E7%82%B9%E6%98%AF%E8%82%AF%E5%AE%9A%E6%98%AF%E8%A6%81%E7%9D%80%E9%87%8D%E5%8E%BB%E8%80%83%E8%99%91%E3%80%82"><span class="toc-text">比如说你像如果说要做一个流程，首先是它这个稳定性对不对？这个特性上面你是怎么去考虑并设计的？就是如果做流程系统的话，我觉得这这个点是肯定是要着重去考虑。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%A7%89%E5%BE%97%E4%BD%A0%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你觉得你这个项目的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你的框架的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%EF%BC%88Java%EF%BC%89"><span class="toc-text">Async 用了哪些个线程池？（Java）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88Java%EF%BC%89"><span class="toc-text">Async 分布式锁怎么实现的？（Java）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%A4%9A%E5%B0%91%EF%BC%9F%EF%BC%88Java%EF%BC%89"><span class="toc-text">Async 线程池的参数设置了多少？（Java）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%8E%E4%B9%88%E5%90%88%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-text">数据库连接池怎么合理的设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E7%94%A8%E4%BB%80%E4%B9%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F%EF%BC%88Java%EF%BC%89"><span class="toc-text">Async 用什么垃圾回收算法？（Java）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">Async 用了什么设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E9%87%8F%E6%9C%89%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%BD%93%E6%97%B6%E5%81%9A%E4%BA%86%E5%A4%9A%E4%B9%85%EF%BC%9F"><span class="toc-text">项目代码量有多少？当时做了多久？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">你的项目最大的难点是什么？怎么解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88bug%EF%BC%9F"><span class="toc-text">开发过程中有出现什么bug？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/" title="02 SpringCloud 笔记"><img alt="02 SpringCloud 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/SpringCloud_2025-01-15.png"></a><div class="content"><a class="title" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/" title="02 SpringCloud 笔记">02 SpringCloud 笔记</a><a class="article-recent_post_categories" href="/2025/01/15/SpringCloud%E7%AC%94%E8%AE%B0/">Spring</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记"><img alt="00 Kafka 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/kafka_log.png"></a><div class="content"><a class="title" href="/2025/01/10/00-Kafka/" title="00 Kafka 笔记">00 Kafka 笔记</a><a class="article-recent_post_categories" href="/2025/01/10/00-Kafka/">MQ</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记"><img alt="00 操作系统知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/caozuoxitong.png"></a><div class="content"><a class="title" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 操作系统知识点归纳 笔记">00 操作系统知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2025/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记"><img alt="00 计算机网络知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/computer_network.png"></a><div class="content"><a class="title" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="00 计算机网络知识点归纳 笔记">00 计算机网络知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Others</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记"><img alt="06 Redis知识点归纳 笔记" src="https://coo1heisenberg-blog.oss-cn-shanghai.aliyuncs.com/redis_conclude.png"></a><div class="content"><a class="title" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/" title="06 Redis知识点归纳 笔记">06 Redis知识点归纳 笔记</a><a class="article-recent_post_categories" href="/2024/12/21/01-redis%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3/">Database</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Solitude</span></div><div class="footer-bar-description">来自 Heisenberg 的原创文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 - 2025 By&nbsp;<a class="footer-bar-link" href="/">Coo1heisenberg’s BLOG</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.10.6"></script><script src="/js/main.js?v=1.10.6"></script><script src="/js/third_party/waterfall.min.js?v=1.10.6"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.10.6"></script><script>dark()
</script><script src="//open.lightxi.com/cdnjs/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="//open.lightxi.com/cdnjs/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="//open.lightxi.com/cdnjs/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="//open.lightxi.com/cdnjs/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script defer pjax src="//open.lightxi.com/cdnjs/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.10.6"></script><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["2025/01/15/SpringCloud笔记/","2025/01/10/00-Kafka/","2025/01/04/操作系统知识点归纳/","2024/12/24/计算机网络知识点归纳/","2024/12/21/01-redis知识点归纳/","2024/12/16/01-MySQL知识点归纳/","2024/12/04/Spring框架/","2024/12/02/Java-JVM虚拟机/","2024/11/04/Java-并发编程/","2024/11/01/Java-集合框架/","2024/09/28/00-前端开发入门教程/","2024/09/26/01-空间转录组/","2024/09/13/00-单细胞多组学分析/","2024/07/22/00-MongoDB/","2024/07/17/00-elasticsearch/","2024/07/15/01-黑马redis/","2024/07/13/00-黑马redis/","2024/07/08/00-黑马SSM/","2024/07/08/01-头条点评项目/","2024/07/06/00-Mybatis-Plus/","2024/06/29/00-黑马MySQL/","2024/06/25/00-头条点评项目/","2024/06/21/02-Python/","2024/06/11/01-Python/","2024/05/25/00-Python/","2024/05/13/DesignPattern/","2024/05/13/Docker/","2024/05/13/Nginx/","2024/05/13/Linux/","2024/05/07/00-spike-program/","2024/01/09/00-Asynchronous-framework/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>